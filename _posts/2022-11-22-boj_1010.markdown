---
title: "[BOJ] 다리 놓기 - 1010"
author: kwon
date: 2022-11-22T23:00:00 +0900
categories: [boj]
tags: [math, dynamic programing, combinatorics]
math: true
mermaid: false
---

| 시간 제한 | 메모리 제한 |
| --- | --- |
| 0.5 초 (추가 시간 없음) | 128 MB |

# 문제

재원이는 한 도시의 시장이 되었다. 이 도시에는 도시를 동쪽과 서쪽으로 나누는 큰 일직선 모양의 강이 흐르고 있다. 하지만 재원이는 다리가 없어서 시민들이 강을 건너는데 큰 불편을 겪고 있음을 알고 다리를 짓기로 결심하였다. 강 주변에서 다리를 짓기에 적합한 곳을 사이트라고 한다. 재원이는 강 주변을 면밀히 조사해 본 결과 강의 서쪽에는 N개의 사이트가 있고 동쪽에는 M개의 사이트가 있다는 것을 알았다. (N ≤ M)

재원이는 서쪽의 사이트와 동쪽의 사이트를 다리로 연결하려고 한다. (이때 한 사이트에는 최대 한 개의 다리만 연결될 수 있다.) 재원이는 다리를 최대한 많이 지으려고 하기 때문에 서쪽의 사이트 개수만큼 (N개) 다리를 지으려고 한다. 다리끼리는 서로 겹쳐질 수 없다고 할 때 다리를 지을 수 있는 경우의 수를 구하는 프로그램을 작성하라.

![https://www.acmicpc.net/upload/201003/pic1.JPG](https://www.acmicpc.net/upload/201003/pic1.JPG)

# 입력

입력의 첫 줄에는 테스트 케이스의 개수 T가 주어진다. 그 다음 줄부터 각각의 테스트 케이스에 대해 강의 서쪽과 동쪽에 있는 사이트의 개수 정수 N, M (0 < N ≤ M < 30)이 주어진다.

# 출력

각 테스트 케이스에 대해 주어진 조건 하에 다리를 지을 수 있는 경우의 수를 출력한다.

# 풀이

## 조합

서쪽의 다리의 개수만큼 동쪽의 다리를 고르는 문제로 생각할 수 있다. 하지만 주의할 점은 다리가 교차되면 안된다는 것이다. 때문에 순서를 생각하지 않고 서쪽의 다리를 동쪽 다리 개수만큼 골라야 한다.

순서 없이 M개를 고른 후 서쪽 다리의 위부터, 고른 다리의 위부터 내려가면서 이어준다. 위부터 차례대로 이어주면  다리가 교차되는 일이 없고 순서는 딱 한 가지만 주어진다.

그러므로 순서 없이 고르는 조합${m}\choose{n}$을 이용하면 된다.

### 코드

```python
from math import factorial as fac
t = int(input())
for _ in range(t):
    n, m = map(int, input().split())
    print(fac(m) // (fac(n) * fac(m - n)))
```

## 동적 프로그래밍

다리를 이을 수 있는 쌍을 재귀로 반복하면서 개수를 찾는다. `b1`, `b2`는 각각 서-동쪽의 사이트 번호이며 `b1`이 N이 됐을 때 모든 다리가 이어진 것이므로 다리를 잇는 경우를 하나 찾았다는 의미로 1을 return한다.

탐색은 위부터 시작하며 각 탐색의 범위는 직전에 연결했던 사이트의 다음(`b2+ 1`)부터 남은 서쪽 사이트 개수만큼 남을 때까지(`(b2 + 1) + m - n`)이다. 끝나는 범위가 앞선 식으로 계산되는 이유는 남아있는 서쪽 사이트가 연결될 수 있는 동쪽 사이트가 남아 있어야 하기 때문이다.

예를 들어  n, m이 각각 4, 7이고 현재 연결하려는 사이트를 포함하여 남아있는 서쪽 사이트가 3개, 동쪽 사이트는 5 개라고 한다면, 현재 사이트를 연결하고 남아있는 동쪽 사이트가 최소 2 개는 되어야 하기 때문에 1 + (7 - 4) + 1 = 5로 동쪽의 5번째 사이트까지만 연결이 가능하다.

```python
def dp(b1, b2, n, m):
    global memo
    if b1 == n:
        return 1
    cnt = 0
    for i in range(b2 + 1, min(m, b2 + m - n + 1) + 1):
        if (b1 + 1, i) in memo:
            cnt += memo[(b1 + 1, i)]
        else:
            tmp = dp(b1 + 1, i, n, m)
            cnt += tmp
            memo[(b1 + 1, i)] = tmp
    return cnt

t = int(input())
for _ in range(t):
    memo = {}
    n, m = map(int, input().split())
    print(dp(0, 0, n, m))
```