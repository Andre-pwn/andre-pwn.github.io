---
title: 데이터베이스 트랜잭션 - 2
authors: jongin_kim
date: 2022-12-28 01:48:00 +0900
categories: [데이터베이스]
tags: [database, transaction]
---
## 직렬성 (=serializable)
- 격리수준의 문제
	- 위에서 공부한 것 처럼 격리 수준은 너무 어렵고 복잡하다. 그리고 모든 문제를 해결해주지 못한다.
	- 또 데이터베이스의 구현마다 그 격리 수준의 동작 방식은 조금씩 다르다.
	- 어떤 로직에는 어떤 격리수준이 안전한지 파악하는 일이라는건 쉬운일이 아니다.
	- 경쟁조건을 완벽하게 감지하는 방법은 없다.
- 이에 대한 연구자들의 답은 항상 같았다 직렬성 (=serializable) 격리를 사용해라..!
- 직렬성 (=serializable)
	- 가장 강력한 격리
	- ::여러 트랜잭션이 병렬로 실행되더라도 최종 결과는 동시성 없이 한 번에 하나씩 직렬로 실행될 때와 같도록 보장한다.::
	- 데이터베이스가 발생할 수 있는 모든 경쟁 조건을 막아준다.
	- **그런데 우리는 왜 모든 직렬성 (=serializable) 격리를 사용하지 않는거지?**

### 실제적인 직렬 실행
### 2단계 잠금 (2PL)
### 직렬성 스냅숏 격리 (SSI)
---
title: 데이터베이스 트랜잭션 - 2
authors: jongin_kim
date: 2022-12-28 01:48:00 +0900
categories: [데이터베이스]
tags: [database, transaction]
---
## 직렬성 (=serializable)
- 격리수준의 문제
	- 위에서 공부한 것 처럼 격리 수준은 너무 어렵고 복잡하다. 그리고 모든 문제를 해결해주지 못한다.
	- 또 데이터베이스의 구현마다 그 격리 수준의 동작 방식은 조금씩 다르다.
	- 어떤 로직에는 어떤 격리수준이 안전한지 파악하는 일이라는건 쉬운일이 아니다.
	- 경쟁조건을 완벽하게 감지하는 방법은 없다.
- 이에 대한 연구자들의 답은 항상 같았다 직렬성 (=serializable) 격리를 사용해라..!
- 직렬성 (=serializable)
	- 가장 강력한 격리
	- ::여러 트랜잭션이 병렬로 실행되더라도 최종 결과는 동시성 없이 한 번에 하나씩 직렬로 실행될 때와 같도록 보장한다.::
	- 데이터베이스가 발생할 수 있는 모든 경쟁 조건을 막아준다.
	- **그런데 우리는 왜 모든 직렬성 (=serializable) 격리를 사용하지 않는거지?**

### 실제적인 직렬 실행
### 2단계 잠금 (2PL)
### 직렬성 스냅숏 격리 (SSI)
---
title: 데이터베이스 트랜잭션 - 2
authors: jongin_kim
date: 2022-12-28 01:48:00 +0900
categories: [데이터베이스]
tags: [database, transaction]
---
## 직렬성 (=serializable)
- 격리수준의 문제
	- 위에서 공부한 것 처럼 격리 수준은 너무 어렵고 복잡하다. 그리고 모든 문제를 해결해주지 못한다.
	- 또 데이터베이스의 구현마다 그 격리 수준의 동작 방식은 조금씩 다르다.
	- 어떤 로직에는 어떤 격리수준이 안전한지 파악하는 일이라는건 쉬운일이 아니다.
	- 경쟁조건을 완벽하게 감지하는 방법은 없다.
- 이에 대한 연구자들의 답은 항상 같았다 직렬성 (=serializable) 격리를 사용해라..!
- 직렬성 (=serializable)
	- 가장 강력한 격리
	- ::여러 트랜잭션이 병렬로 실행되더라도 최종 결과는 동시성 없이 한 번에 하나씩 직렬로 실행될 때와 같도록 보장한다.::
	- 데이터베이스가 발생할 수 있는 모든 경쟁 조건을 막아준다.
	- **그런데 우리는 왜 모든 직렬성 (=serializable) 격리를 사용하지 않는거지?**

### 실제적인 직렬 실행
### 2단계 잠금 (2PL)
### 직렬성 스냅숏 격리 (SSI)
