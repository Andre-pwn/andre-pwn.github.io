---
title: BigData - MongoDB
date: 2020-11-11 11:11:11 -0400
categories: [00Basic, 50BigData]
tags: [BigData, MongoDB]
toc: true
image:
---

- [BigData - MongoDB](#bigdata---mongodb)
  - [overall](#overall)
  - [Compponent](#compponent)
    - [数据库 Database](#数据库-database)
    - [文档 Document](#文档-document)
    - [集合 collections](#集合-collections)
    - [capped collections](#capped-collections)
    - [元数据](#元数据)
  - [MongoDB feature](#mongodb-feature)
    - [复制（副本集）](#复制副本集)
    - [分片](#分片)
    - [备份(mongodump)与恢复(mongorestore)](#备份mongodump与恢复mongorestore)
    - [监控](#监控)
  - [MongoDB 数据类型](#mongodb-数据类型)
    - [ObjectId](#objectid)
    - [string](#string)
    - [时间戳](#时间戳)
    - [日期](#日期)
  - [Basic](#basic)
    - [创建删除数据库](#创建删除数据库)
    - [创建删除集合](#创建删除集合)
    - [插入文档](#插入文档)
    - [更新文档](#更新文档)
    - [删除文档](#删除文档)
    - [查询文档](#查询文档)
      - [AND 条件](#and-条件)
      - [OR 条件](#or-条件)
      - [AND 和 OR 联合使用](#and-和-or-联合使用)
      - [条件操作符](#条件操作符)
      - [`$type` 操作符](#type-操作符)
      - [`Limit()` 与 `Skip()`](#limit-与-skip)
    - [排序](#排序)
  - [index](#index)
    - [索引](#索引)
    - [聚合](#聚合)
  - [deduplicate](#deduplicate)
    - [group](#group)
    - [index](#index-1)
      - [没有并发的环境](#没有并发的环境)
      - [存在并发的环境 - 唯一索引](#存在并发的环境---唯一索引)


---

# BigData - MongoDB

---

## overall

- 由C++语言编写
- 一个基于分布式文件存储的开源数据库系统。
- 在高负载的情况下，添加更多的节点，可以保证服务器性能。
- 旨在为WEB应用提供可扩展的高性能数据存储解决方案。
- 将数据存储为一个文档，数据结构由键值(key=>value)对组成。
- MongoDB文档类似于 JSON 对象。字段值可以包含其他文档，数组及文档数组。

- MongoDB 是一个面向文档存储的数据库，操作起来比较简单和容易。
- 可以在MongoDB记录中设置任何属性的索引 (如：FirstName="Sameer",Address="8 Gandhi Road")来实现更快的排序。
- 可以通过本地或者网络创建数据镜像，这使得MongoDB有更强的扩展性。
- 如果负载的增加（需要更多的存储空间和更强的处理能力）, 它可以分布在计算机网络中的其他节点上这就是所谓的分片。
- Mongo支持丰富的查询表达式。
  - 查询指令使用JSON形式的标记，可轻易查询文档中内嵌的对象及数组。

- MongoDb 使用update()命令可以实现替换完成的文档（数据）或者一些指定的数据字段 。

- Mongodb中的Map/reduce主要是用来对数据进行批量处理和聚合操作。

- Map和Reduce。
  - Map函数调用emit(key,value)遍历集合中所有的记录，将key与value传给Reduce函数进行处理。
  - Map函数和Reduce函数是使用Javascript编写的，并可以通过db.runCommand或mapreduce命令来执行MapReduce操作。

- GridFS是MongoDB中的一个内置功能，可以用于存放大量小文件。

- MongoDB允许在服务端执行脚本，可以用Javascript编写某个函数，直接在服务端执行，也可以把函数的定义存储在服务端，下次直接调用即可。

- MongoDB支持各种编程语言:RUBY，PYTHON，JAVA，C++，PHP，C#等多种语言。

- MongoDB安装简单。

---


## Compponent

![Figure-1-Mapping-Table-to-Collection-1](https://i.imgur.com/vgzfCPi.png)

mongodb中基本的概念是文档、集合、数据库

| SQL         | MongoDB     | 解释说明                              |
| ----------- | ----------- | ------------------------------------- |
| database    | database    | 数据库                                |
| table       | collection  | 数据库表/集合                         |
| row         | document    | 数据记录行/文档                       |
| column      | field       | 数据字段/域                           |
| index       | index       | 索引                                  |
| table       | joins       | 表连接,MongoDB不支持                  |
| primary key | primary key | 主键,MongoDB自动将`_id`字段设置为主键 |

---

### 数据库 Database

- 一个mongodb中可以建立多个数据库。

- MongoDB的默认数据库为"db"，该数据库存储在data目录中。

- MongoDB的单个实例可以容纳多个独立的数据库，每一个都有自己的集合和权限，不同的数据库也放置在不同的文件中。

```bash
$ ./mongo
MongoDB shell version: 3.0.6
connecting to: test

# "show dbs" 命令可以显示所有数据的列表。
> show dbs
local  0.078GB
test   0.078GB

# 执行 "db" 命令可以显示当前数据库对象或集合。
> db
test


# 运行"use"命令，可以连接到一个指定的数据库。
> use local
switched to db local
> db
local
```


- 数据库也通过名字来标识。数据库名可以是满足以下条件的任意UTF-8字符串。
- 不能是空字符串
- 不得含有`' '（空格)、.、$、/、\和\0 (空字符)`
- 应全部小写。
- 最多64字节。
- 有一些数据库名是保留的，可以直接访问这些有特殊作用的数据库。
  - admin： 从权限的角度来看，这是"root"数据库。要是将一个用户添加到这个数据库，这个用户自动继承所有数据库的权限。一些特定的服务器端命令也只能从这个数据库运行，比如列出所有的数据库或者关闭服务器。
  - local: 这个数据永远不会被复制，可以用来存储限于本地单台服务器的任意集合
  - config: 当Mongo用于分片设置时，config数据库在内部使用，用于保存分片的相关信息。

---

### 文档 Document

- 文档是一组键值(key-value)对(即 BSON)。

- MongoDB 的文档不需要设置相同的字段，并且相同的字段不需要相同的数据类型，这与关系型数据库有很大的区别，也是 MongoDB 非常突出的特点。

```json
// 一个简单的文档例子如下：
{"site":"www.runoob.com", "name":"Grace"}
```

注意:
- 文档中的键/值对是有序的。
- 文档中的值不仅可以是在双引号里面的字符串，还可以是其他几种数据类型, 甚至可以是整个嵌入的文档
- MongoDB区分类型和大小写。
- MongoDB的文档`不能有重复的键`。
- 文档的键是字符串。除了少数例外情况，键可以使用任意UTF-8字符。

文档键命名规范：
- 键不能含有`\0 (空字符)`。这个字符用来表示键的结尾。
- `.和$`有特别的意义，只有在特定环境下才能使用。
- 以下划线`"_"`开头的键是保留的(不是严格要求的)。

---

### 集合 collections

- `集合` 就是 MongoDB 文档组，类似于 RDBMS, 关系数据库管理系统, Relational Database Management System 中的表格。

- 集合存在于数据库中，集合没有固定的结构，这意味着你在对集合可以插入不同格式和类型的数据，但通常情况下我们插入集合的数据都会有一定的关联性。

```json
// 比如，我们可以将以下不同数据结构的文档插入到集合中：
{"site":"www.baidu.com"}
{"site":"www.google.com","name":"Google"}
{"site":"www.runoob.com","name":"Grace","num":5}
```

- 当第一个文档插入时，集合就会被创建。


合法的集合名
- 集合名不能是`空字符串""`。
- 集合名不能含有`\0字符（空字符)`，这个字符表示集合名的结尾。
- 集合名不能以`"system."`开头，这是为系统集合保留的前缀。
- 用户创建的集合名字不能含有保留字符。有些驱动程序的确支持在集合名里面包含，这是因为某些系统生成的集合中包含该字符。除非你要访问这种系统创建的集合，否则千万不要在名字里出现`$`。　

```py
# 如下实例：
db.col.findOne()
```

### capped collections

- 固定大小的collection。

- 它有很高的性能以及队列过期的特性(过期按照插入的顺序). 有点和 "RRD" 概念类似。

- 是高性能自动的维护对象的插入顺序。它非常适合类似记录日志的功能

- 和标准的 collection 不同，你必须要显式的创建一个capped collection，指定一个 collection 的大小，单位是字节。collection 的数据存储空间值提前分配的。

- 可以按照文档的插入顺序保存到集合中，而且这些文档在磁盘上存放位置也是按照插入顺序来保存的，所以当我们更新Capped collections 中文档的时候，更新后的文档不可以超过之前文档的大小，这样话就可以确保所有文档在磁盘上的位置一直保持不变。

- 由于 Capped collection 是按照文档的插入顺序而不是使用索引确定插入位置，这样的话可以提高增添数据的效率。MongoDB 的操作日志文件 oplog.rs 就是利用 Capped Collection 来实现的。

- 要注意的是指定的存储大小包含了数据库的头信息。

```py
db.createCollection("mycoll", {capped:true, size:100000})
```

- 在 capped collection 中，你能添加新的对象。

- 能进行更新，然而，对象不会增加存储空间。如果增加，更新就会失败 。

- 不能删除一个文档，可以使用 drop() 方法删除 collection 所有的行。

- 删除之后，你必须显式的重新创建这个 collection。

- 在32bit机器中，capped collection 最大存储为 1e9( 1X109)个字节。


---

### 元数据

- 数据库的信息是存储在集合中。它们使用了系统的命名空间：

```py
dbname.system.*
```

在MongoDB数据库中`名字空间 <dbname>.system.*` 是包含多种系统信息的特殊集合(Collection)，如下:

```py
集合命名空间	描述
dbname.system.namespaces	列出所有名字空间。
dbname.system.indexes	列出所有索引。
dbname.system.profile	包含数据库概要(profile)信息。
dbname.system.users	列出所有可访问数据库的用户。
dbname.local.sources	包含复制对端（slave）的服务器信息和状态。
```

对于修改系统集合中的对象有如下限制。
- 在{{system.indexes}}插入数据，可以创建索引。
- 但除此之外该表信息是不可变的(特殊的drop index命令将自动更新相关信息)。
- {{system.users}}是可修改的。
- {{system.profile}}是可删除的。

---

## MongoDB feature

### 复制（副本集）

![replication](/assets/img/post/replication.png)

```bash
mongod --port "PORT" \
       --dbpath "YOUR_DB_DATA_PATH" \
       --replSet "REPLICA_SET_INSTANCE_NAME"

> rs.add(HOST_NAME:PORT)
```

- MongoDB复制是将数据同步在多个服务器的过程。
- 复制提供了数据的冗余备份，并在多个服务器上存储数据副本，提高了数据的可用性， 并可以保证数据的安全性。
- 复制还允许您从硬件故障和服务中断中恢复数据。
- MongoDB的副本集与我们常见的主从有所不同，主从在主机宕机后所有服务将停止，而副本集在主机宕机后，副本会接管主节点成为主节点，不会出现宕机的情况。


1. 副本集设置
   - 用`rs.initiate()`在Mongo客户端使启动一个新的副本集。
   - 用`rs.conf()`查看副本集配置
   - 用`rs.status()`查看副本集状态

```bash
mongod --port 27017 \
  --dbpath "D:\set up\mongodb\data" \
  --replSet rs0
# 启动一个名为rs0的MongoDB实例，其端口号为27017。
启动后打开命令提示框并连接上mongoDB服务。
```

2. 副本集添加成员
   - 使用多台服务器来启动mongo服务。
   - 进入Mongo客户端，并使用rs.add()方法来添加副本集的成员。

```sql
-- 已经启动了一个名为mongod1.net，端口号为27017的Mongo服务。
-- 在客户端命令窗口使用rs.add() 命令将其添加到副本集中
> rs.add("mongod1.net:27017")


-- MongoDB中你只能通过主节点将Mongo服务添加到副本集中
-- 判断当前运行的Mongo服务是否为主节点可以使用命令db.isMaster()
```


---

### 分片

- 当MongoDB存储海量的数据时，一台机器可能不足以存储数据，也可能不足以提供可接受的读写吞吐量。
- 分片
  - 在Mongodb里面存在另一种集群，就是分片技术
  - 可以满足MongoDB数据量大量增长的需求。
  - 通过在多台机器上分割数据，使得数据库系统能存储和处理更多的数据。
  - 复制所有的写入操作到主节点
  - 延迟的敏感数据会在主节点查询
  - 单个副本集限制在12个节点
  - 当请求量巨大时会出现内存不足。
  - 本地磁盘不足
  - 垂直扩展价格昂贵

![sharding](/assets/img/post/sharding.png)

三个主要组件：
- Shard:
  - 用于存储实际的数据块，
  - 实际生产环境中一个shard server角色可由几台机器组个一个replica set承担，防止主机单点故障
- Config Server:
  - mongod实例
  - 存储了整个 ClusterMetadata，其中包括 chunk信息。
- Query Routers:
  - 前端路由
  - 客户端由此接入，且让整个集群看上去像单一数据库，前端应用可以透明使用。


```sql
-- 分片结构端口分布如下：
Shard Server 1：27020
Shard Server 2：27021
Shard Server 3：27022
Shard Server 4：27023
Config Server ：27100
Route Process：40000


-- 步骤一：启动Shard Server
[root@100 /]# mkdir -p /www/mongoDB/shard/s0
[root@100 /]# mkdir -p /www/mongoDB/shard/s1
[root@100 /]# mkdir -p /www/mongoDB/shard/s2
[root@100 /]# mkdir -p /www/mongoDB/shard/s3
[root@100 /]# mkdir -p /www/mongoDB/shard/log
[root@100 /]# /usr/local/mongoDB/bin/mongod --port 27020 \
                  --dbpath=/www/mongoDB/shard/s0 \
                  --logpath=/www/mongoDB/shard/log/s0.log \
                  --logappend \
                  --fork
[root@100 /]# /usr/local/mongoDB/bin/mongod --port 27023 \
                  --dbpath=/www/mongoDB/shard/s3 \
                  --logpath=/www/mongoDB/shard/log/s3.log
                  --logappend \
                  --fork


-- 步骤二： 启动Config Server
[root@100 /]# mkdir -p /www/mongoDB/shard/config
[root@100 /]# /usr/local/mongoDB/bin/mongod --port 27100 \
                  --dbpath=/www/mongoDB/shard/config \
                  --logpath=/www/mongoDB/shard/log/config.log \
                  --logappend \
                  --fork
-- 完全可以像启动普通mongodb服务一样启动，不需要添加—shardsvr和configsvr参数。
-- 因为这两个参数的作用就是改变启动端口的，所以我们自行指定了端口就可以。


-- 步骤三： 启动Route Process
/usr/local/mongoDB/bin/mongos --port 40000 \
  --configdb localhost:27100 \
  --logpath=/www/mongoDB/shard/log/route.log \
  --fork \
  --chunkSize 500
-- mongos启动参数中，chunkSize这一项是用来指定chunk的大小的，单位是MB，默认大小为200MB.


-- 步骤四： 配置Sharding
-- 使用MongoDB Shell登录到mongos，添加Shard节点
[root@100 shard]# /usr/local/mongoDB/bin/mongo admin \
                    --port 40000
> db.runCommand({ addshard:"localhost:27020" })
-- { "shardAdded" : "shard0000", "ok" : 1 }
> db.runCommand({ addshard:"localhost:27029" })
-- { "shardAdded" : "shard0009", "ok" : 1 }

--  设置分片存储的数据库
> db.runCommand({ enablesharding:"test" })
-- { "ok" : 1 }
> db.runCommand({ shardcollection: "test.log", key: { id:1,time:1}})
{ "collectionsharded" : "test.log", "ok" : 1 }


-- 步骤五： 程序代码内无需太大更改，直接按照连接普通的mongo数据库那样，将数据库连接接入接口40000
```



```sql
-- 分片结构端口分布如下：
Shard Server 1：27020
Shard Server 2：27021
Shard Server 3：27022
Shard Server 4：27023
Config Server ：27100
Route Process：40000


-- 1. 创建Sharding复制集 rs0
# mkdir /data/log
# mkdir /data/db1
# mkdir /data/db2
# nohup mongod --port 27020 \
  --dbpath=/data/db1 \
  --logpath=/data/log/rs0-1.log \
  --logappend \
  --fork \
  --shardsvr \
  --replSet=rs0 &
# nohup mongod --port 27021 \
  --dbpath=/data/db2 \
  --logpath=/data/log/rs0-2.log \
  --logappend \
  --fork \
  --shardsvr \
  --replSet=rs0 &



-- 1.1 复制集rs0配置
-- # mongo localhost:27020
> rs.initiate(
  {_id: 'rs0', members: [
    {_id: 0, host: 'localhost:27020'},
    {_id: 1, host: 'localhost:27021'}]})
> rs.isMaster()  -- #查看主从关系



-- 2. 创建Sharding复制集 rs1
# mkdir /data/db3
# mkdir /data/db4
# nohup mongod --port 27030 \
  --dbpath=/data/db3 \
  --logpath=/data/log/rs1-1.log \
  --logappend \
  --fork \
  --shardsvr \
  --replSet=rs1 &
# nohup mongod --port 27031 \
  --dbpath=/data/db4 \
  --logpath=/data/log/rs1-2.log \
  --logappend \
  --fork \
  --shardsvr \
  --replSet=rs1 &


-- 2.1 复制集rs1配置
-- # mongo localhost:27030
> rs.initiate(
  {_id: 'rs1', members: [
    {_id: 0, host: 'localhost:27030'},
    {_id: 1, host: 'localhost:27031'}]})
> rs.isMaster() -- #查看主从关系



-- 3. 创建Config复制集 conf
# mkdir /data/conf1
# mkdir /data/conf2
# nohup mongod --port 27100 \
  --dbpath=/data/conf1 \
  --logpath=/data/log/conf-1.log \
  --logappend \
  --fork \
  --configsvr \
  --replSet=conf &
# nohup mongod --port 27101 \
  --dbpath=/data/conf2 \
  --logpath=/data/log/conf-2.log \
  --logappend \
  --fork \
  --configsvr \
  --replSet=conf &



-- 3.1 复制集conf配置
-- # mongo localhost:27100
> rs.initiate(
  {_id: 'conf', members: [
    {_id: 0, host: 'localhost:27100'},
    {_id: 1, host: 'localhost:27101'}]})
> rs.isMaster() -- #查看主从关系


-- 4. 创建Route
# nohup mongos --port 40000 \
  --configdb conf/localhost:27100,localhost:27101 \
  --fork \
  --logpath=/data/log/route.log \
  --logappend &


-- 4.1 设置分片
-- # mongo localhost:40000
> use admin
> db.runCommand({ addshard: 'rs0/localhost:27020,localhost:27021'})
> db.runCommand({ addshard: 'rs1/localhost:27030,localhost:27031'})
> db.runCommand({ enablesharding: 'test'})
> db.runCommand({ shardcollection: 'test.user', key: {name: 1}})
```


---


### 备份(mongodump)与恢复(mongorestore)

```sql
> mongodump -h dbhost -d dbname -o dbdirectory

-- 备份所有MongoDB数据
> mongodump \
  --host HOST_NAME \
  --port PORT_NUMBER
> mongodump \
  --host runoob.com --port 27017


> mongodump \
  --dbpath DB_PATH \
  --out BACKUP_DIRECTORY
> mongodump \
  --dbpath /data/db/ \
  --out /data/backup/


-- 备份指定数据库的集合。
> mongodump \
  --db DB_NAME \
  --collection COLLECTION
> mongodump \
  --db test \
  --collection mycol


> mongorestore \
  -h <hostname><:port> \
  -d dbname <path>

```

1. 数据备份

   - 用mongodump命令来备份MongoDB数据。
   - 可以导出所有数据到指定目录中。
   - 可以通过参数指定导出的数据量级转存的服务器。
   - `-h`：MongoDB 所在服务器地址，也可以指定端口号：127.0.0.1:27017
   - `-d`：需要备份的数据库实例，例如：test
   - `-o`：备份的数据存放位置，例如：c:\data\dump，当然该目录需要提前建立，在备份完成后，系统自动在dump目录下建立一个test目录，这个目录里面存放该数据库实例的备份数据。

```sql
-- 在本地使用 27017 启动你的mongod服务。
-- 打开命令提示符窗口，进入MongoDB安装目录的bin目录输入命令mongodump:
> mongodump
-- 执行以上命令后，客户端会连接到ip为 127.0.0.1 端口号为 27017 的MongoDB服务上，并备份所有数据到 bin/dump/ 目录中。
-- 命令输出结果如下：
```

![mongodump](/assets/img/post/mongodump.png)

1. 数据恢复
   - `--host <:port>, -h <:port>`: MongoDB所在服务器地址，默认为： localhost:27017
   - `--db , -d`: 需要恢复的数据库实例，例如：test，当然这个名称也可以和备份时候的不一样，比如test2
   - `--drop`:
     - 恢复的时候，先删除当前数据，然后恢复备份的数据。
     - 就是说，恢复后，备份后添加修改的数据都会被删除，慎用哦！
  - `<path>`:
     - mongorestore 最后的一个参数，设置备份数据所在位置，例如：c:\data\dump\test。
     - 不能同时指定 <path> 和 --dir 选项，--dir也可以设置备份目录。
   - `--dir`:
     - 指定备份的目录
     - 你不能同时指定 <path> 和 --dir 选项。

```sql
>mongorestore
-- 执行以上命令输出结果如下：
```

![mongorestore](/assets/img/post/mongorestore.png)

---

### 监控

mongostat
- mongodb自带的状态检测工具
- 间隔固定时间获取mongodb的当前运行状态，并输出。
- 如果你发现数据库突然变慢或者有其他问题的话，你第一手的操作就考虑采用mongostat来查看mongo的状态。
启动你的Mongod服务，进入到你安装的MongoDB目录下的bin目录， 然后输入mongostat命令，如下所示：




---

## MongoDB 数据类型

MongoDB中常用的几种数据类型。

| 数据类型           | 描述                                                                                                       |
| ------------------ | ---------------------------------------------------------------------------------------------------------- |
| String             | 字符串。存储数据常用的数据类型。在 MongoDB 中，UTF-8 编码的字符串才是合法的。                              |
| Integer            | 整型数值。用于存储数值。根据你所采用的服务器，可分为 32 位或 64 位。                                       |
| Boolean            | 布尔值。用于存储布尔值（真/假）。                                                                          |
| Double             | 双精度浮点值。用于存储浮点值。                                                                             |
| Min/Max keys       | 将一个值与 BSON（二进制的 JSON）元素的最低值和最高值相对比。                                               |
| Array              | 用于将数组或列表或多个值存储为一个键。                                                                     |
| Timestamp          | 时间戳。记录文档修改或添加的具体时间。                                                                     |
| Object             | 用于内嵌文档。                                                                                             |
| Null               | 用于创建空值。                                                                                             |
| Symbol             | 符号。该数据类型基本上等同于字符串类型，但不同的是，它一般用于采用特殊符号类型的语言。                     |
| Date               | 日期时间。用 UNIX 时间格式来存储当前日期或时间。你可以指定自己的日期时间：创建 Date 对象，传入年月日信息。 |
| Object ID          | 对象 ID。用于创建文档的 ID。                                                                               |
| Binary Data        | 二进制数据。用于存储二进制数据。                                                                           |
| Code               | 代码类型。用于在文档中存储 JavaScript 代码。                                                               |
| Regular expression | 正则表达式类型。用于存储正则表达式。                                                                       |


---

### ObjectId

- ObjectId 类似唯一主键，可以很快的去生成和排序，

- 包含 12 bytes，含义是：
  - 前 4 个字节表示创建 unix 时间戳,格林尼治时间 UTC 时间，比北京时间晚了 8 个小时
  - 接下来的 3 个字节是机器标识码
  - 紧接的两个字节由进程 id 组成 PID
  - 最后三个字节是随机数

- MongoDB 中存储的文档必须有一个 `_id` 键。这个键的值可以是任何类型的，默认是个 ObjectId 对象

由于 ObjectId 中保存了创建的时间戳，所以你不需要为你的文档保存时间戳字段，你可以通过 getTimestamp 函数来获取文档的创建时间:

```java
> var newObject = ObjectId()

> newObject.getTimestamp()
// # ISODate("2017-11-25T07:21:10Z")

> newObject.str
// # 5a1919e63df83ce79df8b38f
// # ObjectId 转为字符串
```

---

### string

BSON 字符串都是 UTF-8 编码。

---

### 时间戳
- BSON 有一个特殊的时间戳类型用于 MongoDB 内部使用，与普通的 日期 类型不相关。 时间戳值是一个 64 位的值。其中：
- 前32位是一个 time_t 值（与Unix新纪元相差的秒数）
- 后32位是在某秒中操作的一个递增的序数
- 在单个 mongod 实例中，时间戳值通常是唯一的。
- 在复制集中， oplog 有一个 ts 字段。这个字段中的值使用BSON时间戳表示了操作时间。
- BSON 时间戳类型主要用于 MongoDB 内部使用。在大多数情况下的应用开发中，你可以使用 BSON 日期类型。

---

### 日期

- 表示当前距离 Unix新纪元（1970年1月1日）的毫秒数。

- 日期类型是有符号的, 负数表示 1970 年之前的日期。

```java
> var mydate1 = new Date()     //格林尼治时间

> mydate1
// ISODate("2018-03-04T14:58:51.233Z")
> typeof mydate1
// object

> var mydate2 = ISODate() //格林尼治时间

> mydate2
// ISODate("2018-03-04T15:00:45.479Z")
> typeof mydate2
// object
```
这样创建的时间是日期类型，可以使用 JS 中的 Date 类型的方法。
返回一个时间类型的字符串：

```java
> var mydate1str = mydate1.toString()
> mydate1str
// Sun Mar 04 2018 14:58:51 GMT+0000 (UTC)
> typeof mydate1str
// string
// 或者
> Date()
// Sun Mar 04 2018 15:02:59 GMT+0000 (UTC)
```

---

## Basic

```sql
> use runoob
-- switched to db runoob

> db
-- runoob

> show dbs
-- admin   0.000GB
-- config  0.000GB
-- local   0.000GB

> db.runoob.insertOne({"name":"Grace"})
-- WriteResult({ "nInserted" : 1 })

> show dbs
-- admin   0.000GB
-- config  0.000GB
-- local   0.000GB
-- runoob  0.000GB


> db.createCollection("runoob")

> show tables
-- runoob

> db.runoob.drop()
-- true

> show tables


> db.dropDatabase()
-- { "dropped" : "runoob", "ok" : 1 }

> show dbs
-- admin   0.000GB
-- config  0.000GB
-- local   0.000GB


-- ============ Collection ============

> db.createCollection("runoob")
-- { "ok" : 1 }

> show collections
-- runoob
-- system.indexes

> show tables
runoob

> db.mycol2.insert({"name" : "Grace"})

> show collections
-- mycol2

> db.mycol2.drop()
-- true



-- ============ document ============

> db.col.insert(
  {
    title: 'MongoDB_class',
    description: 'MongoDB 是一个 Nosql 数据库',
    by: 'Grace',
    url: 'http://www.runoob.com',
    tags: ['mongodb', 'database', 'NoSQL'],
    likes: 100
})

> document=(
  {
    title: 'MongoDB_class',
    description: 'MongoDB 是一个 Nosql 数据库',
    by: 'Grace',
    url: 'http://www.runoob.com',
    tags: ['mongodb', 'database', 'NoSQL'],
    likes: 100
});
> db.col.insert(document)

> db.col.find()

```



---

### 创建删除数据库

```sql
use DATABASE_NAME
-- 如果数据库不存在，则创建数据库，否则切换到指定数据库。


-- 创建了数据库 runoob:
> use runoob
switched to db runoob

> db
runoob


-- 查看所有数据库
> show dbs
admin   0.000GB
config  0.000GB
local   0.000GB

-- 可以看到，我们刚创建的数据库 runoob 并不在数据库的列表中，
-- 要显示它，我们需要向 runoob 数据库插入一些数据。
> db.runoob.insertOne({"name":"Grace"})
WriteResult({ "nInserted" : 1 })
> show dbs
admin   0.000GB
config  0.000GB
local   0.000GB
runoob  0.000GB
```

- MongoDB 中默认的数据库为 test，如果你没有创建新的数据库，集合将存放在 test 数据库中。
- 在 MongoDB 中，集合只有在内容插入后才会创建! 就是说，创建集合(数据表)后要再插入一个文档(记录)，集合才会真正创建。



```sql
db.dropDatabase()
-- 删除当前数据库，默认为 test，你可以使用 db 命令查看当前数据库名。

> use runoob
switched to db runoob

-- 执行删除命令：
> db.dropDatabase()
{ "dropped" : "runoob", "ok" : 1 }

> show dbs
admin   0.000GB
config  0.000GB
local   0.000GB
```

---

### 创建删除集合

```sql
> use runoob
switched to db runoob

-- 先创建集合，类似数据库中的表
> db.createCollection("runoob")
{ "ok" : 1 }


> show collections
runoob
system.indexes


> show tables
runoob


> db.runoob.drop()
true
> show tables


-- 创建固定集合 mycol，整个集合空间大小 6142800 B, 文档最大个数为 10000 个。
> db.createCollection(
  "mycol", {
    capped : true,
    autoIndexId : true,
    size : 6142800,
    max : 10000 }
  )
{ "ok" : 1 }


-- 在 MongoDB 中，你不需要创建集合。当你插入一些文档时，MongoDB 会自动创建集合。
> db.mycol2.insert({"name" : "Grace"})
> show collections
mycol2


-- 删除集合 mycol2
> db.mycol2.drop()
true


```

---

### 插入文档


- 文档的数据结构和 JSON 基本一样。
- 所有存储在集合中的数据都是 BSON 格式。
- BSON 是一种类似 JSON 的二进制形式的存储格式，是 Binary JSON 的简称。


> MongoDB 使用 insert() 或 save() 方法向集合中插入文档，

```sql
db.COLLECTION_NAME.insert(document)
或
db.COLLECTION_NAME.save(document)
```

- `save()`：
  - 如果 _id 主键存在则更新数据，如果不存在就插入数据。
  - 该方法新版本中已废弃，用 `db.collection.insertOne()` 或 `db.collection.replaceOne() `来代替。
  - 如果不指定 _id 字段 save() 方法类似于 insert() 方法。
  - 如果指定 _id 字段，则会更新该 _id 的数据。

- `insert()`:
  - 若插入的数据主键已经存在，则会抛 org.springframework.dao.DuplicateKeyException 异常，提示主键重复，不保存当前数据。


```sql
db.collection.insertOne(
   <document>,
   {
      writeConcern: <document>
   }
)
或
db.collection.insertMany(
   [ <document 1> , <document 2>, ... ],
   {
      writeConcern: <document>,
      ordered: <boolean>
   }
)
```

- `db.collection.insertOne()`: 用于向集合插入`一个新文档 `
- `db.collection.insertMany()`: 用于向集合插入`多个文档`
  - document：要写入的文档。
  - writeConcern：写入策略，默认为 1，即要求确认写操作，0 是不要求。
  - ordered：指定是否按顺序写入，默认 true，按顺序写入。


```sql
-- 以下文档可以存储在 MongoDB 的 runoob 数据库 的 col 集合中：
> db.col.insert(
  {
    title: 'MongoDB_class',
    description: 'MongoDB 是一个 Nosql 数据库',
    by: 'Grace',
    url: 'http://www.runoob.com',
    tags: ['mongodb', 'database', 'NoSQL'],
    likes: 100
})

-- col 是集合名，
-- 如果该集合不在该数据库中， MongoDB 会自动创建该集合并插入文档。


-- 查看已插入文档：
> db.col.find()
-- {
--   "_id" : ObjectId("56064886ade2f21f36b03134"),
--   "title" : "MongoDB_class",
--   "description" : "MongoDB 是一个 Nosql 数据库",
--   "by" : "Grace",
--   "url" : "http://www.runoob.com",
--   "tags" : [ "mongodb", "database", "NoSQL" ],
--   "likes" : 100
-- }


-- 我们也可以将数据定义为一个变量，如下所示：
> document=(
  {
    title: 'MongoDB_class',
    description: 'MongoDB 是一个 Nosql 数据库',
    by: 'Grace',
    url: 'http://www.runoob.com',
    tags: ['mongodb', 'database', 'NoSQL'],
    likes: 100
});
> db.col.insert(document)
WriteResult({ "nInserted" : 1 })



> db.col.save(document) 命令。


> var res = db.collection.insertMany([{"b": 3}, {'c': 4}])
> res
{
        "acknowledged" : true,
        "insertedIds" : [
                ObjectId("571a22a911a82a1d94c02337"),
                ObjectId("571a22a911a82a1d94c02338")
        ]
}
```

---

### 更新文档


```sql
> db.collection.update(
   <query>,
   <update>,
   {
     upsert: <boolean>,
     multi: <boolean>,
     writeConcern: <document>
   }
)

db.collection.save(
   <document>,
   {
     writeConcern: <document>
   }
)
```

MongoDB 使用 `update()` 和 `save()` 方法来更新集合中的文档。

1. `update()`: 用于更新已存在的文档
   1. `query` : update的查询条件，类似sql update查询内where后面的。
   1. `update` : update的对象和一些更新的操作符（如$,$inc...）等，也可以理解为sql update查询内set后面的
   1. `upsert` : 可选，这个参数的意思是，如果不存在update的记录，是否插入objNew,true为插入，默认是false，不插入。
   1. `multi` : 可选，mongodb 默认是false,只更新找到的第一条记录，如果这个参数为true,就把按条件查出来多条记录全部更新。
   1. `writeConcern` :可选，抛出异常的级别。


```sql
-- 实例
> mdb.col.insert(
  {
    title: 'MongoDB_class',
    description: 'MongoDB 是一个 Nosql 数据库',
    by: 'Grace',
    url: 'http://www.runoob.com',
    tags: ['mongodb', 'database', 'NoSQL'],
    likes: 100
})

-- 修改第一条发现的文档
-- 更新标题(title):
> db.col.update(
    {'title':'MongoDB_class'},
    {$set:{'title':'MongoDB'}}
  )
-- WriteResult({ "nMatched" : 1, "nUpserted" : 0, "nModified" : 1 })
> db.col.find().pretty()
-- {
--         "_id" : ObjectId("56064f89ade2f21f36b03136"),
--         "title" : "MongoDB",
--         "description" : "MongoDB 是一个 Nosql 数据库",
--         "by" : "Grace",
--         "url" : "http://www.runoob.com",
--         "tags" : [
--                 "mongodb",
--                 "database",
--                 "NoSQL"
--         ],
--         "likes" : 100
-- }



-- 修改多条相同的文档，则需要设置 multi 参数为 true。
> db.col.update(
    {'title':'MongoDB_class'},
    {$set:{'title':'MongoDB'}},
    {multi:true}
  )


-- 只更新第一条记录：
db.col.update(
  { "count" : { $gt : 1 } } , { $set : { "test2" : "OK"} } );
-- 全部更新：
db.col.update(
  { "count" : { $gt : 3 } } , { $set : { "test2" : "OK"} },false,true );
-- 只添加第一条：
db.col.update(
  { "count" : { $gt : 4 } } , { $set : { "test5" : "OK"} },true,false );
-- 全部添加进去:
db.col.update(
  { "count" : { $gt : 5 } } , { $set : { "test5" : "OK"} },true,true );
-- 全部更新：
db.col.update(
  { "count" : { $gt : 15 } } , { $inc : { "count" : 1} },false,true );
-- 只更新第一条记录：
db.col.update(
  { "count" : { $gt : 10 } } , { $inc : { "count" : 1} },false,false );
```



2. `save()` 方法
   1. 通过传入的文档来替换已有文档
   2. `_id` 主键存在就更新，不存在就插入。
   1. document : 文档数据。
   1. writeConcern :可选，抛出异常的级别。

```sql
-- 替换了 _id 为 56064f89ade2f21f36b03136 的文档数据：
> db.col.save(
  {
    "_id" : ObjectId("56064f89ade2f21f36b03136"),
    "title" : "MongoDB",
    "description" : "MongoDB 是一个 Nosql 数据库",
    "by" : "Runoob",
    "url" : "http://www.runoob.com",
    "tags" : [
            "mongodb",
            "NoSQL"
    ],
    "likes" : 110
})
-- 替换成功
>db.col.find().pretty()
{
        "_id" : ObjectId("56064f89ade2f21f36b03136"),
        "title" : "MongoDB",
        "description" : "MongoDB 是一个 Nosql 数据库",
        "by" : "Runoob",
        "url" : "http://www.runoob.com",
        "tags" : [
                "mongodb",
                "NoSQL"
        ],
        "likes" : 110
}
```

---

### 删除文档

```sql
db.collection.remove(
   <query>,
   <justOne>
)

-- MongoDB 是 2.6 版本以后
db.collection.remove(
   <query>,
   {
     justOne: <boolean>,
     writeConcern: <document>
   }
)

db.inventory.deleteMany({})
db.inventory.deleteMany({ status: "A" })
db.inventory.deleteOne( { status: "D" } )
```

- `remove()` 函数是用来移除集合中的数据。
  - `query` :（可选）删除的文档的条件。
  - `justOne` : （可选）如果设为 true 或 1，则只删除一个文档，如果不设置该参数，或使用默认值 false，则删除所有匹配条件的文档。
  - `writeConcern` :（可选）抛出异常的级别。

```sql
-- 执行两次插入操作：
> db.col.insert(
  {
    title: 'MongoDB_class',
    description: 'MongoDB 是一个 Nosql 数据库',
    by: 'Grace',
    url: 'http://www.runoob.com',
    tags: ['mongodb', 'database', 'NoSQL'],
    likes: 100
})


> db.col.find()
{ "_id" : ObjectId("56066169ade2f21f36b03137"), ... }
{ "_id" : ObjectId("5606616dade2f21f36b03138"), ... }


-- 移除 title 为 'MongoDB_class' 的文档：删除两条数据
> db.col.remove({'title':'MongoDB_class'})
WriteResult({ "nRemoved" : 2 })

-- 只删除第一条找到的记录可以设置 justOne 为 1，如下所示：
> db.col.remove({'title':'MongoDB_class'},1)


删除所有数据
> db.col.remove({})
> db.col.find()
```


官方推荐使用 deleteOne() 和 deleteMany() 方法。


```sql
-- 删除集合下全部文档：
db.inventory.deleteMany({})

-- 删除 status 等于 D 的一个文档：
db.inventory.deleteOne( { status: "D" } )
-- 删除 status 等于 A 的全部文档：
db.inventory.deleteMany({ status : "A" })
```

---

### 查询文档

```sql
db.collection.find(query, projection)
db.collection.find().pretty()
```

- `findOne()` 方法
  - 只返回一个文档。

- `find()` 方法
  - 以非结构化的方式来显示所有文档。
  - `query` ：可选，使用查询操作符指定查询条件
  - `projection` ：可选，使用投影操作符指定返回的键。查询时返回文档中所有键值， 只需省略该参数即可（默认省略）。

- `pretty()` 方法
  - 以易读的方式来读取数据
  - 以格式化的方式来显示所有文档。


```sql
查询了集合 col 中的数据：

> db.col.find().pretty()
{
        "_id" : ObjectId("56063f17ade2f21f36b03133"),
        "title" : "MongoDB_class",
        "description" : "MongoDB 是一个 Nosql 数据库",
        "by" : "Grace",
        "url" : "http://www.runoob.com",
        "tags" : [
                "mongodb",
                "database",
                "NoSQL"
        ],
        "likes" : 100
}
```


#### AND 条件

```sql
> db.col.find({key1:value1, key2:value2}).pretty()
```

> find() 方法可以传入多个键(key)，每个键(key)以逗号隔开，即常规 SQL 的 AND 条件。

```sql
-- 通过键来查询数据
-- 类似于 WHERE 语句：WHERE by='Grace' AND title='MongoDB_class'
> db.col.find({"by":"Grace", "title":"MongoDB_class"}).pretty()
```

#### OR 条件

```sql

>db.col.find(
   {
      $or: [
         {key1: value1}, {key2:value2}
      ]
   }
).pretty()
```

```sql
-- 查询键 by 值为 Grace
-- 或
-- 键 title 值为 MongoDB_class 的文档。

> db.col.find(
  {$or:[
    {"by":"Grace"},
    {"title": "MongoDB_class"}
  ]}
  ).pretty()
```


#### AND 和 OR 联合使用

```sql
-- 类似常规 SQL 语句为： 'where likes>50 AND (by = 'Grace' OR title = 'MongoDB_class')'

> db.col.find({
  "likes": {$gt:50},
  $or: [
    {"by": "Grace"},
    {"title": "MongoDB_class"}]
  }).pretty()
```


#### 条件操作符

MongoDB 与 RDBMS Where 语句比较

| 操作 | 格式                   | 范例                                      | RDBMS中的类似语句 |
| ---- | ---------------------- | ----------------------------------------- | ----------------- |
| =    | {<key>:<value>}        | db.col.find({"by":"ana"}).pretty()        | where by = 'ana'  |
| <    | {<key>:{$lt:<value>}}  | db.col.find({"likes":{$lt:50}}).pretty()  | where likes < 50  |
| <=   | {<key>:{$lte:<value>}} | db.col.find({"likes":{$lte:50}}).pretty() | where likes <= 50 |
| >    | {<key>:{$gt:<value>}}  | db.col.find({"likes":{$gt:50}}).pretty()  | where likes > 50  |
| >=   | {<key>:{$gte:<value>}} | db.col.find({"likes":{$gte:50}}).pretty() | where likes >= 50 |
| !=   | {<key>:{$ne:<value>}}  | db.col.find({"likes":{$ne:50}}).pretty()  | where likes != 50 |

```sql
> db.col.insert({
    title: 'PHP 教程',
    description: 'PHP 是一种创建动态交互性站点的强有力的服务器端脚本语言。',
    by: '菜鸟教程',
    url: 'http://www.runoob.com',
    tags: ['php'],
    likes: 200
})
> db.col.insert({
    title: 'Java 教程',
    description: 'Java 是由Sun Microsystems公司于1995年5月推出的高级程序设计语言。',
    by: '菜鸟教程',
    url: 'http://www.runoob.com',
    tags: ['java'],
    likes: 150
})
> db.col.insert({
    title: 'MongoDB 教程',
    description: 'MongoDB 是一个 Nosql 数据库',
    by: '菜鸟教程',
    url: 'http://www.runoob.com',
    tags: ['mongodb'],
    likes: 100
})

> db.col.find()

> db.col.find({likes : {$gt : 100}})
{ ..., "likes" : 200 }
{ ..., "likes" : 150 }

> db.col.find({likes : {$gte : 100}})
{ ..., "likes" : 200 }
{ ..., "likes" : 150 }
{ ..., "likes" : 100 }

> db.col.find({likes : {$lt : 150}})
{ ..., "likes" : 100 }

> db.col.find({likes : {$lte : 150}})
{ ..., "likes" : 150 }
{ ..., "likes" : 100 }

> db.col.find({likes : {$lt :200, $gt : 100}})
{ "_id" : ObjectId("56066549ade2f21f36b0313b"), "title" : "Java 教程", "description" : "Java 是由Sun Microsystems公司于1995年5月推出的高级程序设计语言。", "by" : "菜鸟教程", "url" : "http://www.runoob.com", "tags" : [ "java" ], "likes" : 150 }
>
```

#### `$type` 操作符

- `$type`: 基于BSON类型来检索集合中匹配的数据类型，并返回结果。

MongoDB 中可以使用的类型如下表所示：

| 类型                    | 数字 | 备注           |
| ----------------------- | ---- | -------------- |
| Double                  | 1    |
| String                  | 2    |
| Object                  | 3    |
| Array                   | 4    |
| Binary data             | 5    |
| Undefined               | 6    | 已废弃。       |
| Object id               | 7    |
| Boolean                 | 8    |
| Date                    | 9    |
| Null                    | 10   |
| Regular Expression      | 11   |
| JavaScript              | 13   |
| Symbol                  | 14   |
| JavaScript (with scope) | 15   |
| 32-bit integer          | 16   |
| Timestamp               | 17   |
| 64-bit integer          | 18   |
| Min key                 | 255  | Query with -1. |
| Max key                 | 127  |


```sql
> db.col.insert(
  {
    title: 'PHP 教程',
    description: 'PHP 是一种创建动态交互性站点的强有力的服务器端脚本语言。',
    by: '菜鸟教程',
    url: 'http://www.runoob.com',
    tags: ['php'],
    likes: 200
})
> db.col.insert(
  {
    title: 'Java 教程',
    description: 'Java 是由Sun Microsystems公司于1995年5月推出的高级程序设计语言。',
    by: '菜鸟教程',
    url: 'http://www.runoob.com',
    tags: ['java'],
    likes: 150
})
> db.col.insert(
  {
    title: 'MongoDB 教程',
    description: 'MongoDB 是一个 Nosql 数据库',
    by: '菜鸟教程',
    url: 'http://www.runoob.com',
    tags: ['mongodb'],
    likes: 100
})

-- 使用find()命令查看数据：
> db.col.find()

-- 获取 "col" 集合中 title 为 String 的数据，你可以使用以下命令：
db.col.find({"title" : {$type : 2}})
db.col.find({"title" : {$type : 'string'}})
```


---

#### `Limit()` 与 `Skip()`

```sql
> db.COLLECTION_NAME.find().limit(NUMBER)

> db.COLLECTION_NAME.find().limit(NUMBER).skip(NUMBER)
```

- `Limit()`:
  - 在MongoDB中读取指定数量的数据记录，可以使用MongoDB的Limit方法，
  - limit()方法接受一个数字参数，该参数指定从MongoDB中读取的记录条数。
  - 如果没指定limit()方法中的参数, 则显示集合中的所有数据。

```sql
-- 显示查询文档中的两条记录：
> db.col.find(
  {},
  {"title":1,_id:0}
  ).limit(2)
{ "title" : "PHP 教程" }
{ "title" : "Java 教程" }
```

- `Skip()`:
  - 使用limit()方法来读取指定数量的数据外，还可以使用skip()方法来跳过指定数量的数据，
  - skip方法同样接受一个数字参数作为跳过的记录条数。
  - skip()方法默认参数为 0 。

```sql
-- 只显示第二条文档数据
> db.col.find({},{"title":1,_id:0}).limit(1).skip(1)
{ "title" : "Java 教程" }
```

---

### 排序

```sql
> db.COLLECTION_NAME.find().sort({KEY:1})
```

- `sort()`:
  - 对数据进行排序，sort() 方法可以通过参数指定排序的字段，并使用 1 和 -1 来指定排序的方式，
  - 1 为升序排列，而 -1 是用于降序排列。

```sql
-- 集合中的数据按字段 likes 的降序排列：
> db.col.find({},{"title":1,_id:0}).sort({"likes":-1})
{ "title" : "PHP 教程" }
{ "title" : "Java 教程" }
{ "title" : "MongoDB 教程" }

-- Limit与Skip方法MongoDB 索引
-- skip(), limilt(), sort()三个放在一起执行的时候，执行的顺序是先 sort(), 然后是 skip()，最后是显示的 limit()。
```

---

## index

### 索引

```sql
> db.collection.createIndex(keys, options)
```

- 索引通常能够极大的提高查询的效率
  - 如果没有索引，MongoDB在读取数据时必须扫描集合中的每个文件并选取那些符合查询条件的记录。
  - 扫描全集合的查询效率是非常低的，特别在处理大量的数据时，查询可以要花费几十秒甚至几分钟，这对网站的性能是非常致命的。

- 索引是特殊的数据结构
- 索引存储在一个易于遍历读取的数据集合中
- 索引是对数据库表中一列或多列的值进行排序的一种结构

- `createIndex()`: 创建索引。
  - 注意在 3.0.0 版本前创建索引方法为 `db.collection.ensureIndex()`，是 createIndex() 的别名。
  - `Key`: 值为索引字段，1 为指定按升序创建索引，降序为 -1
  - Parameter	Type	Description
  - `background`	Boolean
    - 建索引过程会阻塞其它数据库操作，background可指定以后台方式创建索引，即增加 "background" 可选参数。 "background" 默认值为false。
  - `unique`	Boolean
    - 建立的索引是否唯一。指定为true创建唯一索引。默认值为false.
  - `name`	string
    - 索引的名称。如果未指定，MongoDB的通过连接索引的字段名和排序顺序生成一个索引名称。
  - `dropDups`	Boolean
    - 3.0+版本已废弃。
    - 在建立唯一索引时是否删除重复记录,指定 true 创建唯一索引。默认值为 false.
  - `sparse`	Boolean
    - 对文档中不存在的字段数据不启用索引；
    - 这个参数需要特别注意，如果设置为true的话，在索引字段中不会查询出不包含对应字段的文档。
    - 默认值为 false.
  - `expireAfterSeconds`	integer
    - 指定一个以秒为单位的数值，完成 TTL设定，设定集合的生存时间。
  - `v`	index version
    - 索引的版本号。默认的索引版本取决于mongod创建索引时运行的版本。
  - `weights`	document
    - 索引权重值，数值在 1 到 99,999 之间，表示该索引相对于其他索引字段的得分权重。
  - `default_language`	string
    - 对于文本索引，该参数决定了停用词及词干和词器的规则的列表。 默认为英语
  - `language_override`	string
    - 对于文本索引，该参数指定了包含在文档中的字段名，语言覆盖默认的language，默认值为 language.

```sql
> db.col.createIndex({"title":1})

-- 设置使用多个字段创建索引（关系型数据库中称作复合索引）。
> db.col.createIndex({"title":1,"description":-1})


-- 在后台创建索引：
> db.values.createIndex({open: 1, close: 1}, {background: true})
通过在创建索引时加 background:true 的选项，让创建工作在后台执行


-- 查看集合索引
db.col.getIndexes()

-- 查看集合索引大小
db.col.totalIndexSize()

-- 删除集合所有索引
db.col.dropIndexes()

-- 删除集合指定索引
db.col.dropIndex("索引名称")

-- 利用 TTL 集合对存储的数据进行失效时间设置：
-- 经过指定的时间段后或在指定的时间点过期，MongoDB 独立线程去清除数据。
-- 类似于设置定时自动删除任务，可以清除历史记录或日志等前提条件，设置 Index 的关键字段为日期类型 new Date()。

-- 例如数据记录中 createDate 为日期类型时：
--  设置时间180秒后自动清除。
--  设置在创建记录后，180 秒左右删除。
db.col.createIndex({"createDate": 1},{expireAfterSeconds: 180})

-- 由记录中设定日期点清除。
-- 设置 A 记录在 2019 年 1 月 22 日晚上 11 点左右删除，
-- A 记录中需添加 "ClearUpDate": new Date('Jan 22, 2019 23:00:00')，且 Index中expireAfterSeconds 设值为 0。
db.col.createIndex({"ClearUpDate": 1},{expireAfterSeconds: 0})
--  索引关键字段必须是 Date 类型。
--  非立即执行：扫描 Document 过期数据并删除是独立线程执行，默认 60s 扫描一次，删除也不一定是立即删除成功。
--  单字段索引，混合索引不支持。

```


---

### 聚合

```sql
> db.COLLECTION_NAME.aggregate(AGGREGATE_OPERATION)
```

- MongoDB 中聚合(aggregate)主要用于处理数据(诸如统计平均值，求和等)，并返回计算后的数据结果。
- 有点类似 SQL 语句中的 count(*)。


```sql
集合中的数据如下：
{
   _id: ObjectId(7df78ad8902c)
   title: 'MongoDB Overview',
   description: 'MongoDB is no sql database',
   by_user: 'runoob.com',
   url: 'http://www.runoob.com',
   tags: ['mongodb', 'database', 'NoSQL'],
   likes: 100
},
{
   _id: ObjectId(7df78ad8902d)
   title: 'NoSQL Overview',
   description: 'No sql database is very fast',
   by_user: 'runoob.com',
   url: 'http://www.runoob.com',
   tags: ['mongodb', 'database', 'NoSQL'],
   likes: 10
},
{
   _id: ObjectId(7df78ad8902e)
   title: 'Neo4j Overview',
   description: 'Neo4j is no sql database',
   by_user: 'Neo4j',
   url: 'http://www.neo4j.com',
   tags: ['neo4j', 'database', 'NoSQL'],
   likes: 750
},

-- 计算每个作者所写的文章数
> db.mycol.aggregate([{
  $group : {
    _id : "$by_user",
    num_tutorial : {$sum : 1}}}])
{
   "result" : [
      {
         "_id" : "runoob.com",
         "num_tutorial" : 2
      },
      {
         "_id" : "Neo4j",
         "num_tutorial" : 1
      }
   ],
   "ok" : 1
}
-- 类似sql语句：
 select by_user, count(*) from mycol group by by_user


-- $sum	计算总和。
> db.mycol.aggregate([{
  $group : {_id : "$by_user", num_tutorial : {$sum : "$likes"}}}])

-- $avg	计算平均值
> db.mycol.aggregate([{
  $group : {_id : "$by_user", num_tutorial : {$avg : "$likes"}}}])

-- $min	获取集合中所有文档对应值得最小值。
> db.mycol.aggregate([{
  $group : {_id : "$by_user", num_tutorial : {$min : "$likes"}}}])

-- $max	获取集合中所有文档对应值得最大值。
> db.mycol.aggregate([{
  $group : {_id : "$by_user", num_tutorial : {$max : "$likes"}}}])

-- $push	将值加入一个数组中，不会判断是否有重复的值。
> db.mycol.aggregate([{
  $group : {_id : "$by_user", url : {$push: "$url"}}}])

-- $addToSet	将值加入一个数组中，会判断是否有重复的值，若相同的值在数组中已经存在了，则不加入。
> db.mycol.aggregate([{
  $group : {_id : "$by_user", url : {$addToSet : "$url"}}}])

-- $first	根据资源文档的排序获取第一个文档数据。
> db.mycol.aggregate([{
  $group : {_id : "$by_user", first_url : {$first : "$url"}}}])

-- $last	根据资源文档的排序获取最后一个文档数据
> db.mycol.aggregate([{
  $group : {_id : "$by_user", last_url : {$last : "$url"}}}])
```

管道
- 管道在Unix和Linux中一般用于将当前命令的输出结果作为下一个命令的参数。
- MongoDB的聚合管道将MongoDB文档在一个管道处理完毕后将结果传递给下一个管道处理。管道操作是可以重复的。
- 表达式：处理输入文档并输出。
- 表达式是无状态的，只能用于计算当前聚合管道的文档，不能处理其它的文档。

聚合框架中常用的几个操作：

- `$project`：修改输入文档的结构。可以用来重命名、增加或删除域，也可以用于创建计算结果以及嵌套文档。
- `$match`：用于过滤数据，只输出符合条件的文档。使用MongoDB的标准查询操作。
- `$limit`：用来限制MongoDB聚合管道返回的文档数。
- `$skip`：在聚合管道中跳过指定数量的文档，并返回余下的文档。
- `$unwind`：将文档中的某一个数组类型字段拆分成多条，每条包含数组中的一个值。
- `$group`：将集合中的文档分组，可用于统计结果。
- `$sort`：将输入文档排序后输出。
- `$geoNear`：输出接近某一地理位置的有序文档。

```sql
-- 1、$project 实例
db.article.aggregate({
  $project : {title : 1 ,author : 1 ,}});
-- 这样结果中就只还有_id,tilte和author三个字段


-- 默认情况下_id字段是被包含的，如果要想不包含_id话可以这样:
db.article.aggregate({
  $project : {_id : 0 ,title : 1 ,author : 1}});

-- 2.$match实例
db.articles.aggregate( [
  { $match : { score : { $gt : 70, $lte : 90 } } },
  { $group: { _id: null, count: { $sum: 1 } } }
  ] );
-- $match用于获取分数大于70小于或等于90记录，
-- 然后将符合条件的记录送到下一阶段$group管道操作符进行处理。


-- 3.$skip实例
db.article.aggregate({ $skip : 5 });
-- 经过$skip管道操作符处理后，前五个文档被"过滤"掉。

```

---










---

## deduplicate

---

### group

```bash
db.col.aggregate([
  { $group: {
      _id: "$name",
      doc: { $first: "$$ROOT" }
  }},
  { $replaceRoot: { newRoot: "$doc" } }
])

db.col.aggregate([
  { $sort: { last_evaluation: -1 } },
  {
    $group: {
      _id: {
        resource: "$resource",
        rule: "$rule" },
      doc: { $first: "$$ROOT" }
    }
  },
  { $out: "col" }
])
```



### index

Use **Update** with `upsert=true`.
- Update will look for the document that matches the input query,
- then it will modify the fields you want and then,
- you can tell it `upsert:True` if you want to insert if no document matches your query.


```py
# { _id:'...', user: 'A', title: 'Physics',   Bank: 'Bank_A' }
# { _id:'...', user: 'A', title: 'Chemistry', Bank: 'Bank_B' }
# { _id:'...', user: 'B', title: 'Chemistry', Bank: 'Bank_A' }

doc = { user: 'B', title: 'Chemistry', Bank:'Bank_A' }
db.collection.insert(doc)

here, this duplicate doc will get inserted in database.
# { _id:'...', user: 'A', title: 'Physics',   Bank: 'Bank_A' }
# { _id:'...', user: 'A', title: 'Chemistry', Bank: 'Bank_B' }
# { _id:'...', user: 'B', title: 'Chemistry', Bank: 'Bank_A' }
# { _id:'...', user: 'B', title: 'Chemistry', Bank: 'Bank_A' }
```


```py
# 1
db.collection.update(
   <query>,
   <update>,
  {
    upsert: <boolean>,
     multi: <boolean>,
    writeConcern: <document>
   }
)

db.collection.update(doc, doc, {upsert:true})

# 2
db.collection.createIndex(
  {user: 1, title: 1, Bank: 1},
  {unique:true}
)


# 3
# bulk insert and simultaneously prevent duplicates.
documents = [{'_id':'hello'}, {'_id':'world'}, {'_id':'hello'}]

collection.insert_many(documents, ordered=False)
# if ordered=True then mongo will stop attempting to insert if it encounters an duplicate _id.
# If ordered=False, mongo will attempt to insert all documents.



# 4
{
  'index': '1',
  'movie_name': '霸王别姬',
  'pic': 'https://p1.meituan.net/movie/20803f59291c47e1e116c11963ce019e68711.jpg@160w_220h_1e_1c',
  'release': '上映时间：1993-01-01',
  'score': '9.5'
}
# 那么应该把这条数据作为查询语句，然后执行collection.update_one(query,{'$set':query},upsert=True)。
query={
  '_id': ObjectId('5d23fc92c2a80d7e578a2ae2'),
  'index': '1',
  'movie_name': '霸王别姬',
  'pic': 'https://p1.meituan.net/movie/20803f59291c47e1e116c11963ce019e68711.jpg@160w_220h_1e_1c', 'release': '上映时间：1993-01-01',
   'score': '9.5'
}
collection.update_one(query,{'$set':query},upsert=True)

```


重复数据，指的是某些字段是相同的文档重复插入。也就是说在一个集合里面，某些字段有重复值。

#### 没有并发的环境

- 先查询相关字段，如果查询到，就更新，如果没有查询到就插入。

```py
filter={
  '_id': 'lkj',
  'index': '1',
  'movie_name': '霸王别姬',
}
if db.collection.find(filter).count() == 0：
    db.collection.insert_one(document)
else:
    # 重置更新abbs字段
    db.collection.update_one(filter, update)
```

- 使用update_one()
  - 将参数upsert设置为true, 会查找有没有匹配的文档，有的话就更新，没有的话就插入。
  - 如果upsert为默认值false时，如果没有找到匹配的文档，并不会执行插入。

```py
filter={
  '_id': 'lkj',
  'index': '1',
  'movie_name': '霸王别姬',
}
db.collection.update_one(filter, update, upsert=true)
```

但是这两种操作并不原子，也就是说，存在并发的场景下，可能出现冲突。

upsert设置为true的update函数也不是线程安全的。多个命令同时进行，都没有查询到匹配的文档时，会都执行插入，这样就会有多个文档了。


#### 存在并发的环境 - 唯一索引

- 需要建立唯一索引，这样就不会有重复插入的情况了。

```py
db.collection.createIndex(
  <key and index type specification>, { unique: true }
)

# 单一字段索引
db.collection.createIndex({key:1},{unique:true})

# 组合字段索引
db.collection.createIndex({key_one:1,key_two:1},{unique:true})

# 然后直接尝试插入或者更新，抛出异常的时候再次使用更新即可
try:
    db.collection.insert_one(document)
except DuplicateKeyError:
    db.collection.update_one(filter, update)
# 或者:
try:
    db.collection.update_one(filter, update, upsert=true)
except DuplicateKeyError:
    db.collection.update_one(filter, update, upsert=true)
```

为了避免多次插入同一个文档，**只有在查询字段是唯一索引的情况下才使用upsert: true**




给定一个名为people的集合，其中没有文档的name字段持有值Andy。考虑当多个客户端同时发出以下upsert: true的更新时。

```py
db.people.update(
   { name: "Andy" },
   {
      name: "Andy",
      rating: 1,
      score: 1
   },
   { upsert: true }
)
```


如果所有的update()操作都在任何客户端成功插入数据之前完成了查询部分，并且在name字段上没有唯一索引，那么每次update操作都可能导致插入。

为了防止MongoDB不止一次地插入同一个文档，在name字段上创建一个唯一索引。
- 有了唯一索引，如果多个应用程序以upsert: true发出同一个更新，只会有一个update()成功插入一个新文档。

可能的剩余操作：
- 更新最新插入的文件，或者
- 试图插入一个重复的文档时失败。
- 如果操作因为重复的索引键错误而失败，应用程序可以重试操作，该操作将作为更新操作成功。






---
