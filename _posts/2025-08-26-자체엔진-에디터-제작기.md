---
title: 자체엔진 에디터 제작기
description: 자체엔진을 만들면서 에디터도 제작 중인데 꽤 예전부터 틈틈히 진행하던 내용을 정리했습니다.
author: ounols
date: '2025-08-27 02:00:00'
categories:
- Dev
- 자체 게임 엔진 프로젝트
tags:
- Coding
- dev
- OpenGL
- cpp
pin: false
math: false
mermaid: false
image:
  path: "/media/2025-08-26-자체엔진-에디터-제작기/p.png"
---

{% include embed/video.html src="/media/2025-08-26-자체엔진-에디터-제작기/editor_colored.mp4" title="에디터 구동 테스트 영상" %}

안녕하세요! 자체엔진을 만들면서 에디터도 제작 중인데 꽤 예전부터 틈틈히 진행하다보니 블로그에 쓰기도 너무 애매한 분량이 몇년동안 지속되더라구요.<br>
그러다가 슬슬 포트폴리오도 새로 갱신할 겸 에디터 제작에 대한 이야기를 여기에 적어보고자 합니다.

구현된 순서대로 작성해보겠습니다.


## 에디터 만들어보자!

![](/media/2025-08-26-자체엔진-에디터-제작기/1-v167-misc.png)

에디터를 만들어보고 싶어서 GUI를 뭐로 붙일까 고민하다가 [imgui](https://github.com/ocornut/imgui)가 눈에 들어왔습니다.
static 함수들로 이루어져있고, 절차식으로 ui를 만들어가다보니 꽤 접근 난이도가 낮을 것 같아서 이걸 채택하게 된 것 같습니다.

무엇보다 크로스 플랫폼 기반의 예제소스도 있다보니 쓰지 말아야 할 이유를 찾는게 더 힘들더군요.


아무튼 imgui를 기반으로 아래와 같은 작업을 시작하였습니다.

- **스크립트 직렬화 시스템** 구현 시작
- **`WindowBase`** 클래스로 에디터 윈도우 아키텍처 설계
- **`MainDocker`** 클래스로 도킹 시스템 기반 마련
- **`CustomComponent`** 확장으로 게임 오브젝트 시스템 강화

![](/media/2025-08-26-자체엔진-에디터-제작기/192213752-f03a935e-1c5d-4121-9b22-ec96b4caf243.png)
_imgui에서의 docker 시스템을 이용한 DockerSpace 예제 이미지_

대체적으로 `WindowBase`를 기반으로 기능을 만들려고 했습니다. 무엇보다 docker 브랜치에 구현된 도커형태가 매우 마음에 들었기 때문에 저 클래스를 기반으로 설계를 했습니다.

```cpp

// WindowBase.h - 모든 에디터 윈도우의 기반 클래스
namespace CSEditor {
    class WindowBase {
    public:
        virtual ~WindowBase() = default;
        virtual void SetUI() = 0;  // 각 윈도우의 UI 렌더링
    protected:
        ImGuiViewport* m_mainViewport;
    };
}

```

```cpp
// MainDocker.cpp - 도킹 시스템과 윈도우 관리
class MainDocker : public WindowBase {
private:
    std::vector<WindowBase*> m_windows;
    ImGuiWindowFlags m_windowFlags = ImGuiWindowFlags_MenuBar | ImGuiWindowFlags_NoDocking;

public:
    void SetUI() override {...}
    
private:
    void GenerateWindows() {...}
};
```

이러한 클래스를 담아서 총 관리를 하는 `MainDocker`도 간단하게 작업을 해뒀지만...<br>
사실 대충 설계해서 추상 클래스만 만들어둔터라 에디터를 위해 일부 컴포넌트들의 직렬화 작업이 더 진행되었던 걸로 기억합니다ㅋㅋ


## 본격적으로 에디터 구조화하기

본격적으로 에디터 구조화 작업은 얼추 2022년 10월부터 윈도우 프로젝트로 시작했던 것 같습니다.
```
Editor/platforms/Windows/
├── CMakeLists.txt          # CMake 빌드 시스템
├── CSEditor.sln            # Visual Studio 솔루션
├── CSEditor/               
│   ├── main.cpp           # 에디터 진입점
│   ├── imgui.ini          # ImGui 설정
│   └── 리소스 파일들...
└── CMake/                  # 빌드 유틸리티
```
{: file='당시 Editor전용 프로젝트 파일 트리'}

기본적으로 평소에 만들어놨던 프로젝트 파일 트리를 기반으로 Editor 폴더를 따로 빼서 비슷하게 만들었던걸로 기억합니다.<br>
당시에 아래와 같은 작업을 했다고 볼 수 있습니다.

- CMake 기반 **에디터 전용 빌드 시스템** 구축
- **Visual Studio 및 CMake 통합**
- **멀티 플랫폼 아키텍처** 준비 (`platforms/Windows/` 구조)

여기까지는 imgui의 glfw 기반의 예제를 통해 구현했던터라 큰 문제는 없었습니다.

## 엔진 코어 분리

사실 제목만 보면 이게 무슨 말인가 싶습니다. 엔진 코어 분리라니...?<br>
설명을 드리기 위해 기존 엔진 코어의 형태를 보여드리도록 하겠습니다.

### 기존 EngineCore 클래스

```cpp
namespace CSE {
    class EngineCore {
    public:
        DECLARE_SINGLETON(EngineCore);
        ~EngineCore();

        void Init(unsigned int width, unsigned int height);
        void Update(float elapsedTime);
        void LateUpdate(float elapsedTime);
        void Render() const;
        void Exterminate();
       // ...생략...
    };
}
```
{: file='[수정 전] EngineCore.h'}

보시다시피 `DECLARE_SINGLETON`라는 메크로처럼 싱글톤 선언이 되어있습니다. 엔진의 코어이니 싱글톤으로 놔둬도 무방하다고 생각했습니다. 에디터를 만들기 전까진 말이죠.<br>
에디터를 만들면서 아래와 같이 엔진 코어를 중복으로 돌려야 하는 상황이 왔습니다.

* 에디터 상에서 여러 편집이 일어나는 에디터용 엔진 코어
* 에디터에서 게임 프리뷰를 실행하면 에뮬레이팅 되는 프리뷰용 엔진 코어

그렇게 세상에 절대라는건 없다는 문구를 다시 한번 크게 느끼게 되었습니다.

### 수정된 EngineCore

결국 `EngineCore`는 인스턴스화가 가능하도록 개량해야하기 때문에 아래와 같이 `EngineCoreInstance`라는 부모 클래스를 만들었습니다.

```cpp

namespace CSE {
    class EngineCoreInstance {
    protected:
        EngineCoreInstance();
        virtual ~EngineCoreInstance();

    public:
        void Init(unsigned int width, unsigned int height);
        void Update(float elapsedTime);
        void LateUpdate(float elapsedTime);
        void Render() const;
        void Exterminate();

        bool IsReady() const {
            return m_isReady;
        }
				
       // ...생략...

    protected:
        bool m_isGenerated = false;
        bool m_isReady = false;
       // ...생략...
    };
}

```
{: file='EngineCoreInstance.h'}

사실 기존의 `EngineCore`랑 큰 차이는 없습니다. 다행스럽게도 `EngineCore`는 내부적으로 할당된 모든 코어 시스템의 메모리 수명을 담당했던 덕분입니다.

```cpp
namespace CSE {
    class EngineCore : public EngineCoreInstance {
    public:
        DECLARE_SINGLETON(EngineCore);
        ~EngineCore() override;
    };
}
```
{: file='[수정 후] EngineCore.h'}

그렇게 빌드된 런타임으로 돌아갈 `EngineCore`는 기존의 싱글톤 형태로 그대로 들어감으로써 기존 엔진의 로직은 크게 변하지 않았습니다.

```cpp
// EEngineCore.cpp - 싱글톤 패턴과 프리뷰 모드 분기
namespace CSEditor {
    class EEngineCore : public CSE::EngineCoreInstance {
    public:
        static EngineCoreInstance* getInstance() {
            if (sInstance == nullptr) sInstance = new EEngineCore;
            if (sInstance->IsPreview())
                return sInstance->m_previewCore;  // 프리뷰 모드일 때
            return sInstance;                     // 에디터 모드일 때
        }
        
        void StartPreviewCore() {
            if (m_previewCore == nullptr) {
                m_previewCore = new EPreviewCore();
                m_previewCore->Init(m_previewWidth, m_previewHeight);
            }
        }
    
        void StopPreviewCore() {
            if (m_previewCore != nullptr) {
                m_previewCore->Exterminate();
                delete m_previewCore;
                m_previewCore = nullptr;
            }
        }
    };
}
```

에디터는 `EEngineCore`라는 에디터 전용 엔진 코어가 적용됩니다. 위 코드에서 확인하실 수 있듯이 해당 클래스 내부에는 프리뷰 엔진 코어도 들어있습니다. 해당 클래스를 간단하게 설명하면 아래와 같습니다.

- `EPreviewCore` : 별도의 렌더링 컨텍스트를 가진 프리뷰 엔진
- `EEngineCore` : 에디터 전용 엔진 코어로 기존 EngineCoreInstance 확장
- 프레임버퍼 분리 : 메인 엔진과 독립적인 렌더링 파이프라인

![](/media/2025-08-26-자체엔진-에디터-제작기/3.png)

여기서 프리뷰를 진행 중인지 아닌지에 따라 실제 PreviewWindow의 프레임버퍼를 스위칭하며 렌더링을 하게됩니다.

## 윈도우 시스템 기본 구현

![](/media/2025-08-26-자체엔진-에디터-제작기/2.png)

엔진 코어도 분리되었으니 본격적으로 윈도우를 나누게 됩니다. 처음 구현한 윈도우는 간단하게 아래처럼 정리할 수 있습니다.

* HierarchyWindow : 씬에 배치된 오브젝트들의 계층구조를 보여주는 화면
* ConsoleWindow : 로그 및 디버그 정보
* PreviewWindow : 게임 화면을 확인하는 화면
* InspectorWindow : 선택된 오브젝트의 component 및 정보를 표시하는 화면 

```cpp
// HierarchyWindow.cpp - 씬 오브젝트 트리 렌더링
void HierarchyWindow::SetUI() {
    ImGui::Begin("Hierarchy");
    
    RenderTrees();  // 씬의 오브젝트 계층구조 렌더링
    
    // 키 입력 감지로 에디터 렌더링 트리거
    if (!m_core->IsPreview() && (ImGui::IsWindowFocused() || ImGui::IsWindowHovered())) {
        for (ImGuiKey key = static_cast<ImGuiKey>(0); key < ImGuiKey_COUNT; key = (ImGuiKey)(key + 1)) {
            if (ImGui::IsKeyDown(key)) {
                m_core->InvokeEditorRender();  // 실시간 업데이트
                break;
            }
        }
    }
    
    ImGui::End();
}

void HierarchyWindow::RenderTrees() {
    const auto& sceneMgr = CORE->GetSceneMgrCore();
    const auto& scene = dynamic_cast<CSE::SScene*>(sceneMgr->GetCurrentScene());
    if (scene == nullptr) return;
    
    const auto& root = scene->GetRoot();
    // 재귀적으로 오브젝트 트리 렌더링...
}
```

하이어라키 윈도우는 그냥 유니티에 있는 하이어라키와 같은 역할로 만들었습니다. 여기서 중요한 점은 프리뷰가 진행 중이 아니면 화면 갱신이 매 Tick마다 진행되지 않는다는 것입니다.<br>
따라서 위 `HierarchyWindow` 클래스 중 일부 함수 내용을 보면 키 입력에 따라 프리뷰에 보여질 현 씬의 화면을 새로 갱신하는 모습을 볼 수 있습니다.

이 외에도 imgui의 도킹 시스템을 본격적으로 적용하게 되었습니다. 역시 도킹이 된 모습이 좀 더 에디터스럽게 보입니다.

## 에셋 브라우저 구현

```cpp
class AssetWindow {
private:
    std::unordered_map<std::string, AssetsVector> m_assets;
    std::string m_currentPath;
    std::queue<void*> m_previewAssetQueue;
    std::vector<std::string> m_pathSelector;
    
public:
    void RefreshAssets();
    void OnDragDrop(const AssetReference& asset);
    bool OnAssetClickEvent(const AssetReference& asset);
};
```

에셋 브라우저 역할을 하는 `AssetWindow` 클래스를 추가하였습니다. 에셋 브라우저를 구현하여 런타임 중에 실시간으로 에셋들을 불러오기 위해선 전반적인 리소스를 담당하는 `SResource` 라는 부모 클래스에서부터 직렬화 및 Reflection 시스템이 필요했습니다. 

그렇기에 직렬화를 담당하는 `VariableBinder`와 Reflection을 담당하는 `ReflectionObject`를 추가적으로 상속받는 형태로 적용하게 되었습니다.

이렇게 에셋 브라우저를 구현하기 위해 아래와 같은 기능을 추가적으로 구현하였습니다.

- **폴더 트리 네비게이션**
- **에셋 프리뷰 시스템**
- **드래그 앤 드롭** 인터페이스
- **동적 에셋 갱신**


이렇게 에셋 브라우저를 구현하면서 씬의 데이터를 확인하는 용도 밖에 안되던 에디터의 사용성이 매우 좋아져 커스텀이 가능해진 형태로 바뀌게 된 것 같습니다.

아래는 에셋 브라우저를 구현하면서 구현했던 Reflection 시스템에 대한 간략한 추가 설명이 있습니다.

### CPP에서 Reflection 구현

이건 아마 따로 게시글을 작성할 것 같아 간단하게만 작성하도록 하겠습니다.

Reflection 시스템을 구현하기 위해선 Reflection이 적용될 모든 클래스의 헤더파일 선언에서부터 클래스의 해쉬 등록이 필요했습니다. 이를 위해 Reflection 데이터를 담은 linked list를 static으로 저장하여 모든 클래스들의 헤더파일 선언 시점부터 안전하게 등록을 할 수 있도록 만들었습니다.

```cpp
// SMaterial의 생성자 파트
RESOURCE_CONSTRUCTOR(SMaterial) {
    m_lightMgr = CORE->GetCore(LightMgr);
}


// SMaterial의 생성자 파트의 매크로를 풀면 아래와 같은 코드로 나타남
namespace __REFELCTION_DUMP__ {
    namespace SMaterial {
        unsigned char* __CSE_REFLECTION_DUMP__ = CSE::ReflectionMgr::DefineWrapper::SetDefine(
            "SMaterial", []() { return new CSE::SMaterial(); });
    }
}

CSE::SMaterial() : CSE::SResource("SMaterial") {
    m_lightMgr = CORE->GetCore(LightMgr);
}

```
이렇게 선언된 Reflection 오브젝트들은 아래와 같은 코드로 문자열에 의한 타입 추론을 통해 호출이 가능합니다.

```cpp
// SGameObject.cpp의 컴포넌트를 생성하는 함수
SComponent* SGameObject::CreateComponent(const char* type) {
    SComponent* component = static_cast<SComponent*>(ReflectionObject::NewObject(type));
    component->SetGameObject(this);
    AddComponent(component);
    if (m_status == IDLE)
        component->Init();
    return component;
}
```

## 인스펙터의 Material 정보 표기

```cpp
class MaterialLayer {
private:
    // 머티리얼 파라미터들을 레이어 형태로 관리
public:
    void RenderMaterialUI();
    void UpdateMaterialProperties();
};
```

PBR 렌더링을 지원하는 기존 로직을 보여줄 머티리얼 에디터가 구현되었습니다. 여기서 구현된 인스펙터 주요 기능은 아래와 같습니다.

- 레이어 기반 머티리얼 시스템
- 인스펙터 수정 시 실시간 프리뷰에도 적용되어 업데이트
- 람다 형식으로 구현되었던 SMaterial의 uniform 선언 로직을 그대로 적용 가능한 형태

```cpp
// MaterialLayer.cpp - 머티리얼 속성 에디터
void MaterialLayer::RenderUI() {
    // 머티리얼 참조가 변경되었는지 확인
    if(m_render->GetMaterialReference() != m_material_ref) {
        m_material = m_render->GetMaterial();
        m_material_ref = m_render->GetMaterialReference();
        MaterialLayer::InitParams();  // 파라미터 재초기화
    }
    
    if (!ImGui::CollapsingHeader(m_name.c_str(), ImGuiTreeNodeFlags_DefaultOpen))
        return;
    
    // 드래그 앤 드롭 소스로 설정
    if (ImGui::BeginDragDropSource(ImGuiDragDropFlags_None)) {
        ImGui::SetDragDropPayload("INSP_RES", m_material, sizeof(CSE::SResource));
        ImGui::EndDragDropSource();
    }
    
    // 머티리얼 파라미터들을 테이블 형태로 렌더링
    ImGui::BeginTable(m_material->GetHash().c_str(), 2, ImGuiTableFlags_None);
    
    for (const auto& param: m_params) {
        const auto& name = param->GetName();
        ImGui::TableNextRow();
        ImGui::TableSetColumnIndex(0);
        ImGui::Text("%s", name.c_str());
        ImGui::TableSetColumnIndex(1);
        param->RenderUI();  // 각 파라미터 타입에 맞는 UI 렌더링
    }
    
    ImGui::EndTable();
}
```

이를 통해 프리뷰 진행 중에도 instance로 생성된 머티리얼들의 uniform 데이터를 실시간으로 수정 가능한 형태로 구현되었습니다.

## 에셋 브라우저의 에셋 프리뷰 구현

![](/media/2025-08-26-자체엔진-에디터-제작기/1.png)

```cpp
// EAssetPreviewMgr.cpp - 에셋 프리뷰 생성 및 관리
class EAssetPreviewMgr {
private:
    std::unordered_map<std::string, CSE::SResource*> m_previews;
    CSE::ResMgr* m_editorResMgr;

public:
    CSE::STexture* GetPreview(std::string& hash) {
        const auto& iter = m_previews.find(hash);
        SResource* res = nullptr;
        
        if (iter != m_previews.end()) 
            res = iter->second;  // 캐시된 프리뷰 사용
        else 
            res = GeneratePreview(hash);  // 새 프리뷰 생성
        
        if(res->IsSameClass(STexture::GetClassStaticType())) {
            return static_cast<STexture*>(res);
        }
        return nullptr;
    }
    
    SResource* GeneratePreview(std::string& hash) {
        const auto& asset = m_editorResMgr->GetAssetReference(hash);
        const auto& res = SResource::Create(asset, asset->class_type);
        
        if (res->IsSameClass(STexture::GetClassStaticType())) {
            // 프리뷰 캐시에 저장
            m_previews.insert(std::pair<std::string, CSE::SResource*>(res->GetHash(), res));
            return res;
        }
    }
};
```

에셋 브라우저의 프리뷰 이미지를 불러오는 로직을 추가했습니다. 어찌보면 단순할 수 있지만 **에디터용 엔진 코어와 프리뷰 엔진 코어의 데이터 차별화**가 제대로 적용되어야 문제 없이 작동하기 때문에 중요하다고 생각합니다.

```cpp
EngineCoreInstance* EEngineCore::getInstance() {
    if (sInstance == nullptr) sInstance = new EEngineCore;
    if (sInstance->IsPreview())
        return sInstance->m_previewCore;
    return sInstance;
}
```
이 역시 프리뷰 진행 중인지 아닌지에 따라 유동적으로 처리가 가능하도록 로직을 작성했습니다. 위에 작성된 에디터 프로젝트에 엔진 코어를 가져오는 `getInstance()` 함수가 대표적인 예시입니다.

## 정리

{% include embed/video.html src="/media/2025-08-26-자체엔진-에디터-제작기/editor.mp4" title="전반적으로 설명된 구현 내용을 테스트하는 영상" %}

지금까지 이렇게 만들면서 어느정도 에디터의 모습이 보이는 느낌이지만 아직 많은 것이 부족하기 때문에 아직 `master` 브랜치에 적용하지 못한 상태입니다. 저의 에디터 목표는 씬의 작업이 가능한 형태로 만들어진 에디터가 **WebGL 기반인 웹 브라우저에서도 작동하게 하는 것**입니다.

지금은 웹 브라우저에서 실행 시 PreviewWindow에서 프레임버퍼의 스위칭에서 문제가 발생 중이라 이걸 먼저 해결해야할 것 같네요...ㅎㅎ;;

아무튼 한동안 소식 없던 에디터 관련 소식을 이렇게 정리할 수 있어서 속이 좀 후련한 느낌입니다. 꽤 많은걸 만들었네요!

긴 글 읽어주셔서 감사합니다!

> 자체엔진 Git 주소 : [https://github.com/ounols/CSEngine](https://github.com/ounols/CSEngine)
{: .prompt-info}
