---
title: "[BOJ] 신입 사원 - 1946"
author: kwon
date: 2022-12-13T23:00:00 +0900
categories: [boj]
tags: [greedy algorithm, sort]
math: true
mermaid: false
---

| 시간 제한 | 메모리 제한 |
| --- | --- |
| 2초 | 256 MB |

## 문제

언제나 최고만을 지향하는 굴지의 대기업 진영 주식회사가 신규 사원 채용을 실시한다. 인재 선발 시험은 1차 서류심사와 2차 면접시험으로 이루어진다. 최고만을 지향한다는 기업의 이념에 따라 그들은 최고의 인재들만을 사원으로 선발하고 싶어 한다.

그래서 진영 주식회사는, 다른 모든 지원자와 비교했을 때 서류심사 성적과 면접시험 성적 중 적어도 하나가 다른 지원자보다 떨어지지 않는 자만 선발한다는 원칙을 세웠다. 즉, 어떤 지원자 A의 성적이 다른 어떤 지원자 B의 성적에 비해 서류 심사 결과와 면접 성적이 모두 떨어진다면 A는 결코 선발되지 않는다.

이러한 조건을 만족시키면서, 진영 주식회사가 이번 신규 사원 채용에서 선발할 수 있는 신입사원의 최대 인원수를 구하는 프로그램을 작성하시오.

## 입력

첫째 줄에는 테스트 케이스의 개수 T(1 ≤ T ≤ 20)가 주어진다. 각 테스트 케이스의 첫째 줄에 지원자의 숫자 N(1 ≤ N ≤ 100,000)이 주어진다. 둘째 줄부터 N개 줄에는 각각의 지원자의 서류심사 성적, 면접 성적의 순위가 공백을 사이에 두고 한 줄에 주어진다. 두 성적 순위는 모두 1위부터 N위까지 동석차 없이 결정된다고 가정한다.

## 출력

각 테스트 케이스에 대해서 진영 주식회사가 선발할 수 있는 신입사원의 최대 인원수를 한 줄에 하나씩 출력한다.

## 풀이

### 첫 시도

범위가 정해져 있는 정수 데이터이기 때문에 conting sort를 변형하여 정렬을 하였고, 정렬된 배열을 기반으로 슬라이싱을 하여 set을 만들어서 풀이를 시도했다.

```python
import sys
input = sys.stdin.readline
t = int(input())

for _ in range(t):
    n = int(input())
    p_cnt = [0] * (n + 1)
    p_cnt2 = [0] * (n + 1)
    for _ in range(n):
        s1, s2 = map(int, input().split())
        p_cnt[s1] = (s1, s2)
        p_cnt2[s2] = (s1, s2)
    top1 = p_cnt[1][1]
    top2 = p_cnt2[1][0]

    if p_cnt[1][1] == 1:
        print(1)
    else:
        cnt = 0
        set1 = set(p_cnt[1:top2 + 1])
        set2 = set(p_cnt2[1:top1 + 1])
        print(len(set1 & set2))
```

| 3 | 6 |
| 7 | 3 |
| 4 | 2 |
| 1 | 4 |
| 5 | 7 |
| 2 | 5 |
| 6 | 1 |

위와 같은 예제가 있다고 생각해보자. 먼저 이를 성적과 면접 순으로 정렬한 리스트를 각각 만든다.

| 1 | 4 |  | 6 | 1 |
| 2 | 5 |  | 4 | 2 |
| 3 | 6 |  | 7 | 3 |
| 4 | 2 |  | 1 | 4 |
| 5 | 7 |  | 2 | 5 |
| 6 | 1 |  | 3 | 6 |
| 7 | 3 |  | 5 | 7 |

여기서 첫 번째 리스트(성적 순)는 면접 순위가 가장 높은 사람이 나올 때까지 슬라이싱을 하여 set으로 만들어 준다. set(p_cnt[1:top2 + 1])

반대로 두 번째 리스트(면접 순)는 성적  순위가 가장 높은 사람이 나올 때까지 슬라이싱을 하여 set으로 만들어 준다. set2 = set(p_cnt2[1:top1 + 1])

이렇게 만들면 각 set에 한 분야의 1 순위인 사람보다 다른 분야의 순위가 높은 사람들을 걸러낼 수 있고, 이 둘의 교집합을 이용하면 두 분야의 1 순위인 사람들보다 적어도 하나의 분야의 순위가 높은 사람들을 추려낼 수 있어서 정답을 구할 수 있다고 생각했다.

실제로도 위 예제로 실행한 결과는 3으로 정상적으로 통과한다.

하지만 아래의 예제와 같은 경우에는 문제가 발생한다.

| 1 | 4 |
| 2 | 2 |
| 3 | 3 |
| 4 | 1 |

이 경우에는 위와 같은 방법으로 하게 되면 4명 모두 set에 들어가게 되므로 출력이 4가 나오게 된다.

하지만 실제 정답은 (3, 3)이 (2, 2)에 막히게 되어 3 이 나와야 한다.

### 수정한 코드

```python
import sys
input = sys.stdin.readline

t = int(input())

for _ in range(t):
    n = int(input())
    p_cnt = [0] * (n + 1)
    for _ in range(n):
        s1, s2 = map(int, input().split())
        p_cnt[s1] = (s1, s2)
    
    cnt = 1
    best_s1, best_s2 = p_cnt[1]
    for s1, s2 in p_cnt[2:]:
        if best_s2 > s2:
            cnt += 1
            best_s2 = s2
    print(cnt)
```

성적 순으로 정렬한 리스트 하나만 사용한다. 이 리스트를 돌면서 현재 저장되어 있는 면접 순위보다 높은 사람을 발견할 경우 카운트를 하나 늘리고 그 사람의 순위를 저장하여 반복문을 계속 진행한다. (초기 값은 성적 1위의 사람)

이렇게 하면 성공적으로 어떤 사람보다 두 순위가 모두 낮은 사람을 걸러낼 수 있다.