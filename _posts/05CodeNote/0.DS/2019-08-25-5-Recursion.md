---
title: DS - pythonds3 - 5. Recursion
# author: Grace JyL
date: 2019-08-25 11:11:11 -0400
description:
excerpt_separator:
categories: [05-CodeNote, PythonNote]
tags:
math: true
# pin: true
toc: true
# image: /assets/img/sample/devices-mockup.png
---

- [5. Recursion](#5-recursion)
  - [The Three Laws of Recursion](#the-three-laws-of-recursion)
  - [simple code](#simple-code)
    - [Calculating the Sum of a List of Numbers](#calculating-the-sum-of-a-list-of-numbers)
    - [returns reverse string](#returns-reverse-string)
    - [check palindrome string](#check-palindrome-string)
    - [Int to Str in Any Base](#int-to-str-in-any-base)
    - [Int to Str in Any Base <- Stack + Recursion](#int-to-str-in-any-base---stack--recursion)
  - [Visualizing Recursion](#visualizing-recursion)
    - [turtle graphics basics.](#turtle-graphics-basics)
    - [fractal tree.](#fractal-tree)
    - [Sierpinski Triangle](#sierpinski-triangle)
  - [Complex Recursive Problems](#complex-recursive-problems)
    - [Tower of Hanoi](#tower-of-hanoi)
    - [Exploring a Maze](#exploring-a-maze)


---


# 5. Recursion

**A recursive function is a function that calls itself**.

Recursion is a method of solving problems that involves breaking a problem down into smaller and smaller subproblems until you get to a small enough problem that it can be solved trivially.
- Usually recursion involves a function calling itself.
- While it may not seem like much on the surface, recursion allows us to write elegant solutions to problems that may otherwise be very difficult to program.

> Each time we make a recursive call we are solving a smaller problem, until we reach the point where the problem cannot get any smaller.


---

## The Three Laws of Recursion

all recursive algorithms must obey three important laws:
- A recursive algorithm must have a `base case`.
  - a base case is the condition that allows the algorithm to stop recursing.
  - A base case is typically a problem that is small enough to solve directly.
- A recursive algorithm must `change its state` and `move toward the base case`.
  - A change of state means that some data that the algorithm is using is modified.
  - Usually `the data that represents problem gets smaller` in some way.  
- A recursive algorithm must `call itself, recursively`.


---

## simple code

---

### Calculating the Sum of a List of Numbers

calculate the sum of a list of numbers such as: [1,3,5,7,9]

**An iterative function**:

```py
def listsum(numList):
    theSum = 0
    for i in numList: theSum = theSum + i
    return theSum
print(listsum([1,3,5,7,9]))
```

do not have while loops or for loops. How would you compute the sum of a list of numbers?
- the sum of the list `numList` is the sum of the first element of the list `numList[0]`, and the sum of the numbers in the rest of the list `numList[1:]`


- A recursive algorithm must have a `base case`.
  - the base case is a list of length 1.
- A recursive algorithm must `change its state` and `move toward the base case`.
  - primary data structure is a list,
  - so we must focus state-changing efforts on the list.
  - Since the base case is a list of length 1, a natural progression toward the base case is to shorten the list.
  - call listsum with a shorter list.
- A recursive algorithm must `call itself, recursively`.


```py
def listsum(numList):
  # This check is crucial and is escape clause from the function. The sum of a list of length 1 is trivial; it is just the number in the list.
  if len(numList) == 1:
    return numList[0]
  else:
    return numList[0] + listsum(numList[1:])
print(listsum([1,3,5,7,9]))
```

---

### returns reverse string

```py
def reverse(s):
    # print(s)
    if len(s) <= 1:
        s = s
    elif len(s) <=2:
        s = s[1] + s[0]
    else:
        s = reverse(s[1:]) + s[0]
    # print(s)
    return s

print(reverse("hello")=="olleh")
print(reverse("l")=="l")
print(reverse("follow")=="wollof")
print(reverse("")=="")
```

----


### check palindrome string

takes a string as a parameter and returns True if the string is a palindrome, False otherwise.
- a string is a palindrome if it is spelled the same both forward and backward.
- For example:
  - radar is a palindrome.
- bonus points
  - palindromes can also be phrases,
  - need to remove the spaces and punctuation before checking.
  - `madam i’m adam` is a palindrome.

Other fun palindromes include:
```
kayak
aibohphobia
Live not on evil
Reviled did I live, said I, as evil I did deliver
Go hang a salami; I’m a lasagna hog.
Able was I ere I saw Elba
Kanakanak – a town in Alaska
Wassamassaw – a town in South Dakota
```

```py
def removeWhite(s):
    s = s.replace(" ", "").replace("'","").replace('"','')
    return s

def isPal(s):
    if len(s) <= 1:
        # print(s)
        return True
    if len(s) == 2:
        # print(s)
        return s[0] == s[-1]
    else:
        return isPal(s[0]+s[-1]) and isPal(s[1:-1])

print(isPal("x"))
print(isPal("radar"))
print(isPal("hello"))
print(isPal(""))
print(isPal("hannah"))
print(isPal(removeWhite("madam i'm adam")))
```

---



### Int to Str in Any Base

For example,
- convert the integer 10 to its string representation in decimal as "10",
- or to its string representation in binary as "1010".


three components:
- **Reduce the original number to a series of single-digit numbers**
- **Convert the single digit-number to a string using a lookup**
  - divide a number by the base we are trying to convert to.
- **Concatenate the single-digit strings together to form the final result**

```py
def toStr(n,base):
   convertString = "0123456789ABCDEF"
   if n < base:
      return convertString[n]
   else:
      return toStr(n//base,base) + convertString[n%base]
print(toStr(1453,16))
```


---


### Int to Str in Any Base <- Stack + Recursion


push the strings onto a stack instead of making the recursive call.

![newcallstack](https://i.imgur.com/kPOeI2V.png)

```py
from pythonds.basic import Stack

rStack = Stack()

def toStr(n,base):
    convertString = "0123456789ABCDEF"
    while n > 0:
        if n < base:
            rStack.push(convertString[n])
        else:
            rStack.push(convertString[n % base])
        n = n // base
    res = ""
    while not rStack.isEmpty():
        res = res + str(rStack.pop())
    return res

print(toStr(1453,16))

```


---

## Visualizing Recursion

using recursion to draw pictures


### turtle graphics basics.
- use the turtle module to draw a spiral recursively.
- importing the turtle module we create a turtle. When the turtle is created it also creates a window for itself to draw in.
- define the `drawSpiral` function.
  - The base case for this simple function is when the length of the line we want to draw, as given by the len parameter, is reduced to zero or less.
  - If the length of the line is longer than zero we instruct the turtle to go forward by len units and then turn right 90 degrees.
  - The recursive step is when we call drawSpiral again with a reduced length. At the end of ActiveCode 1 you will notice that we call the function myWin.exitonclick(), this is a handy little method of the window that puts the turtle into a wait mode until you click inside the window, after which the program cleans up and exits.

```py
import turtle

myTurtle = turtle.Turtle()
myWin = turtle.Screen()

def drawSpiral(myTurtle, lineLen):
    if lineLen > 0:
        myTurtle.forward(lineLen)
        myTurtle.right(90)
        drawSpiral(myTurtle,lineLen-5)

drawSpiral(myTurtle,100)
myWin.exitonclick()
```


### fractal tree.
- Fractals come from a branch of mathematics, and have much in common with recursion.
- -The definition of a fractal is that when you look at it the fractal has the same basic shape no matter how much you magnify it.
- Some examples from nature are the coastlines of continents, snowflakes, mountains, and even trees or shrubs
- fractal is something that looks the same at all different levels of magnification.
- If we translate this to trees and shrubs we might say that even a small twig has the same shape and characteristics as a whole tree. Using this idea we could say that a tree is a trunk, with a smaller tree going off to the right and another smaller tree going off to the left.
- If you think of this definition recursively it means that we will apply the recursive definition of a tree to both of the smaller left and right trees.


```py
import turtle

def tree(branchLen,t):
    if branchLen > 5:
        t.forward(branchLen)
        t.right(20)
        tree(branchLen-15,t)
        t.left(40)
        tree(branchLen-15,t)
        t.right(20)
        t.backward(branchLen)

def main():
    t = turtle.Turtle()
    myWin = turtle.Screen()
    t.left(90)
    t.up()
    t.backward(100)
    t.down()
    t.color("green")
    tree(75,t)
    myWin.exitonclick()
main()
```


Modify the recursive tree program using one or all of the following ideas:
- Modify the thickness of the branches so that as the `branchLen` gets smaller, the line gets thinner
- Modify the color of the branches so that as the `branchLen` gets very short it is colored like a leaf.
- Modify the angle used in turning the turtle so that at each branch point the angle is selected at random in some range. For example choose the angle between 15 and 45 degrees. Play around to see what looks good.
- Modify the branchLen recursively so that instead of always subtracting the same amount you subtract a random amount in some range.

```py
import turtle

def tree(branchLen,t):
    if branchLen > 5:
        t.forward(branchLen)
        t.right(20)
        tree(branchLen-15,t)
        t.left(40)
        tree(branchLen-15,t)
        t.right(20)
        t.backward(branchLen)

def main():
    t = turtle.Turtle()
    myWin = turtle.Screen()
    t.left(90)
    t.up()
    t.backward(100)
    t.down()
    t.color("green")
    tree(75,t)
    myWin.exitonclick()
main()
```

---

### Sierpinski Triangle

![sierpinski](https://i.imgur.com/uiLL6q9.png)

![stCallTree](https://i.imgur.com/N2o6xhE.png)


- the base case is set arbitrarily as the number of times we want to divide the triangle into pieces.
- Sometimes we call this number the “degree” of the fractal.
- Each time we make a recursive call, we subtract 1 from the degree until we reach 0.
- When we reach a degree of 0, we stop making recursive calls.



```py
import turtle

def drawTriangle(points,color,myTurtle):
    myTurtle.fillcolor(color)
    myTurtle.up()
    myTurtle.goto(points[0][0],points[0][1])
    myTurtle.down()
    myTurtle.begin_fill()
    myTurtle.goto(points[1][0],points[1][1])
    myTurtle.goto(points[2][0],points[2][1])
    myTurtle.goto(points[0][0],points[0][1])
    myTurtle.end_fill()

def getMid(p1,p2):
    return ( (p1[0]+p2[0]) / 2, (p1[1] + p2[1]) / 2)

def sierpinski(points,degree,myTurtle):
    colormap = ['blue','red','green','white','yellow',
                'violet','orange']
    drawTriangle(points,colormap[degree],myTurtle)
    if degree > 0:
        sierpinski( [ points[0],
                      getMid(points[0], points[1]),
                      getMid(points[0], points[2]) ],
                    degree-1, myTurtle)
        sierpinski( [ points[1],
                      getMid(points[0], points[1]),
                      getMid(points[1], points[2])],
                    degree-1, myTurtle)
        sierpinski( [ points[2],
                      getMid(points[2], points[1]),
                      getMid(points[0], points[2])],
                    degree-1, myTurtle)

def main():
   myTurtle = turtle.Turtle()
   myWin = turtle.Screen()
   myPoints = [[-100,-50],[0,100],[100,-50]]
   sierpinski(myPoints,3,myTurtle)
   myWin.exitonclick()

main()
```

---

## Complex Recursive Problems

---

### Tower of Hanoi

high-level outline of how to move a tower from the starting pole, to the goal pole, using an intermediate pole:
- Move a tower of `height-1` to an intermediate pole, using the final pole.
- Move the remaining disk to the final pole.
- Move the tower of `height-1` from the intermediate pole to the final pole using the original pole

As long as we always obey the rule that the larger disks remain on the bottom of the stack, we can use the three steps above recursively, treating any larger disks as though they were not even there.

The only thing missing from the outline above is the identification of a base case. The simplest
- Tower of Hanoi problem is a tower of one disk.
- In this case, we need move only a single disk to its final destination.
- A tower of one disk will be base case.

![hanoi](https://i.imgur.com/ONnKass.png)

```py
def moveTower(height,fromPole, toPole, withPole):
    if height >= 1:
        moveTower(height-1,fromPole,withPole,toPole)
        moveDisk(fromPole,toPole)
        moveTower(height-1,withPole,toPole,fromPole)

def moveDisk(fp,tp):
    print("moving disk from",fp,"to",tp)

moveTower(3,"A","B","C")
# moving disk from A to B
# moving disk from A to C
# moving disk from B to C
# moving disk from A to B
# moving disk from C to A
# moving disk from C to B
# moving disk from A to B
```


---

### Exploring a Maze

![maze](https://i.imgur.com/fA26d8F.png)

assume that maze is divided up into “squares.”
- Each square of the maze is either open or occupied by a section of wall.
- The turtle can only pass through the open squares of the maze.
- If the turtle bumps into a wall it must try a different direction.
- The turtle will require a **systematic procedure** to find its way out of the maze.


Here is the procedure:
- From starting position, try going `North` one square and then recursively try procedure from there.
- If `Northern` does not work, take a step to the `South` and recursively repeat procedure.
- If `South` does not work, try a step to the `West` and recursively apply procedure.
- If `North`, `South`, and `West` does not work, then apply the procedure recursively from a position one step to `East`.
- If none of these directions works then there is no way to get out of the maze and we fail.

If we apply the recursive procedure from there we will just go back one step to the North and be in an infinite loop. So, we must have a strategy to remember where we have been. In this case we will assume that we have a bag of bread crumbs we can drop along our way. If we take a step in a certain direction and find that there is a bread crumb already on that square, we know that we should immediately back up and try the next direction in our procedure. As we will see when we look at the code for this algorithm, backing up is as simple as returning from a recursive function call.













.
