---
title: DS - pythonds3 - 7. Binary Tree
# author: Grace JyL
date: 2019-08-25 11:11:11 -0400
description:
excerpt_separator:
categories: [04CodeNote, PythonNote]
tags:
math: true
# pin: true
toc: true
# image: /assets/img/sample/devices-mockup.png
---


- [7. Binary Tree](#7-binary-tree)
  - [Why Trees?](#why-trees)
  - [properties](#properties)
    - [properties of trees](#properties-of-trees)
    - [Properties or Binary tree](#properties-or-binary-tree)
  - [樹的元素](#樹的元素)
  - [Tree(樹)的定義：](#tree樹的定義)
  - [集合關係](#集合關係)
  - [code example](#code-example)
    - [Tree in java](#tree-in-java)
    - [Tree in java2](#tree-in-java2)
    - [Tree in python1](#tree-in-python1)
    - [Tree in python 2 - Using nodes and references](#tree-in-python-2---using-nodes-and-references)
  - [Binary Tree](#binary-tree)
- [Types of BT](#types-of-bt)
  - [Full Binary Tree](#full-binary-tree)
  - [Complete Binary Tree](#complete-binary-tree)
    - [property of a complete tree](#property-of-a-complete-tree)
  - [Perfect Binary Tree](#perfect-binary-tree)
  - [Balanced Binary Tree](#balanced-binary-tree)
  - [degenerate / pathological tree](#degenerate--pathological-tree)
- [Binary Tree Traversal](#binary-tree-traversal)
  - [preorder traversal `N-L-R`](#preorder-traversal-n-l-r)
    - [preorder in java](#preorder-in-java)
    - [preorder in python](#preorder-in-python)
  - [inorder traversal `L-N-R` Binary search tree](#inorder-traversal-l-n-r-binary-search-tree)
    - [inorder in java](#inorder-in-java)
    - [inorder in python](#inorder-in-python)
  - [postorder traversal `L-R-N`](#postorder-traversal-l-r-n)
    - [postorder in java](#postorder-in-java)
    - [postorder in python](#postorder-in-python)
- [tree inplement](#tree-inplement)
  - [Binary Search Tree](#binary-search-tree)
    - [Binary Search Tree Implementation](#binary-search-tree-implementation)
    - [Binary Search Tree in python](#binary-search-tree-in-python)
      - [`BinarySearchTree` class](#binarysearchtree-class)
      - [`TreeNode` class](#treenode-class)
      - [`put` method](#put-method)
      - [`__setitem__` method](#__setitem__-method)
      - [`get` method](#get-method)
      - [`in` method](#in-method)
      - [`del` method](#del-method)
        - [The node to be deleted has no children](#the-node-to-be-deleted-has-no-children)
        - [The node to be deleted has only one child](#the-node-to-be-deleted-has-only-one-child)
        - [The node to be deleted has two children](#the-node-to-be-deleted-has-two-children)
      - [`__iter__` iterate over all the keys](#__iter__-iterate-over-all-the-keys)
      - [full code](#full-code)
      - [Search Tree Analysis `𝑂(log2𝑛) to 𝑂(𝑛)`](#search-tree-analysis-𝑂log2𝑛-to-𝑂𝑛)
  - [Balanced Binary Search Trees](#balanced-binary-search-trees)
  - [Binary Search Tree code (depth-first)](#binary-search-tree-code-depth-first)
    - [Binary Search Tree Search in java](#binary-search-tree-search-in-java)
  - [Binary Search Tree Insertion (Iterative method)](#binary-search-tree-insertion-iterative-method)
  - [Size Of Binary Tree `node numebr`](#size-of-binary-tree-node-numebr)
  - [Height Of Binary Tree](#height-of-binary-tree)
  - [Root To Leaf Sum Binary Tree](#root-to-leaf-sum-binary-tree)
  - [Check if Binary Tree is Binary Search Tree](#check-if-binary-tree-is-binary-search-tree)
- [Binary Search Tree code (Level Order -> queue)](#binary-search-tree-code-level-order---queue)
  - [Level Order Traversal (in one line)](#level-order-traversal-in-one-line)
  - [Level by Level Printing (in different line)](#level-by-level-printing-in-different-line)
  - [`Reverse` level order traversal binary tree](#reverse-level-order-traversal-binary-tree)
- [Handshaking Lemma and Interesting Tree Properties ??](#handshaking-lemma-and-interesting-tree-properties-)
- [Enumeration of Binary Trees ???](#enumeration-of-binary-trees-)
- [Insertion in a Binary Tree](#insertion-in-a-binary-tree)
- [exersice](#exersice)
  - [Parse Tree](#parse-tree)
  - [Check Same Binary Tree](#check-same-binary-tree)

- ref
  - [1](https://www.geeksforgeeks.org/binary-tree-data-structure/ )

---

# 7. Binary Tree

> The difference between a tree in nature and a tree in computer science
> a tree data structure has its root at the top and its leaves on the bottom.

若熟悉`Linked List`(連結串列)將會更容易理解樹：
- `Linked list`是 **一維的線性結構(不是往前、就是往後)**
- 樹(與Graph)則推廣成**多維的結構**。

linkedlist

![f1](https://i.imgur.com/mLBAp4m.png )

- A、B、C、D稱為node(節點)，用以代表資料(data)、狀態(state)。
- 連結各個node之間的連結(link)稱為edge，可能是單方向，或者雙向。

---


## Why Trees?


1. to store information that naturally forms a hierarchy. For example, the file system on a computer:
2. Trees (with some ordering e.g., BST) provide moderate access/search (quicker than Linked List and slower than arrays).
3. Trees provide moderate insertion/deletion (quicker than Arrays and slower than Unordered Linked Lists).
4. Like Linked Lists and unlike Arrays, Trees don`t have an upper limit on number of nodes as nodes are linked using pointers.


Main applications of trees include:
1. Manipulate hierarchical data.
2. Make information easy to search (see tree traversal).
3. Manipulate sorted lists of data.
4. As a workflow for compositing digital images for visual effects.
5. Router algorithms
6. Form of a multi-stage decision-making (see business chess).


---

## properties

### properties of trees


1. 用以描述具有`階層結構(hierarchical structure)`的問題的首選，
   - 階層結構意味著明確的先後次序，
   - 例如，若要印出ABC三個字母的所有排列組合(permutation)
   - trees are structured in layers
     - the more general things near the top
     - and the more specific things near the bottom.

2. all of the children of one node are independent of the children of another node.
   - we can change the node without affecting other child node.

3. each leaf node is unique.
   - You can follow a path from the root to any directory. That path will uniquely identify that subdirectory (and all the files in it).


4. you can move entire sections of a tree (called a subtree) to a different position in the tree without affecting the lower levels of the hierarchy.
   - derived from their hierarchical nature



而樹的最根本特徵就是：
- 在樹的結構裡，`只有一個root(樹根)`，`並且不存在cycle`。
- 此特徵將衍生出另外兩項等價的性質：
  - 在樹中若要從root尋找特定node，一定只存在一條路徑(path)。
  - 每個node只會有一個parent。


---

###  Properties or Binary tree


1. The maximum number of nodes at level `l`: `2^l`
   - level is number of nodes on path from root to the node (including root and node).
   - Level of root is 0, number of nodes = 2^0 = 1


2. Maximum number of nodes in a binary tree of height `h`: `2^h – 1`.
   - height of a tree is maximum number of nodes on root to leaf path.
   - Height of a tree with single node is considered as 1.
   - In some books, height of the root is considered as 0. In this convention, the above formula becomes 2h+1 – 1


3. In a Binary Tree with `N` nodes, minimum possible height or minimum number of levels: `Log2(N+1)`
   - This can be directly derived from point 2 above.
   - If we consider the height of a leaf node is considered as 0, then above formula for minimum possible height becomes   ? Log2(N+1) ? – 1


4. A Binary Tree with L leaves has at least: `Log2L ? + 1`   levels
A Binary tree has maximum number of leaves (and minimum number of levels) when all levels are fully filled. Let all leaves be at level l, then below is true for number of leaves L.

   L   <=  2l-1  [From Point 1]
   l =   ? Log2L ? + 1
   where l is the minimum number of levels.


5) In Binary tree where every node has 0 or 2 children, number of leaf nodes is always one more than nodes with two children.

---

## 樹的元素

針對node / vertex：

![f9](https://i.imgur.com/EVshcEh.png )

- `degree`(分歧度)：
  - 一個node擁有的subtree(子樹)的個數。
  - A的degree為3，F的degree為2，N的degree為0。
- `root`(樹根)：
  - 樹中最上層的node，也是唯一一個其parent為NULL的node。
  - A即為root。
- `external node/leaf`：
  - 沒有child/subtree的node。
  - G、H、J、K、L、M、N皆為leaf node。
- `internal node`：
  - 至少有一個child的node。
  - A、B、C、D、E、F、I皆為internal node。


- `parent <--> child`：
  - 以pointer說明，被指向者(pointed)為child，指向者(point to)為parent。
- `siblings：擁有相同parent的node們，互相稱兄道弟。`
  - B、C、D共同的parent為A，B、C、D即為彼此的sibling。
- `descendant`(子嗣)：
  - 站在A，所有能夠以「parent指向child」的方式找到的node，皆稱為A的descendant，因此整棵樹除了A以外皆為A的descendant。
  - 在F，能夠以「parent指向child」找到的node有L、M，則稱L、M為F的descendant。
- `ancestor`(祖先)：
  - 圖四中，站在K，所有能夠以「尋找parent」的方式找到的node，皆稱為K的ancestor，因此，E、B、A皆為K的ancestor。
- `path`(路徑)：
  - 由descendant與ancestor關係連結成的`edge`，例如A-B-E-K、A-C-F-N。
- `level`： root-2-3-4
  - 定義root的level為1，其餘node的level為其parent的level加一。
- `height of node`：
  - 某一node與其最長path上之descendant leaf node之間的edge數。
  - 例如，F的height為1，D的height為2，leaf node的height為0。
- `height of tree`：樹的height即為root的height。
  - 樹的height為A的height，等於3。
- `depth`：
  - 某一node與root之間的edge數。
  - 例如，F的depth為2，L的depth為3。

在樹中的traversal(尋訪)之時間複雜度(time complexity)會與height(樹高)有關。

---

## Tree(樹)的定義：

A. Tree(樹)是由一個或多個節點所組成的有限集合，並且滿足：
- 存在且只有一個稱為root(樹根)的節點；
- 其餘的節點可以分割成任意正整數個(包含零個)互斥(disjoint)的集合：T1、...、Tn，其中每一個集合也都滿足樹的定義，這些集合又稱為這棵樹的subtree(子樹)。
- B. Tree(樹)是由一個或多個nodes/vertices以及edge所組成，而且沒有cycle的集合(set)。

Forest(樹林)
- 由n≥0棵彼此互斥(disjoint)的Tree(樹)所形成的集合(Set)，即稱為Forest(樹林)。
- Forest(樹林)由多個Tree(樹)所組成，可以用來表示互斥集合(disjoint set)。



---

## 集合關係


Tree(樹)位居承先啟後的重要戰略位置，資料結構之集合關係圖：

![f11](https://i.imgur.com/xqAyRXN.png )


本篇介紹的Tree(樹)並沒有限制child/ subtree的個數
- 理論上可以有多到超過記憶體空間的child node。
  - ![f1-1](https://i.imgur.com/wt3t5d0.png )
- 然而在實務上，較常使用每個node至多只有兩個child的樹，為`Binary Tree(二元樹)`。
  - ![f2](https://i.imgur.com/ngahlhP.png )
  - 樹上的每一個node之degree皆為2
  - 並稱兩個child pointer為left child和right child。
- 從Binary Tree再增加「鍵值(Key)大小規則」，即`Binary Search Tree(BST，二元搜尋樹)`。
- 以BST為基礎，在每個node上添加顏色(紅與黑)用以平衡樹的height，以減短搜尋時間，這種樹稱為`Red Black Tree(RBT，紅黑樹)`。
- 常見的平衡樹(balanced tree)還有：AVL tree、2-3-4 tree、Splay tree等等，請參考：Wikipedia：Self-balancing binary search tree
- 另一個方向，若打破「不能存在cycle」的限制，則從Tree推廣至圖(Graph)。


---

## code example

---

### Tree in java

以程式碼實作一棵樹，常用的手法為：先以`class TreeNode`(或是struct)定義出每顆node能夠指向多少subtree、攜帶哪些資料形態，再以另一個class Tree表示整棵樹，並以root作為樹的存取點：


```java
public class BinarySearchTree {

    // 根节点
    public static TreeNode root;

    public BinarySearchTree() {
        this.root = null;
    }
}

```

### Tree in java2

Binary Tree: A tree whose elements have at most 2 children is called a binary tree. Since each element in a binary tree can have only 2 children, we typically name them the left and right child.

Summary: Tree is a hierarchical data structure. Main uses of trees include maintaining hierarchical data, providing moderate access and insert/delete operations. Binary trees are special cases of tree where every node has at most two children.

```java
/* Class containing left and right child of current node and key value*/

class Node
{
	int key;
	Node left, right;

	public Node(int item)
	{
		key = item;
		left = right = null;
	}
}


class BinaryTree
{
	// Root of Binary Tree
	Node root;

	// Constructors
	BinaryTree(int key)
	{
		root = new Node(key);
	}

	BinaryTree()
	{
		root = null;
	}


  // create a simple tree with 4 nodes
	public static void main(String[] args) {

		BinaryTree tree = new BinaryTree();

		/*create root*/
		tree.root = new Node(1);

		/* following is the tree after above statement
			1
			/ \
		null null	 */

		tree.root.left = new Node(2);
		tree.root.right = new Node(3);

		/* 2 and 3 become left and right children of 1
			1
			/ \
			2	 3
		/ \ / \
		null null null null */


		tree.root.left.left = new Node(4);
		/* 4 becomes left child of 2
					1
				/	 \
			2		 3
			/ \	 / \
			4 null null null
		/ \
		null null
		*/
	}
}
```

---

---

### Tree in python1

```py
myTree = ['a',
         ['b', ['d',[],[]], ['e',[],[]] ],
         ['c', ['f',[],[]], []] ]
print(myTree)
print('left subtree = ', myTree[1])
print('root = ', myTree[0])
print('right subtree = ', myTree[2])


# The BinaryTree function simply constructs a list with a root node and two empty sublists for the children.
def BinaryTree(r):
    return [r, [], []]


# To add a left subtree to the root of a tree, insert a new list into the second position of the root list.
# If the list already has something in the second position, we need to keep track of it and push it down the tree as the left child of the list we are adding.  
def insertLeft(root,newBranch):
    t = root.pop(1)
    if len(t) > 1:
        root.insert( 1, [ newBranch, t, [] ] )
    else:
        root.insert( 1, [ newBranch, [], [] ] )
    return root
# Notice that to insert a left child, we first obtain the (possibly empty) list that corresponds to the current left child. We then add the new left child, installing the old left child as the left child of the new one. This allows us to splice a new node into the tree at any position.  


def insertRight(root,newBranch):
    t = root.pop(2)
    if len(t) > 1:
        root.insert(2,[newBranch,[],t])
    else:
        root.insert(2,[newBranch,[],[]])
    return root


def getRootVal(root):
    return root[0]

def setRootVal(root,newVal):
    root[0] = newVal

def getLeftChild(root):
    return root[1]

def getRightChild(root):
    return root[2]


r = BinaryTree(3)
insertLeft(r,4)
insertLeft(r,5)
insertRight(r,6)
insertRight(r,7)
l = getLeftChild(r)
print(l)

setRootVal(l,9)
print(r)
insertLeft(l,11)
print(r)
print(getRightChild(getRightChild(r)))

from test import testEqual

def buildTree():
    r = BinaryTree(3)
    insertRight(r,'c')
    insertLeft(r,'c')
    one_left = getLeftChild(r)
    insertRight(one_left,'d')
    one_right = getRightChild(r)
    insertRight(one_right,'f')
    return r

ttree = buildTree()
testEqual(getRootVal(getRightChild(ttree)),'c')
testEqual(getRootVal(getRightChild(getLeftChild(ttree))),'d')
testEqual(getRootVal(getRightChild(getRightChild(ttree))),'f')

```


---


### Tree in python 2 - Using nodes and references

```py
class BinaryTree:
  def __init__(self,rootObj):
    self.key = rootObj
    self.leftChild = None
    self.rightChild = None

  def insertLeft(self,newNode):
    if self.leftChild == None:
      self.leftChild = BinaryTree(newNode)
    else:
      # a node with an existing left child. In the second case, we insert a node and push the existing child down one level in the tree.
      t = BinaryTree(newNode)
      t.leftChild = self.leftChild
      self.leftChild = t

  def insertRight(self,newNode):
    if self.rightChild == None:
      self.rightChild = BinaryTree(newNode)
    else:
      t = BinaryTree(newNode)
      t.rightChild = self.rightChild
      self.rightChild = t

  def getRightChild(self):
    return self.rightChild

  def getLeftChild(self):
    return self.leftChild

  def setRootVal(self,obj):
    self.key = obj

  def getRootVal(self):
    return self.key


r = BinaryTree('a')
print(r.getRootVal())
print(r.getLeftChild())
r.insertLeft('b')
print(r.getLeftChild())
print(r.getLeftChild().getRootVal())
r.insertRight('c')
print(r.getRightChild())
print(r.getRightChild().getRootVal())
r.getRightChild().setRootVal('hello')
print(r.getRightChild().getRootVal())

```

---

## Binary Tree


- Binary Search Tree(BST)：
  - 在某些資料經常要增加、刪除的應用中，BST常用來做搜尋，
  - 例如許多程式語言的Library中的map和set。
- Binary Space Partition：
  - 應用於幾乎所有的3D電玩遊戲以決定哪些物件需要rendered。
- Binary Tries：
  - 應用於大多數high-bandwidth router(高頻寬路由器)以儲存router-tables。
- Heaps：
  - 用以實現高效率的priority queues(優先權佇列)，許多作業系統用來安排工作程序。請參考：Priority Queue：Binary Heap。
- Huffman Coding Tree：
  - 例如.jpeg、.mp3等壓縮技術皆使用Huffman編碼。(在一顆20MB的硬碟要價新台幣一萬元的時代，壓縮技術就是救世主。)




#  Types of BT


![Screen Shot 2021-09-15 at 8.28.09 PM](https://i.imgur.com/B41rB2I.png )

---

## Full Binary Tree

- number of leaf nodes is the number of internal nodes plus 1:
  - Number of leaf nodes = Number of internal nodes + 1

```
               18
           /       \  
         15         30  
        /  \        /  \
      40    50    100   40

             18
           /    \   
         15     20    
        /  \       
      40    50   
    /   \
   30   50

               18
            /     \  
          40       30  
                   /  \
                 100   40
```

---


## Complete Binary Tree

- node按照Full Binary Tree的次序排列(由上至下，由左至右)
  - 樹共有10個node，
  - 且`這十個node正好填滿Full Binary Tree的前十個位置`，
  - 則此樹為Complete Binary Tree。
- if all the levels are completely filled except possibly the last level and the last level has all keys as left as possible


```
               18
           /       \  
         15         30  
        /  \        /  \
      40    50    100   40


               18
           /       \  
         15         30  
        /  \        /  \
      40    50    100   40
     /  \   /
    8   7  9
```


![f4](https://i.imgur.com/K8L Qjx1.png )

這是一棵Complete Binary Tree。

![f5](https://i.imgur.com/ed7613u.png )

這不是一棵Complete Binary Tree。


### property of a complete tree


![heapOrder](https://i.imgur.com/FzGkeOJ.png)

- can represent it using a single list.
  - no need to use nodes and references or even lists of lists.
- Because the tree is complete,
- the left child of a parent (at position `𝑝` ) is the node that is found in position `2𝑝` in the list.
- Similarly, the right child of the parent is at position `2𝑝+1` in the list.
- To find the parent of any node in the tree, Given that a node is at position `𝑛` in the list, the parent is at position `𝑛/2`


The list representation of the tree, along with the full structure property, allows us to efficiently traverse a complete binary tree `using only a few simple mathematical operations`.  


---


## Perfect Binary Tree

- 所有internal node都有兩個`subtree(child pointer)`
- 所有leaf node具有相同的level(或相同的height)。


- 由以上性質能夠推論出：
  - 若leaf node之level為`n`，整棵樹共有 `2^n − 1`個node。
- 並且，每個node與其child有以下關係：
  - 第i個node的left child之index為 2i；
  - 第i個node的right child之index為 2i+1；
  - 除了root之parent為NULL之外，第i個node的parent之index為 ⌊i/2⌋ 。


```
               18
           /       \  
         15         30  
        /  \        /  \
      40    50    100   40


               18
           /       \  
         15         30  
```




---

## Balanced Binary Tree


- A binary tree is balanced if the height of the tree is O(Log n) where n is the number of nodes.
- For Example, the AVL tree maintains `O(Log n)` height by making sure that the difference between the heights of the left and right subtrees is almost 1.
- Red-Black trees maintain O(Log n) height by making sure that the number of Black nodes on every root to leaf paths is the same and there are no adjacent red nodes.
- performance-wise good: woest: O(log n) time for search, insert and delete.


---

## degenerate / pathological tree

- A Tree where every internal node has one child. Such trees are performance-wise same as linked list.

```
      10
      /
    20
     \
     30
      \
      40     
```


---

#  Binary Tree Traversal


---

## preorder traversal `N-L-R`


![Screen Shot 2020-07-23 at 01.29.46](https://i.imgur.com/bDWOafI.png )

10 -> 7 -> 6 -> 1 -> 8 -> 9 -> 11 -> 20 -> 14 -> 22

```
             10
           /     \  
          7       11  
        /  \        \
       6    8        20
      /      \      /  \    
     1        9    14  22
```

![Screen Shot 2020-07-24 at 14.39.24](https://i.imgur.com/8V6IjcI.png )


### preorder in java

```java
public class TreeTraversals {

    public void preOrder(Node root){
        if(root == null){return;}
        System.out.print(root.data + " ");
        preOrder(root.left);
        preOrder(root.right);
    }

    public void preOrderItr(Node root){
        Deque<Node> stack = new LinkedList<Node>();
        stack.addFirst(root);
        while(!stack.isEmpty()){
            root = stack.pollFirst();
            System.out.print(root.data + " ");

            if(root.right != null){stack.addFirst(root.right);}
            if(root.left!= null){stack.addFirst(root.left);}
        }
    }
}
```


### preorder in python

```py
def preorder(tree):
    if tree:
        print(tree.getRootVal())
        preorder(tree.getLeftChild())
        preorder(tree.getRightChild())

def preorder(self):
    print(self.key)
    if self.leftChild:
        self.leftChild.preorder()
    if self.rightChild:
        self.rightChild.preorder()
```

The answer is that implementing preorder as an external function is probably better in this case.
- The reason is that you very rarely want to just traverse the tree.
- In most cases you are going to want to accomplish something else while using one of the basic traversal patterns.  





---

## inorder traversal `L-N-R` Binary search tree


![Screen Shot 2020-07-23 at 01.33.45](https://i.imgur.com/q4wCoVb.png )

1 -> 6 -> 7 -> 8 -> 9 -> 10 -> 11 -> 14 -> 20 > 22

```
             10
           /     \  
          7       11  
        /  \        \
       6    8        20
      /      \      /  \    
     1        9    14  22
```

---

### inorder in java

O(n)

![Screen Shot 2020-07-25 at 00.40.01](https://i.imgur.com/ReKolwj.png )

```java
public class TreeTraversals {

    public void inOrder(Node root){
        if(root == null){return;}
        inOrder(root.left);
        System.out.print(root.data + " ");
        inOrder(root.right);
    }

    public void inorderItr(Node root){
        if (root==null) return;
        Stack<Node> s = new Stack<Node>();
        while (true) {
            if (root != null) {
                s.push(root);
                root=root.left;
            }
            else {
                if (s.isEmpty()) {
                    break;
                }
                root=s.pop();
                System.out.print(root);
                root = root.right;
            }
        }
    }



    public void inorderItr(Node root){
        Stack stack = new Stack();
        stack.push(root);

        if (root.left == null) {
            return stack.pop(root);
        }
        if (root.left != null) {
            return inorderItr(root.left);
            stack.pop(root)
            stack.pop(root.right)
        }
    }

    // public void inorderItr(Node root){
    //     Deque<Node> stack = new LinkedList<Node>();
    //     Node node = root;
    //     while(true){
    //         if(node != null){
    //             stack.addFirst(node);
    //             node = node.left;
    //         }
    //         else{
    //             if(stack.isEmpty()){
    //                 break;
    //             }
    //             node = stack.pollFirst();
    //             System.out.println(node.data);
    //             node = node.right;
    //         }
    //     }
    // }
}
```


### inorder in python

```py
def inorder(tree):
  if tree != None:
      inorder(tree.getLeftChild())
      print(tree.getRootVal())
      inorder(tree.getRightChild())

def printexp(tree):
  sVal = ""
  if tree:
      sVal = '(' + printexp(tree.getLeftChild())
      sVal = sVal + str(tree.getRootVal())
      sVal = sVal + printexp(tree.getRightChild())+')'
  return sVal

```

---

## postorder traversal `L-R-N`


1 -> 6 -> 9 -> 8 -> 7 -> 14 -> 22 -> 20 -> 11 -> 10

```
             10
           /     \  
          7       11  
        /  \        \
       6    8        20
      /      \      /  \    
     1        9    14  22
```

---


### postorder in java

![Screen Shot 2020-07-24 at 13.57.34](https://i.imgur.com/EpqGSIW.png )

![Screen Shot 2020-07-24 at 14.00.03](https://i.imgur.com/fNYgO5h.png )



```java
public class TreeTraversals {

    public void postOrder(Node root){
        if(root == null){return;}
        postOrder(root.left);
        postOrder(root.right);
        System.out.print(root.data + " ");
    }

    // 1.
    public void iterPostOrder(Node root){
        if (root==null) {return;}
        Stack<Node> s1 = new Stack<Node>();
        Stack<Node> s2 = new Stack<Node>();
        s1.push(root);
        while (!s1.isEmpty()){
            root=s1.pop();
            s2.push(root);
            if (root.left != null) {
                s1.push(root.left);
            }
            if (root.right != null) {
                s1.push(root.right);
            }
        }
        while (!s2.isEmpty()){
            root=s2.pop();
            System.out.println(root.data)
        }
    }

    // 2.
    public void postOrderItr(Node root){
        Deque<Node> stack1 = new LinkedList<Node>();
        Deque<Node> stack2 = new LinkedList<Node>();
        stack1.addFirst(root);
        while(!stack1.isEmpty()){
            root = stack1.pollFirst();
            if(root.left != null){
                stack1.addFirst(root.left);
            }
            if(root.right != null){
                stack1.addFirst(root.right);
            }
            stack2.addFirst(root);
        }
        while(!stack2.isEmpty()){
            System.out.print(stack2.pollFirst().data + " ");
        }
    }

    public void postOrderItrOneStack(Node root){
        Node current = root;
        Deque<Node> stack = new LinkedList<>();
        while(current != null || !stack.isEmpty()){
            if(current != null){
                stack.addFirst(current);
                current = current.left;
            }else{
                Node temp = stack.peek().right;
                if (temp == null) {
                    temp = stack.poll();
                    System.out.print(temp.data + " ");
                    while (!stack.isEmpty() && temp == stack.peek().right) {
                        temp = stack.poll();
                        System.out.print(temp.data + " ");
                    }
                } else {
                    current = temp;
                }
            }
        }
    }
}
```


### postorder in python

```py
def postorder(tree):
    if tree != None:
        postorder(tree.getLeftChild())
        postorder(tree.getRightChild())
        print(tree.getRootVal())

def postordereval(tree):
    opers = {'+':operator.add, '-':operator.sub, '*':operator.mul, '/':operator.truediv}
    res1 = None
    res2 = None
    if tree:
        res1 = postordereval(tree.getLeftChild())
        res2 = postordereval(tree.getRightChild())
        if res1 and res2:
            return opers[tree.getRootVal()](res1,res2)
        else:
            return tree.getRootVal()

```




---

# tree inplement

---

##  Binary Search Tree

the interface provided by the map ADT.

- `Map()`
  - Create a new, empty map.
- `put(key,val)`
  - Add a new key-value pair to the map.
  - If the key is already in the map then replace the old value with the new value.
- `get(key)`
  - Given a key, return the value stored in the map or None otherwise.
- `del`
  - Delete the key-value pair from the map using a statement of the form `del map[key]`.
- `len()`
  - Return the number of key-value pairs stored in the map.
- `in`
  - Return True for a statement of the form key in map, if the given key is in the map.


---

### Binary Search Tree Implementation


**bst property**
- A binary search tree relies on the property that
- keys that are less than the parent are found in the left subtree,
- keys that are greater than the parent are found in the right subtree.
- We will call this the `bst property`.

As we implement the Map interface as described above, the **bst property** will guide our implementation.


![simpleBST](https://i.imgur.com/7XMfVRk.png)

---

### Binary Search Tree in python

To implement the binary search tree, we will use the `nodes` and references approach similar to the one we used to implement the linked list, and the expression tree.

However, because we must be able create and work with a binary search tree that is empty, our implementation will use two classes.
- The first class we will call `BinarySearchTree`,
- and the second class we will call `TreeNode`.

---

#### `BinarySearchTree` class

The `BinarySearchTree` class has a reference to the `TreeNode` that is the root of the binary search tree.
- In most cases the external methods defined in the outer class simply check to see if the tree is empty.
- If there are nodes in the tree, the request is just passed on to a private method defined in the BinarySearchTree class that takes the root as a parameter.
- In the case where the tree is empty or we want to delete the key at the root of the tree, we must take special action.


```py
class BinarySearchTree:

    def __init__(self):
        self.root = None
        self.size = 0

    def length(self): return self.size

    def __len__(self): return self.size

    def __iter__(self): return self.root.__iter__()
```


---

#### `TreeNode` class

The `TreeNode` class provides many helper functions that make the work done in the `BinarySearchTree` class methods much easier.
- many of these helper functions help to classify a node according to its own position as a child, (left or right) and the kind of children the node has.
- The `TreeNode` class will also explicitly keep track of the `parent` as an attribute of each node.  


```py
class TreeNode:
   def __init__(self,key,val,
                left=None,right=None,
                parent=None):
        self.key = key
        self.payload = val
        self.leftChild = left
        self.rightChild = right
        self.parent = parent

    def hasLeftChild(self): return self.leftChild

    def hasRightChild(self): return self.rightChild

    def isLeftChild(self): return self.parent and self.parent.leftChild == self

    def isRightChild(self): return self.parent and self.parent.rightChild == self

    def isRoot(self): return not self.parent

    def isLeaf(self): return not (self.rightChild or self.leftChild)

    def hasAnyChildren(self): return self.rightChild or self.leftChild

    def hasBothChildren(self): return self.rightChild and self.leftChild

    def replaceNodeData(self,key,value,lc,rc):
        self.key = key
        self.payload = value
        self.leftChild = lc
        self.rightChild = rc
        if self.hasLeftChild():
            self.leftChild.parent = self
        if self.hasRightChild():
            self.rightChild.parent = self
```


---


#### `put` method

**put method**
- to build our binary search tree.
- The put method is a method of the `BinarySearchTree` class.
- This method will check to see if the tree already has a root.
  - If there is not a root then put will create a new `TreeNode` and install it as the root of the tree.
  - If a root node is already in place then put calls the private, recursive, helper function _put to search the tree according to the following algorithm:
    - Starting at the root of the tree,
      - search the binary tree comparing the `new key` to the `key in the current node`.
      - If the new key is less than the current node, search the left subtree.
      - If the new key is greater than the current node, search the right subtree.
    - When there is no left (or right) child to search,
      - we have found the position in the tree where the new node should be installed.
    - To add a node to the tree,
      - create a new TreeNode object
      - and insert the object at the point discovered in the previous step.

```py
def put(self,key,val):
    if self.root:
      self._put(key,val,self.root)
    else: self.root = TreeNode(key,val)
    self.size = self.size + 1

def _put(self,key,val,currentNode):
    if key < currentNode.key:
        if currentNode.hasLeftChild(): self._put(key,val,currentNode.leftChild)
        else: currentNode.leftChild = TreeNode(key,val,parent=currentNode)
    else:
        if currentNode.hasRightChild(): self._put(key,val,currentNode.rightChild)
        else: currentNode.rightChild = TreeNode(key,val,parent=currentNode)
```


One important problem with our implementation of insert is that `duplicate keys` are not handled properly.
- As our tree is implemented a duplicate key will create a new node with the same key value in the right subtree of the node having the original key.
- The result of this is that the node with the new key will never be found during a search.
- A better way to handle the insertion of a duplicate key is for the value associated with the new key to replace the old value.
- We leave fixing this bug as an exercise for you.

---

#### `__setitem__` method

overload the `[]` operator for assignment by having the `__setitem__` method call (see Listing 4) the put method.
- This allows us to write Python statements like `myZipTree['Plymouth'] = 55446`, just like a Python dictionary.

```py
def __setitem__(self,k,v):
    self.put(k,v)
```

---

#### `get` method

- implement the retrieval of a value for a given key.
- The get method is even easier than the put method because it simply searches the tree recursively until it gets to a `non-matching leaf node` or `finds a matching key`.
- When a matching key is found, the value stored in the payload of the node is returned.

```py
def get(self,key):
    if self.root:
        res = self._get(key, self.root)
        if res: return res.payload
        else: return None
    else: return None

def _get(self, key, currentNode):
    if not currentNode:
        return None
    elif currentNode.key == key:
        return currentNode

    elif key < currentNode.key:
        return self._get(key,currentNode.leftChild)
    else:
        return self._get(key,currentNode.rightChild)

def __getitem__(self,key):
    return self.get(key)
```

---

#### `in` method
- implement the `in` operation by writing a `__contains__` method for the BinarySearchTree.
- The `__contains__` method will simply call get and return `True` if get returns a value, or `False` if it returns None.
- The code for `__contains__` is shown in Listing 6.


```py
def __contains__(self,key):
    if self._get(key, self.root): return True
    else: return False
```

---

#### `del` method

- the most challenging method in the binary search tree
- The first task is to find the node to delete by searching the tree.
- If the tree has more than one node, search using the `_get` method to find the `TreeNode` that needs to be removed.
- If the tree only has a single node, that means removing the root of the tree, but we still must check to make sure the key of the root matches the key that is to be deleted.
- In either case if the key is not found the `del` operator raises an error.

```py
def delete(self,key):
  # search the tree
  if self.size > 1:
      nodeToRemove = self._get(key,self.root)
      if nodeToRemove:
          self.remove(nodeToRemove)
          self.size = self.size-1
      else:
          raise KeyError('Error, key not in tree')
  # key is the root
  elif self.size == 1 and self.root.key == key:
      self.root = None
      self.size = self.size - 1
  # empty tree
  else:
      raise KeyError('Error, key not in tree')

def __delitem__(self,key):
    self.delete(key)
```



found the node containing the key we want to delete, there are three cases must consider:
- The node to be deleted has no children
- The node to be deleted has only one child
- The node to be deleted has two children




##### The node to be deleted has no children

```py
# The node to be deleted has no children
if currentNode.isLeaf():
    if currentNode == currentNode.parent.leftChild:
        currentNode.parent.leftChild = None
    else:
        currentNode.parent.rightChild = None
```


##### The node to be deleted has only one child
- If a node has only a single child, then we can simply promote the child to take the place of its parent.
- there are six cases to consider.
- discuss the case where the current node has a left child.
  - If the current node is a `left child`
    - then we only need to update the `parent reference of the left child` to point to the `parent of the current node`,
    - and then update the `left child reference of the parent` to point to the current node’s left child.
  - If the current node is a `right child`
    - then we only need to update the `parent reference of the left child` to point to the `parent of the current node`,
    - and then update the `right child reference of the parent` to point to the current node’s left child.
  - If the current node has no parent, it must be the root.
    - In this case we will just replace the key, payload, leftChild, and rightChild data by calling the replaceNodeData method on the root.


```py
# this node has one child
else:
  # leftchild -> currentNode
  if currentNode.hasLeftChild():
      # LeftChild -> parent
      if currentNode.isLeftChild():
          currentNode.leftChild.parent = currentNode.parent
          currentNode.parent.leftChild = currentNode.leftChild
      # parent <- RightChild
      elif currentNode.isRightChild():
          currentNode.leftChild.parent = currentNode.parent
          currentNode.parent.rightChild = currentNode.leftChild
      else:
          currentNode.replaceNodeData(currentNode.leftChild.key,
                                      currentNode.leftChild.payload,
                                      currentNode.leftChild.leftChild,
                                      currentNode.leftChild.rightChild)
  # currentNode <- RightChild
  else:
      if currentNode.isLeftChild():
          currentNode.rightChild.parent = currentNode.parent
          currentNode.parent.leftChild = currentNode.rightChild
      elif currentNode.isRightChild():
          currentNode.rightChild.parent = currentNode.parent
          currentNode.parent.rightChild = currentNode.rightChild
      else:
          currentNode.replaceNodeData(currentNode.rightChild.key,
                             currentNode.rightChild.payload,
                             currentNode.rightChild.leftChild,
                             currentNode.rightChild.rightChild)
```


##### The node to be deleted has two children
- The third case is the most difficult case to handle
- If a node has two children, then it is unlikely that we can simply promote one of them to take the node’s place.
- however, search the tree for a node that can be used to replace the one scheduled for deletion.
- find a node that will preserve the binary search tree relationships for both of the existing left and right subtrees.
- The node that will do this is the node that has the next-largest key in the tree. We call this node the successor, and we will look at a way to find the successor shortly.
- The successor is guaranteed to have no more than one child, so we know how to remove it using the two cases for deletion that we have already implemented.
- Once the successor has been removed, we simply put it in the tree in place of the node to be deleted.
- make use of the `helper` methods `findSuccessor` and findMin to find the successor.
- To remove the successor, we make use of the method `spliceOut`.
  - it goes directly to the node to splice out and makes the right changes.
  - We could call delete recursively, but then we would waste time re-searching for the key node.

The code to find the successor is a method of the `TreeNode` class.
- This code makes use of the same properties of binary search trees that cause an inorder traversal to print out the nodes in the tree from smallest to largest.
- There are three cases to consider when looking for the successor:
  - If the node has a right child, then the successor is the smallest key in the right subtree.
  - If the node has no right child and is the left child of its parent, then the parent is the successor.
  - If the node is the right child of its parent, and itself has no right child, then the successor to this node is the successor of its parent, excluding this node.

The `findMin` method is called to find the minimum key in a subtree.
- the minimum valued key in any binary search tree is the leftmost child of the tree.
- Therefore the findMin method simply follows the leftChild references in each node of the subtree until it reaches a node that does not have a left child.


```py
#interior
elif currentNode.hasBothChildren():
  succ = currentNode.findSuccessor()
  succ.spliceOut()
  currentNode.key = succ.key
  currentNode.payload = succ.payload
```


```py
def findSuccessor(self):
    succ = None
    if self.hasRightChild():
        succ = self.rightChild.findMin()
    else:
        if self.parent:
               if self.isLeftChild():
                   succ = self.parent
               else:
                   self.parent.rightChild = None
                   succ = self.parent.findSuccessor()
                   self.parent.rightChild = self
    return succ

def findMin(self):
    current = self
    while current.hasLeftChild(): current = current.leftChild
    return current

def spliceOut(self):
  if self.isLeaf():
    if self.isLeftChild(): self.parent.leftChild = None
    else: self.parent.rightChild = None
  elif self.hasAnyChildren():
    if self.hasLeftChild():
      if self.isLeftChild(): self.parent.leftChild = self.leftChild
      else: self.parent.rightChild = self.leftChild
      self.leftChild.parent = self.parent
    else:
      if self.isLeftChild():
        self.parent.leftChild = self.rightChild
      else:
        self.parent.rightChild = self.rightChild
      self.rightChild.parent = self.parent
```

---


#### `__iter__` iterate over all the keys

to simply iterate over all the keys in the tree in order.
- using the inorder traversal algorithm.
- the iterator requires a bit more work, since an iterator should return only one node each time the iterator is called.

`yield` is similar to return in that it returns a value to the caller.
- However, `yield` also takes the additional step of freezing the state of the function so that the next time the function is called it continues executing from the exact point it left off earlier. Functions that create objects that can be iterated are called generator functions.

The code for an inorder iterator of a binary tree is shown in the next listing. Look at this code carefully; at first glance you might think that the code is not recursive. However, remember that `__iter__` overrides the for x in operation for iteration, so it really is recursive! Because it is recursive over TreeNode instances the `__iter__` method is defined in the TreeNode class.


```py
def __iter__(self):
   if self:
      if self.hasLeftChild():
             for elem in self.leftChiLd:
                yield elem
      yield self.key
      if self.hasRightChild():
             for elem in self.rightChild:
                yield elem
```

---

#### full code

```py
class TreeNode:
    def __init__(self,key,val,left=None,right=None,parent=None):
        self.key = key
        self.payload = val
        self.leftChild = left
        self.rightChild = right
        self.parent = parent

    def hasLeftChild(self):
        return self.leftChild

    def hasRightChild(self):
        return self.rightChild

    def isLeftChild(self):
        return self.parent and self.parent.leftChild == self

    def isRightChild(self):
        return self.parent and self.parent.rightChild == self

    def isRoot(self):
        return not self.parent

    def isLeaf(self):
        return not (self.rightChild or self.leftChild)

    def hasAnyChildren(self):
        return self.rightChild or self.leftChild

    def hasBothChildren(self):
        return self.rightChild and self.leftChild

    def spliceOut(self):
        if self.isLeaf():
            if self.isLeftChild():
                self.parent.leftChild = None
            else:
                self.parent.rightChild = None
        elif self.hasAnyChildren():
            if self.hasLeftChild():
                if self.isLeftChild():
                    self.parent.leftChild = self.leftChild
                else:
                    self.parent.rightChild = self.leftChild
                self.leftChild.parent = self.parent
            else:
                if self.isLeftChild():
                    self.parent.leftChild = self.rightChild
                else:
                    self.parent.rightChild = self.rightChild
                self.rightChild.parent = self.parent

    def findSuccessor(self):
        succ = None
        if self.hasRightChild():
            succ = self.rightChild.findMin()
        else:
            if self.parent:
                   if self.isLeftChild():
                       succ = self.parent
                   else:
                       self.parent.rightChild = None
                       succ = self.parent.findSuccessor()
                       self.parent.rightChild = self
        return succ

    def findMin(self):
        current = self
        while current.hasLeftChild():
            current = current.leftChild
        return current

    def replaceNodeData(self,key,value,lc,rc):
        self.key = key
        self.payload = value
        self.leftChild = lc
        self.rightChild = rc
        if self.hasLeftChild():
            self.leftChild.parent = self
        if self.hasRightChild():
            self.rightChild.parent = self


class BinarySearchTree:

    def __init__(self):
        self.root = None
        self.size = 0

    def length(self):
        return self.size

    def __len__(self):
        return self.size

    def put(self,key,val):
        if self.root:
            self._put(key,val,self.root)
        else:
            self.root = TreeNode(key,val)
        self.size = self.size + 1

    def _put(self,key,val,currentNode):
        if key < currentNode.key:
            if currentNode.hasLeftChild():
                   self._put(key,val,currentNode.leftChild)
            else:
                   currentNode.leftChild = TreeNode(key,val,parent=currentNode)
        else:
            if currentNode.hasRightChild():
                   self._put(key,val,currentNode.rightChild)
            else:
                   currentNode.rightChild = TreeNode(key,val,parent=currentNode)

    def __setitem__(self,k,v):
       self.put(k,v)

    def get(self,key):
       if self.root:
           res = self._get(key,self.root)
           if res:
                  return res.payload
           else:
                  return None
       else:
           return None

    def _get(self,key,currentNode):
       if not currentNode:
           return None
       elif currentNode.key == key:
           return currentNode
       elif key < currentNode.key:
           return self._get(key,currentNode.leftChild)
       else:
           return self._get(key,currentNode.rightChild)

    def __getitem__(self,key):
       return self.get(key)

    def __contains__(self,key):
       if self._get(key,self.root):
           return True
       else:
           return False

    def delete(self,key):
      if self.size > 1:
         nodeToRemove = self._get(key,self.root)
         if nodeToRemove:
             self.remove(nodeToRemove)
             self.size = self.size-1
         else:
             raise KeyError('Error, key not in tree')
      elif self.size == 1 and self.root.key == key:
         self.root = None
         self.size = self.size - 1
      else:
         raise KeyError('Error, key not in tree')

    def __delitem__(self,key):
       self.delete(key)

    def remove(self,currentNode):
         if currentNode.isLeaf(): #leaf
           if currentNode == currentNode.parent.leftChild:
               currentNode.parent.leftChild = None
           else:
               currentNode.parent.rightChild = None
         elif currentNode.hasBothChildren(): #interior
           succ = currentNode.findSuccessor()
           succ.spliceOut()
           currentNode.key = succ.key
           currentNode.payload = succ.payload

         else: # this node has one child
           if currentNode.hasLeftChild():
             if currentNode.isLeftChild():
                 currentNode.leftChild.parent = currentNode.parent
                 currentNode.parent.leftChild = currentNode.leftChild
             elif currentNode.isRightChild():
                 currentNode.leftChild.parent = currentNode.parent
                 currentNode.parent.rightChild = currentNode.leftChild
             else:
                 currentNode.replaceNodeData(currentNode.leftChild.key,
                                    currentNode.leftChild.payload,
                                    currentNode.leftChild.leftChild,
                                    currentNode.leftChild.rightChild)
           else:
             if currentNode.isLeftChild():
                 currentNode.rightChild.parent = currentNode.parent
                 currentNode.parent.leftChild = currentNode.rightChild
             elif currentNode.isRightChild():
                 currentNode.rightChild.parent = currentNode.parent
                 currentNode.parent.rightChild = currentNode.rightChild
             else:
                 currentNode.replaceNodeData(currentNode.rightChild.key,
                                    currentNode.rightChild.payload,
                                    currentNode.rightChild.leftChild,
                                    currentNode.rightChild.rightChild)




mytree = BinarySearchTree()
mytree[3]="red"
mytree[4]="blue"
mytree[6]="yellow"
mytree[2]="at"

print(mytree[6])
print(mytree[2])
```

---

#### Search Tree Analysis `𝑂(log2𝑛) to 𝑂(𝑛)`

- The number of nodes at any particular level is 2𝑑 where 𝑑 is the depth of the level.
- The total number of nodes in a perfectly balanced binary tree is 2^(ℎ+1)−1, where ℎ represents the height of the tree.


- A perfectly balanced tree has the same number of nodes in the left subtree as the right subtree.
- In a balanced binary tree, the worst-case performance of put is `𝑂(log2𝑛)`, where `𝑛` is the number of nodes in the tree.
  - this is the inverse relationship to the calculation in the previous paragraph.
  - So `log2𝑛` gives us the height of the tree, and represents the maximum number of comparisons that put will need to do as it searches for the proper place to insert a new node.


- Unfortunately it is possible to construct a search tree that has height 𝑛 simply by inserting the keys in sorted order!
  - In this case the performance of the put method is `𝑂(𝑛)`


- the performance of the put method is limited by the height of the tree, you can probably guess that other methods, get, in, and del, are limited as well. Since get searches the tree to find the key, in the worst case the tree is searched all the way to the bottom and no key is found. At first glance del might seem more complicated, since it may need to search for the successor before the deletion operation can complete. But remember that the worst-case scenario to find the successor is also just the height of the tree which means that you would simply double the work. Since doubling is a constant factor it does not change worst case


---

## Balanced Binary Search Trees

> the binary search tree can degrade to `𝑂(𝑛)` for operations like get and put when the tree becomes unbalanced.


**Balanced Binary Search Trees**
- binary search tree that automatically makes sure that the tree remains balanced at all times.
- This tree is called an **AVL tree** and is named for its inventors: G.M. Adelson-Velskii and E.M. Landis.








---

##  Binary Search Tree code (depth-first)

### Binary Search Tree Search in java


```java

public class BSTSearch {

    public Node search(Node root, int key) {
        if (root.data == null) { return null;}
        if (root.data == key) { return root;}
        else if (root.data > key) {
            search(root.left, key);
        }
        else {
            search(root.right, key);
        }
    }

    public static void main(String args[]){

        BinaryTree bt = new BinaryTree();
        Node root = null;
        root = bt.addNode(10, root);
        root = bt.addNode(20, root);
        root = bt.addNode(-10, root);
        root = bt.addNode(15, root);
        root = bt.addNode(0, root);
        root = bt.addNode(21, root);
        root = bt.addNode(-1, root);

        BSTSearch bstSearch = new BSTSearch();

        Node result = bstSearch.search(root, 21);
        assert result.data == 21;

        result = bstSearch.search(root, -1);
        assert result.data == 21;

        result = bstSearch.search(root, 11);
        assert result == null;
    }
}

```

---

## Binary Search Tree Insertion (Iterative method)


worst: O(n)

```Java

public class BinaryTree{

    public Node insert(Node root, int data){
        Node node = new Node(data);
        if (root == null) {
            return node;
        }        
        Node parent = null;
        Node current = root;
        while (root != null) {
            parent = root;
            if (root.data < data) {
                root = root.right;
            }
            else {
                root = root.left;
            }
        }
        if (parent.data < data) {
            parent.right = data;
        }
        else {
            parent.left = data;
        }
        return parent;

        // if (root.data < key && root.next == null) {
        //     root.left.data == key
        // }
        // if (root.data > key && root.next == null) {
        //     root.left.data == key
        // }
        // if (root.next != null) {
        //     root = root.next;
        //     bstInsert(Node root.next, int key);
        // }
    }
}
```


---


---

## Size Of Binary Tree `node numebr`


![Screen Shot 2020-07-24 at 13.30.14](https://i.imgur.com/mbLl3ws.png )

```java
public class SizeOfBinaryTree {

    public int size(Node root){
        if(root == null){
            return 0;
        }
        return size(root.left) + size(root.right) + 1;
    }

    public static void main(String args[]){

        BinaryTree bt = new BinaryTree();
        Node head = null;
        head = bt.addNode(10, head);
        head = bt.addNode(15, head);
        head = bt.addNode(5, head);
        head = bt.addNode(7, head);
        head = bt.addNode(19, head);
        head = bt.addNode(20, head);
        head = bt.addNode(-1, head);

        SizeOfBinaryTree sbt = new SizeOfBinaryTree();
        System.out.println(sbt.size(head));
    }
}
```

---


## Height Of Binary Tree


time & space: O(n)

![Screen Shot 2020-07-24 at 13.29.49](https://i.imgur.com/WrgJy8X.png )

```java
public class SameTree {

    public int height(Node root){
        if(root == null){
            return 0;
        }
        int leftHeight  = height(root.left);
        int rightHeight = height(root.right);
        return Math.max(leftHeight, rightHeight) + 1;
    }

    // public int height(Node root){
    //     if(root.left == null && root.right == null) {
    //         return 1;
    //     }
    //     else {
    //         return 0;
    //     }
    //     return 1 + height(root.right) + height(root.left)
    // }
}

```

---

## Root To Leaf Sum Binary Tree


![Screen Shot 2020-07-24 at 13.29.20](https://i.imgur.com/ezvZIHd.png )

```java
public class Root {

    public boolean RootToLeaf(Node root, int sum, list<Integer result>) {

        if (root == null) {return false;}
        if (root.left == null && root.right == null) {
            if (root.data == sum) {
                result.add(root.data);
                return true;
            }
            else {return false;}
        }

        if (RootToLeaf(Node root.left, int sum-root.data, list<Integer result>)) {
            result.add(root.data);
            return true;
        }
        else {return false;}

        if (RootToLeaf(Node root.right, int sum-root.data, list<Integer result>)) {
            result.add(root.data);
            return true;
        }
        else {return false;}     
        return false;   
    }
}
```

---

## Check if Binary Tree is Binary Search Tree


![Screen Shot 2020-07-24 at 13.34.44](https://i.imgur.com/8uaDJ2C.png )

```java
public class Root {

    public boolean isBST(Node root, int min, int max) {
        if (root == null) {return true;}
        if (root.data < min || root.data > max) {return false;}
        return isBST(root.left, min, root.data) && isBST(root, root.data, max)
    }
}
```

---

#  Binary Search Tree code (Level Order -> queue)


![Screen Shot 2020-07-24 at 13.44.59](https://i.imgur.com/f5M3oF1.png )

time: O(n)
space: the size of the tree, O(n)

---

## Level Order Traversal (in one line)


![Screen Shot 2020-07-24 at 13.53.38](https://i.imgur.com/nd0fEXX.png )

```java
public class LevelOrderTraversal {

    public void levelOrder(Node root){

        if(root == null){
            System.out.println("Please enter a valid tree!");
            return;
        }

        Queue<Node> queue = new LinkedList<Node>();
        queue.offer(root);

        while(queue.size() > 0){
            root = queue.poll();
            System.out.print(root.data + " ");

            if(root.left != null){
                queue.add(root.left);
            }
            if(root.right != null){
                queue.add(root.right);
            }
        }
    }

    public static void main(String args[]){
        LevelOrderTraversal loi = new LevelOrderTraversal();
        BinaryTree bt = new BinaryTree();
        Node head = null;
        head = bt.addNode(10, head);
        head = bt.addNode(15, head);
        head = bt.addNode(5, head);
        head = bt.addNode(7, head);
        head = bt.addNode(19, head);
        head = bt.addNode(20, head);
        head = bt.addNode(-1, head);
        loi.levelOrder(head);
    }
}
```

---

## Level by Level Printing (in different line)


1. use 2 quesues

![Screen Shot 2020-07-25 at 00.49.14](https://i.imgur.com/eeISHog.png )

```java

void levelByLevelTwoQueue(Node root) {
    if (root==null) return;
    Queue<Node> q1 = new Queue<Node>();
    Queue<Node> q2 = new Queue<Node>();
    q1.add(root);
    while ( !q1.isEmpty() || !q2.isEmpty() ) {
        while (!q1.isEmpty()) {
            root=q1.pull();
            System.out.print(root);
            if (root.left != null) {q2.add(root.left);}
            if (root.right != null) {q2.add(root.right);}
        }
        System.out.println();
        while (!q2.isEmpty()) {
            root=q2.pull();
            System.out.print(root);
            if (root.left != null) {q1.add(root.left);}
            if (root.right != null) {q1.add(root.right);}
        }
        System.out.println();
    }
}
```

2. use 1 queue

![Screen Shot 2020-07-25 at 00.52.36](https://i.imgur.com/YvovZpO.png )

```java
void levelByLevelOneQueueUsingDelimiter(Node root) {
    if (root==null) return;
    Queue<Node> q = new Queue<Node>();
    q.add(root);
    while (!q.isEmpty()) {
        root=q.poll();
        if (root==null) {
            System.out.println();
            break
        }
        if (root != null) {
            System.out.print(root.data + " ");
            if (root.left != null) {
                q.add(root.left);
            }
            if (root.left != null) {
                q.add(root.left);
            }
        }
        q.add(null);
    }
}

public void levelByLevelOneQueueUsingDelimiter(Node root) {
    if (root == null) {
        return;
    }
    Queue<Node> q = new LinkedList<Node>();
    q.offer(root);
    q.offer(null);
    while (!q.isEmpty()) {
        root = q.poll();
        if (root != null) {
            System.out.print(root.data + " ");
            if (root.left != null) {
                q.offer(root.left);
            }
            if (root.right != null) {
                q.offer(root.right);
            }
        } else {
            if (!q.isEmpty()) {
                System.out.println();
                q.offer(null);
            }
        }
    }
}
```

3. 1 queue & 2 conter

![Screen Shot 2020-07-25 at 01.41.49](https://i.imgur.com/kcl3RcP.png )

![Screen Shot 2020-07-25 at 00.57.11](https://i.imgur.com/pl4FPNv.png )

```java
public void levelByLevelOneQueueUsingCount(Node root) {
    if (root == null) return;

    Queue<Node> q = new LinkedList<Node>();
    int levelCount = 1;
    int currentCount = 0;
    int current = 0;

    q.add(root);

    while (!q.isEmpty()) {
        while (levelCount > 0) {
            current = q.poll();
            if (current.left != null) {
                q.add(root.left);
                currentCount++;
            }
            if (current.right != null) {
                q.add(root.right);
                currentCount++;
            }
            System.out.print(current.data + " ");
            levelCount--;
        }
        System.out.println();
        levelCount = currentCount;
        currentCount = 0;
    }

}
```

---

## `Reverse` level order traversal binary tree


![Screen Shot 2020-07-25 at 01.55.58](https://i.imgur.com/UJFL9fn.png )

```java
public void reverseLevelOrderTraversal(Node root) {
    if (root=null) return;
    Stack<Node> s = new Stack<Node>();
    Queue<Node> q = new Queue<Node>();
    q.add(root);
    while(!q.isEmpty()){
        current = q.poll();
        if (current.right != null) {
            q.add(root.right);
        }
        if (current.left != null) {
            q.add(root.left);
        }
        s.push(current)
    }
    while(!s.isEmpty()){
        System.out.print(s.pop().data + " ");
    }
}
```

---


#  Handshaking Lemma and Interesting Tree Properties ??


---


#  Enumeration of Binary Trees ???


A Binary Tree is `labeled` if every node is assigned a label
a Binary Tree is `unlabeled` if nodes are not assigned any label.

```
Below two are considered same unlabeled trees
    o                 o
  /   \             /   \
 o     o           o     o

Below two are considered different labeled trees
    A                C
  /   \             /  \
 B     C           A    B
```

How many different Unlabeled Binary Trees can be there with n nodes?

```
For n  = 1, there is only one tree
   o

For n  = 2, there are two possible trees
   o      o
  /        \  
 o          o

For n  = 3, there are five possible trees
    o      o           o         o      o
   /        \         /  \      /         \
  o          o       o    o     o          o
 /            \                  \        /
o              o                  o      o
```


The idea is to `consider all possible pair of counts for nodes in left and right subtrees` and multiply the counts for a particular pair. Finally add results of all pairs.

```
For example, let T(n) be count for n nodes.
T(0) = 1  [There is only 1 empty tree]
T(1) = 1
T(2) = 2

T(3) =  T(0)*T(2) + T(1)*T(1) + T(2)*T(0) = 1*2 + 1*1 + 2*1 = 5

T(4) =  T(0)*T(3) + T(1)*T(2) + T(2)*T(1) + T(3)*T(0)
     =  1*5 + 1*2 + 2*1 + 5*1
     =  14
```

The above pattern basically represents n`th Catalan Numbers. First few catalan numbers are 1 1 2 5 14 42 132 429 1430 4862,…
T(n)=\sum_{i=1}^{n}T(i-1)T(n-i)=\sum_{i=0}^{n-1}T(i)T(n-i-1)=C_n
Here,
T(i-1) represents number of nodes on the left-sub-tree
T(n−i-1) represents number of nodes on the right-sub-tree

n`th Catalan Number can also be evaluated using direct formula.



   T(n) = (2n)! / (n+1)!n!
Number of Binary Search Trees (BST) with n nodes is also same as number of unlabeled trees. The reason for this is simple, in BST also we can make any key as root, If root is i`th key in sorted order, then i-1 keys can go on one side and (n-i) keys can go on other side.

How many labeled Binary Trees can be there with n nodes?
To count labeled trees, we can use above count for unlabeled trees. The idea is simple, every unlabeled tree with n nodes can create n! different labeled trees by assigning different permutations of labels to all nodes.

Therefore,

Number of Labeled Tees = (Number of unlabeled trees) * n!
                       = [(2n)! / (n+1)!n!]  × n!
For example for n = 3, there are 5 * 3! = 5*6 = 30 different labeled trees


---

#  Insertion in a Binary Tree


![binary-tree-insertion](https://i.imgur.com/xjtBYaX.png )

```java
import java.util.LinkedList;
import java.util.Queue;

public class GFG {

	/* A binary tree node has key, pointer to
	left child and a pointer to right child */
	static class Node {
		int key;
		Node left, right;

		// constructor
		Node(int key) {
			this.key = key;
			left = null;
			right = null;
		}
  }

	static Node root;
	static Node temp = root;

	/* Inorder traversal of a binary tree*/
	static void inorder(Node temp) {
		if (temp == null)
			return;
		inorder(temp.left);
		System.out.print(temp.key+" ");
		inorder(temp.right);
	}

	/*function to insert element in binary tree */
	static void insert(Node temp, int key) {
		Queue<Node> q = new LinkedList<Node>();
		q.add(temp);

		// Do level order traversal until we find
		// an empty place.
		while (!q.isEmpty()) {
			temp = q.peek();
			q.remove();

			if (temp.left == null) {
				temp.left = new Node(key);
				break;
			} else
				q.add(temp.left);

			if (temp.right == null) {
				temp.right = new Node(key);
				break;
			} else
				q.add(temp.right);
		}
	}

	// Driver code
	public static void main(String args[])
	{
		root = new Node(10);
		root.left = new Node(11);
		root.left.left = new Node(7);
		root.right = new Node(9);
		root.right.left = new Node(15);
		root.right.right = new Node(8);

		System.out.print( "Inorder traversal before insertion:");
		inorder(root);

		int key = 12;
		insert(root, key);

		System.out.print("\nInorder traversal after insertion:");
		inorder(root);
	}
}
```




---

Deletion in a Binary Tree
BFS vs DFS for Binary Tree
Binary Tree (Array implementation)
AVL with duplicate keys
Applications of tree data structure
Applications of Minimum Spanning Tree Problem
Continuous Tree
Foldable Binary Trees
Expression Tree
Evaluation of Expression Tree
Symmetric Tree (Mirror Image of itself)





---

# exersice

## Parse Tree

Parse trees can be used to represent real-world constructions like sentences or mathematical expressions.

define four rules as follows:
- If the current token is a `'('`, add a new node as the left child of the current node, and descend to the left child.
- If the current token is in the list `['+','-','/','*']`, set the root value of the current node to the operator represented by the current token.
- Add a new node as the right child of the current node and descend to the right child.
- If the current token is a number, set the root value of the current node to the number and return to the parent.
- If the current token is a `')'`, go to the parent of the current node.


example: `['(', '3', '+', '(', '4', '*', '5' ,')',')']`

![buildExp8](https://i.imgur.com/v8ieqBx.png)

```py
from pythonds.basic import Stack
from pythonds.trees import BinaryTree

def buildParseTree(fpexp):
    fplist = fpexp.split()
    pStack = Stack()
    eTree = BinaryTree('')
    pStack.push(eTree)
    currentTree = eTree

    for i in fplist:
        if i == '(':
            currentTree.insertLeft('')
            pStack.push(currentTree)
            currentTree = currentTree.getLeftChild()

        elif i in ['+', '-', '*', '/']:
            currentTree.setRootVal(i)
            currentTree.insertRight('')
            pStack.push(currentTree)
            currentTree = currentTree.getRightChild()

        elif i == ')':
            currentTree = pStack.pop()

        elif i not in ['+', '-', '*', '/', ')']:
            try:
                currentTree.setRootVal(int(i))
                parent = pStack.pop()
                currentTree = parent

            except ValueError:
                raise ValueError("token '{}' is not a valid integer".format(i))

    return eTree

pt = buildParseTree("( ( 10 + 5 ) * 3 )")
pt.postorder()  #defined and explained in the next section

import operator
def evaluate(parseTree):
    opers = {'+':operator.add, '-':operator.sub, '*':operator.mul, '/':operator.truediv}

    leftC = parseTree.getLeftChild()
    rightC = parseTree.getRightChild()

    if leftC and rightC:
        fn = opers[parseTree.getRootVal()]
        return fn(evaluate(leftC),evaluate(rightC))
    else:
        return parseTree.getRootVal()
```

---


## Check Same Binary Tree


![Screen Shot 2020-07-24 at 11.27.26](https://i.imgur.com/dcOA8T4.png )
time O(n)

```java
public class SameTree {

    public boolean sameTree(Node root1, Node root2){
        if(root1 == null && root2 == null){
            return true;
        }
        if(root1 == null || root2 == null){
            return false;
        }
        return root1.data == root2.data &&
                sameTree(root1.left, root2.left) &&
                sameTree(root1.right, root2.right);
    }

    public static void main(String args[]){
        BinaryTree bt = new BinaryTree();
        Node root1 = null;
        root1 = bt.addNode(10, root1);
        root1 = bt.addNode(20, root1);
        root1 = bt.addNode(15, root1);
        root1 = bt.addNode(2, root1);

        Node root2 = null;
        root2 = bt.addNode(10, root2);
        root2 = bt.addNode(20, root2);
        root2 = bt.addNode(15, root2);
        root2 = bt.addNode(2, root2);

        SameTree st = new SameTree();
        assert st.sameTree(root1, root2);
   }
}
```











.








.
