---
title: DS - pythonds3 - 7. Binary Heap
# author: Grace JyL
date: 2019-08-25 11:11:11 -0400
description:
excerpt_separator:
categories: [04CodeNote, PythonNote]
tags:
math: true
# pin: true
toc: true
# image: /assets/img/sample/devices-mockup.png
---


- [DS - pythonds3 - 7. Binary Heap](#ds---pythonds3---7-binary-heap)
  - [Priority Queues with Binary Heap Â†Ü](#priority-queues-with-binary-heap-Â†Ü)
  - [heap implementation](#heap-implementation)
    - [min heap operation](#min-heap-operation)
    - [heap in python](#heap-in-python)
      - [`insert`](#insert)
      - [`delMin`](#delmin)
      - [analyze the binary heap](#analyze-the-binary-heap)


---

# DS - pythonds3 - 7. Binary Heap


## Priority Queues with Binary Heap Â†Ü  


**queue**
- first-in first-out data structure

**priority queue**
- One important variation of a queue
- A priority queue acts like a queue that dequeue an item by removing it from the front.
  - However, in a priority queue the `logical order of items` inside a queue is determined by their `priority`.
  - The highest priority items are at the front of the queue and the lowest priority items are at the back.
  - Thus when you enqueue an item on a priority queue, the new item may move all the way to the front.
- We will see that the priority queue is a useful data structure for some of the graph algorithms we will study in the next chapter.



You can probably think of a couple of easy ways to implement a priority queue using `sorting` functions and `lists`.
- However, inserting into a list is `ùëÇ(ùëõ)` and sorting a list is `ùëÇ(ùëõlogùëõ)`
- We can do better. The classic way to implement a priority queue is using a data structure called a `binary heap`.
  - A binary heap will allow us both enqueue and dequeue items in `ùëÇ(logùëõ)`.

Heap
- looks a lot like a tree,
- but we implement it only need a single list as an internal representation.

The binary heap has two common variations:  
- the min heap, in which the <font color=red> smallest key is always at the front </font>,
- and the max heap, in which the <font color=red> largest key value is always at the front </font>.


---

## heap implementation

take advantage of the logarithmic nature of the binary tree
- In order to guarantee logarithmic performance, we must keep our tree balanced.
- A balanced binary tree has roughly the same number of nodes in the left and right subtrees of the root.
- keep the tree balanced by creating a <font color=red> complete binary tree </font>.
  - A complete binary tree is a tree in which each level has all of its nodes.
  - The exception to this is the bottom level of the tree, which we fill in from left to right.  

![heapOrder](https://i.imgur.com/FzGkeOJ.png)

The method to store items in a heap relies on maintaining the **heap order property**.
- The heap order property is as follows:
- In a heap, for every node `ùë•` with parent `ùëù`,
- the key in `ùëù` is smaller than or equal to the key in `ùë•`.
- Figure 2 also illustrates a complete binary tree that has the heap order property.

![percUp](https://i.imgur.com/xWvuclU.png)



---

### min heap operation

- `BinaryHeap()`
  - creates a new, empty, binary heap.
- `insert(k)`
  - adds a new item to the heap.
- `findMin()`
  - returns the item with the minimum key value, leaving item in the heap.
- `delMin()`
  - returns the item with the minimum key value, removing the item from the heap.
- `isEmpty()`
  - returns true if the heap is empty, false otherwise.
- `size()`
  - returns the number of items in the heap.
- `buildHeap(list)`
  - builds a new heap from a list of keys.

```py
from pythonds.trees import BinHeap

class BinHeap:
    def __init__(self):
        self.heapList = [0]
        self.currentSize = 0


    def percUp(self,i):
        while i // 2 > 0:
          if self.heapList[i] < self.heapList[i // 2]:
             tmp = self.heapList[i // 2]
             self.heapList[i // 2] = self.heapList[i]
             self.heapList[i] = tmp
          i = i // 2

    def insert(self,k):
      self.heapList.append(k)
      self.currentSize = self.currentSize + 1
      self.percUp(self.currentSize)

    def percDown(self,i):
      while (i * 2) <= self.currentSize:
          mc = self.minChild(i)
          if self.heapList[i] > self.heapList[mc]:
              tmp = self.heapList[i]
              self.heapList[i] = self.heapList[mc]
              self.heapList[mc] = tmp
          i = mc

    def minChild(self,i):
      if i * 2 + 1 > self.currentSize:
          return i * 2
      else:
          if self.heapList[i*2] < self.heapList[i*2+1]:
              return i * 2
          else:
              return i * 2 + 1

    def delMin(self):
      retval = self.heapList[1]
      self.heapList[1] = self.heapList[self.currentSize]
      self.currentSize = self.currentSize - 1
      self.heapList.pop()
      self.percDown(1)
      return retval

    def buildHeap(self,alist):
      i = len(alist) // 2
      self.currentSize = len(alist)
      self.heapList = [0] + alist[:]
      while (i > 0):
          self.percDown(i)
          i = i - 1

bh = BinHeap()
bh.buildHeap([9,5,6,2,3])

print(bh.delMin())
print(bh.delMin())
print(bh.delMin())
print(bh.delMin())
print(bh.delMin())
```

Notice that no matter the order that we add items to the heap, the smallest is removed each time.  

---

### heap in python

```py
# an empty binary heap has a single zero as the first element of heapList and that this zero is not used, but is there so that simple integer division can be used in later methods.
class BinHeap:
    def __init__(self):
        self.heapList = [0]
        self.currentSize = 0
```


#### `insert`
- most efficient way to add an item to a list is to simply append the item to the end of the list.
- The good news about appending is that it guarantees that we will maintain the complete tree property.
- The bad news about appending is that we will very likely violate the heap structure property.
- However, it is possible to write a method to regain the **heap structure property** by comparing the newly added item with its parent.
  - If the newly added item is less than its parent, then we can swap the item with its parent.  

![percUp](https://i.imgur.com/xWvuclU.png)


when we percolate Êâ©Êï£ an item up
- we are restoring the heap property between the newly added item and the parent.
- We are also preserving the heap property for any siblings.
- Of course, if the newly added item is very small, we may still need to swap it up another level.
- In fact, we may need to keep swapping until we get to the top of the tree.

`percUp`
- percolates a new item as far up in the tree as it needs to go to maintain the heap property.
- Here is where our wasted element in heapList is important.
- Notice that we can compute the parent of any node by using simple integer division.
- The parent of the current node can be computed by dividing the index of the current node by 2.


```py
def percUp(self,i):
    while i // 2 > 0:
      if self.heapList[i] < self.heapList[i // 2]:
         tmp = self.heapList[i // 2]
         self.heapList[i // 2] = self.heapList[i]
         self.heapList[i] = tmp
      i = i // 2

def insert(self,k):
    self.heapList.append(k)
    self.currentSize = self.currentSize + 1
    self.percUp(self.currentSize)
```


#### `delMin`

> to keep complete binary tree, replace the last item with the root

- Since the heap property requires that the root of the tree be the smallest item in the tree, finding the minimum item is easy.
- The hard part of delMin is restoring full compliance with the heap structure and heap order properties after the root has been removed.

restore our heap in two steps.
- First, restore the root item by taking the last item in the list and moving it to the root position.
  - It maintains our heap structure property.
  - But we have probably destroyed the heap order property of our binary heap.
- Second, restore the heap order property by pushing the new root node down the tree to its proper position.  
  - to maintain the heap order property,
  - swap the root with its smallest child less than the root.
  - After the initial swap, we may repeat the swapping process with a `node` and `its children` until the node is swapped into a position on the tree where it is already less than both children.

![percDown](https://i.imgur.com/I1kHltA.png)

```py
def percDown(self,i):
    while (i * 2) <= self.currentSize:
        mc = self.minChild(i)
        if self.heapList[i] > self.heapList[mc]:
            tmp = self.heapList[i]
            self.heapList[i] = self.heapList[mc]
            self.heapList[mc] = tmp
        i = mc

def minChild(self,i):
    if i * 2 + 1 > self.currentSize:
        return i * 2
    # i * 2 + 1 <= self.currentSize
    else:
        if self.heapList[i*2] < self.heapList[i*2+1]:
            return i * 2
        else:
            return i * 2 + 1
```



`delMin`
- the hard work is handled by a helper function, in this case percDown.

```py
def delMin(self):
    retval = self.heapList[1]
    self.heapList[1] = self.heapList[self.currentSize]
    self.currentSize = self.currentSize - 1
    self.heapList.pop()
    self.percDown(1)
    return retval
```



build an entire heap from a list of keys.

build a heap by inserting each key one at a time.
- a list of one item, the list is sorted
- use binary search to find the right position to insert the next key at a cost of approximately `ùëÇ(logùëõ)` operations.
- However, inserting an item in the middle of the list may require `ùëÇ(ùëõ)` operations to shift the rest of the list over to make room for the new key.
- Therefore, to insert `ùëõ` keys into the heap would require a total of `ùëÇ(ùëõlogùëõ)` operations.


if we start with an entire list then we can build the whole heap in `ùëÇ(ùëõ)` operations.   

```py
def buildHeap(self, alist):
    i = len(alist) // 2
    self.currentSize = len(alist)
    self.heapList = [0] + alist[:]
    while (i > 0):
        self.percDown(i)
        i = i - 1
```

![buildheap](https://i.imgur.com/KjU539s.png)


`percDown` method ensures that the largest child is always moved down the tree.
- Because the heap is a complete binary tree, any nodes past the halfway point will be leaves and therefore have no children.
- when `i=1`, we are percolating down from the root of the tree, so this may require multiple swaps.

As you can see in the rightmost two trees of Figure 4,
- first the 9 is moved out of the root position,
- but after 9 is moved down one level in the tree,
- percDown ensures that we check the next set of children farther down in the tree to ensure that it is pushed as low as it can go.
- In this case it results in a second swap with 3. Now that 9 has been moved to the lowest level of the tree, no further swapping can be done.
- It is useful to compare the list representation of this series of swaps as shown in Figure 4 with the tree representation.

```py
i = 2  [0, 9, 5, 6, 2, 3]
i = 1  [0, 9, 2, 6, 5, 3]
i = 0  [0, 2, 3, 6, 5, 9]
```


The assertion that we can build the heap in `ùëÇ(ùëõ)` is beyond the scope of this book. However, the key to understanding that you can build the heap in `ùëÇ(ùëõ)` is to remember that the `logùëõ` factor is derived from the height of the tree.

For most of the work in buildHeap, the tree is shorter than `logùëõ`

Using the fact that you can build a heap from a list in `ùëÇ(ùëõ)` time, you will construct a sorting algorithm that uses a heap and sorts a list in `ùëÇ(ùëõlogùëõ))` as an exercise at the end of this chapter.



#### analyze the binary heap

- find the smallest: `ùëÇ(1)`
- insert: `ùëÇ(logùëõ)`
- removal: `ùëÇ(logùëõ)`











.
