---
title: Coding - Object Oriented Programming
date: 2019-10-11 11:11:11 -0400
description:
categories: [04CodeNote]
tags: []
---

- [Object-oriented programming 面向对象编程](#object-oriented-programming-面向对象编程)
  - [Python Object-oriented programming `class&Instance`](#python-object-oriented-programming-classinstance)
  - [Java Object-oriented programming](#java-object-oriented-programming)
    - [2.1.2 Object-Oriented Design Principles](#212-object-oriented-design-principles)
      - [Abstraction](#abstraction)
      - [Encapsulation](#encapsulation)
      - [Modularity](#modularity)
    - [`面向过程`和`OOP`在程序流程上的不同之处。](#面向过程和oop在程序流程上的不同之处)
- [Packages and Imports](#packages-and-imports)
  - [Import](#import)
- [Controlling Access to Members of a Class](#controlling-access-to-members-of-a-class)
- [5.4.1. User-defined Classes](#541-user-defined-classes)
  - [Class](#class)
  - [Object](#object)
    - [Class hierarchy versus instance hierarchy](#class-hierarchy-versus-instance-hierarchy)
- [difference between class and object:](#difference-between-class-and-object)
  - [Types of Class](#types-of-class)
  - [Uses of Class](#uses-of-class)
  - [Use of Object](#use-of-object)
- [example](#example)
  - [OOPs in Python](#oops-in-python)
  - [OOPs in Java: Classes and Objects](#oops-in-java-classes-and-objects)
- [2.2. Inheritance](#22-inheritance)
  - [22.1. Introduction: Class Inheritance](#221-introduction-class-inheritance)
    - [Class Inheritance example](#class-inheritance-example)
    - [example1](#example1)
    - [example2](#example2)
  - [Polymorphism and Dynamic Dispatch](#polymorphism-and-dynamic-dispatch)
  - [Inheriting Variables and Methods](#inheriting-variables-and-methods)
    - [Mechanics of Defining a Subclass](#mechanics-of-defining-a-subclass)
    - [How the interpreter looks up attributes](#how-the-interpreter-looks-up-attributes)
  - [code implement](#code-implement)
    - [The `__init__()` Method for a Child Class](#the-__init__-method-for-a-child-class)
    - [Instances as Attributes](#instances-as-attributes)
    - [`Overrid` 覆写 Methods](#overrid-覆写-methods)
  - [22.4. Invoke 调用 the Parent Class’s Method](#224-invoke-调用-the-parent-classs-method)
  - [继承和多态](#继承和多态)
    - [继承](#继承)
    - [继承好处](#继承好处)
    - [多态](#多态)
    - [多态的好处](#多态的好处)
  - [静态语言 vs 动态语言](#静态语言-vs-动态语言)
  - [Importing Classes](#importing-classes)
    - [Importing a Single Class](#importing-a-single-class)

---

# Object-oriented programming 面向对象编程



## Python Object-oriented programming `class&Instance`

Python is an `object-oriented programming` language.
- provides features that support `object-oriented programming (OOP)`.


`procedural programming` 面向过程
- focus is on writing function/procedure which operate on data.
- 把计算机程序 视为一系列的命令集合，即一组函数的顺序执行。
- 为了简化程序设计，面向过程把函数继续切分为子函数，即把大块函数通过切割成小块函数来降低系统的复杂度。


`Object Oriented Programming - OOP 面向对象`的程序设计
- focus is on the creation of objects which contain both data and functionality together.
- 一种程序设计思想。
- 把`Object`作为程序的基本单元
- 一个`Object`包含了数据和操作数据的函数。
- 把 计算机程序 视为一组对象的集合，而每个对象都可以接收其他对象发过来的消息，并处理这些消息，计算机程序的执行就是一系列消息在各个对象之间传递。

在Python中，所有数据类型都可以视为Object，当然也可以自定义对象。
- 自定义的对象数据类型就是面向对象中的类（`Class`）的概念。


## Java Object-oriented programming

the main “actors” in the object-oriented paradigm are called `objects`.

- Each `object` is an `instance` of a `class`.

- Each `class` presents to the outside world a concise and consistent view of the objects that are instances of this class, without going into too much unnecessary detail or giving others access to the inner workings of the objects.

- The class definition typically specifies the data fields, also known as instance variables, that an object contains, as well as the methods (operations) that an object can execute.  


Software implementations should achieve robustness, adaptability, and reusability.

### 2.1.2 Object-Oriented Design Principles

Chief among the principles of the object-oriented approach, which are intended to facilitate the goals outlined above
- Abstraction
- Encapsulation  
- Modularity


#### Abstraction
- The notion of abstraction is to distill a complicated system down to its most fundamental parts.
- Typically, describing the parts of a system involves naming them and explaining their functionality.
- Applying the abstraction paradigm to the design of data structures gives rise to **abstract data types (ADTs)**.

**abstract data types (ADTs)**
- An ADT is a mathematical model of a data structure that specifies `the type of data stored, the operations supported on them, and the types of parameters of the operations`.
- An ADT specifies what each operation does, but not how it does it.

**interface**
- In Java, an ADT can be expressed by an **interface**
- simply a list of method declarations, where each method has an empty body.

**class**
- An ADT is realized by a concrete data structure, which is modeled in Java by a **class**.
- A class defines the data being stored and the operations supported by the objects that are instances of the class.
- Also, unlike interfaces, classes specify how the operations are performed in the body of each method.
- A Java class is said to implement an interface if its methods include all the methods declared in the interface, thus providing a body for them.
- However, a class can have more methods than those of the interface.




#### Encapsulation
- `different components of a software system should not reveal 揭示 the internal details of their respective implementations`.
- One of the main advantages of encapsulation is that it gives one programmer freedom to implement the details of a component, without concern that other programmers will be writing code that intricately depends on those internal decisions.
- The only constraint on the programmer of a component is to **maintain the public interface for the component**, as other programmers will be writing code that depends on that interface.
- Encapsulation yields robustness and adaptability, for it allows the implementation details of parts of a program to change without adversely affecting other parts, thereby making it easier to fix bugs or add new functionality with relatively local changes to a component.



#### Modularity
- Modern software systems typically consist of several different components that must interact correctly in order for the entire system to work properly.
- Keeping these interactions straight requires that these different components be well organized.
- Modularity refers to an organizing principle in which `different components of a software system are divided into separate functional units`.
- Robustness is greatly increased because it is easier to test and debug separate components before they are integrated into a larger software system.


2.2 Inheritance
A natural way to organize various structural components of a software package is in a hierarchical fashion, with similar abstract definitions grouped together in a level-by-level manner that goes from specific to more general as one traverses up the hierarchy. An example of such a hierarchy is shown in Figure 2.3. Using mathematical notations, the set of houses is a subset of the set of buildings, but a superset of the set of ranches. The correspondence between levels is often referred to as an “is a” relationship, as a house is a building, and a ranch is a house.




---

### `面向过程`和`OOP`在程序流程上的不同之处。

处理学生的成绩表

1. `面向过程`的程序

    ```py
    # 为了表示一个学生的成绩，用一个dict表示：
    std1 = { 'name': 'Michael', 'score': 98 }
    std2 = { 'name': 'Bob', 'score': 81 }
    # 处理学生成绩可以通过函数实现，比如打印学生的成绩：
    def print_score(std):
        print('%s: %s' % (std['name'], std['score']))
    ```  

2. `面向对象`的程序设计思想

   - 首选思考的不是程序的执行流程，而是Student这种数据类型应该被视为一个对象，这个对象拥有name和score这两个属性（`Property`）。
   - 如果要打印一个学生的成绩
     - 首先创建出学生对应的对象，

      ```py
      class Student(object):
          def __init__(self, name, score):
              self.name = name
              self.score = score
          def print_score(self):
              print('%s: %s' % (self.name, self.score))

      bart = Student('Bart Simpson', 59)
      lisa = Student('Lisa Simpson', 87)
      ```        

     - 然后，给对象发一个print_score消息，让对象自己把自己的数据打印出来。
       - 给对象发消息实际上就是调用`对象对应的关联函数`
       - 称之为`对象的方法（Method）`。

      ```py
      bart.print_score()
      lisa.print_score()
      ```

`面向对象`的设计思想是从自然界中来的，因为在自然界中，类（Class）和实例（Instance）的概念是很自然的。
- `Class`是一种抽象概念，比如我们定义的Class——Student，是指学生这个概念
- 而实例（`Instance`）则是一个个具体的Student，比如，Bart Simpson和Lisa Simpson是两个具体的Student。

所以，面向对象的设计思想是抽象出`Class`，根据`Class`创建`Instance`。
- 面向对象的抽象程度又比函数要高，因为一个Class既包含数据，又包含操作数据的方法

---

# Packages and Imports

- Every stand-alone public class defined in Java must be given in a separate file.
- The file name is the name of the class with a .java extension.

**package**
- To aid in the organization of large code repository, Java allows a group of related type definitions to be grouped into what is known as a `package`.
- For types to belong to a package named `packageName`, their source code must all be located in a directory named `packageName` and each file must begin with the line: `package packageName;`


## Import


```java
// Import Statements in java
java.util.Scanner input = new java.util.Scanner(System.in);

import java.util.Scanner;
Scanner input = new Scanner(System.in);


// Importing a Whole Package
import packageName.∗;
```



---

# Controlling Access to Members of a Class

**Access level modifiers** determine `whether other classes can use a particular field or invoke a particular method`.

There are two levels of access control:
- At the top level—`public`, or package-private (no explicit modifier).
- At the member level—`public, private, protected`, or package-private (no explicit modifier)


A class may be declared with the modifier `public`
- that class is visible to all classes everywhere.
- If a class has no modifier (the default, also known as package-private), it is visible only within its own package (packages are named groups of related classes)


The `private` modifier
- specifies that the member can only be accessed in its own class.

The `protected` modifier
- specifies that the member can only be accessed within its own package (as with package-private)
- and, in addition, by a subclass of its class in another package.

---

# 5.4.1. User-defined Classes

Python provides a way to define `new functions` in programs, it also provides a way to `define new classes of objects`.

---

## Class

- an entity
- determines how an object will behave and what the object will contain.
- a blueprint or a set of instruction to build a specific type of object.
- It provides initial values for member variables and member functions or methods.

---

## Object

- a self-contained component
- consists of methods and properties to make a data useful.
- helps to determines the behavior of the class.
- For example
  - send a message to an object
  - asking the object to invoke or execute one of its methods.

- From a programming point of view, an object can be a data structure, a variable, or a function that has a memory location allocated.
- The object is designed as class hierarchies.


User creatable objects
- In a user program, only objects belonging to certain classes can be created directly.
- In the class hierarchy chart, the yellow boxes denote these user-instantiable classes.
- The other classes fall into one of four categories:
  - Non-instantiable superclasses such as Base and View
  - Classes designed to function only as composite class members, such as PlotManager and subclasses of the Transformation class
  - The classes that can have only one instance, such as Error and Workspace; they are automatically instantiated when the HLU library is initialized
  - Classes that are instantiated by certain objects for a specialized purpose on behalf of the user; these currently include the XyDataSpec and AnnoManager classes

Dynamically associated objects
- In addition to the class hierarchy and composite class relationships, the HLU library has a mechanism that allows you to associate independently-created View objects dynamically. You can "overlay" Transform class objects onto a plot object's data space. You can also make any View object into an "annotation" of a plot object. The combination of the base plot object, its overlays, and its annotations acts in many ways like a single object. Plot objects, overlays, and annotations are discussed in the PlotManager class module, and also in the AnnoManager class module.

---


### Class hierarchy versus instance hierarchy
Besides the class hierarchy of subclasses derived from the Base superclass, you should be aware that the HLU library defines an "instance hierarchy" of the objects that are created in the course of executing an HLU program. These two hierarchies are completely distinct, and you should be careful not confuse them.
Whenever you create an object, you must specify the object's "parent" as one of the parameters to the create call. Each object you create is therefore the "child" of some parent object. The initial parent, the "ancestor" of all the objects created, must be an "application" (App) object. Depending on the call used to initialize the HLU library, you may need to create this object yourself, or the library may automatically create it for you.

The instance hierarchy is significant in the following ways:

When you destroy a parent object all its children are destroyed along with it.
A View object must have a Workstation class ancestor that supplies the viewspace on which it is drawn.
The resource database uses the instance hierarchy to determine how resource specifications in resource files apply to particular objects in an HLU program.


---



# difference between class and object:

| **Class**                                                   | **Object**                                                   |
| ----------------------------------------------------------- | ------------------------------------------------------------ |
| `template` for creating objects in program.                 | an instance of a class.                                      |
| `logical entity`                                            | Object is a physical entity                                  |
| `does not allocate memory space` when it is created.        | Object allocates memory space when been created.             |
| You can declare class only once.                            | can create more than one object using a class.               |
| Example: Car.                                               | Example: Jaguar, BMW, Tesla, etc.                            |
| Class generates objects                                     | Objects provide life to the class.                           |
| `can't be manipulated` as they are not available in memory. | can be manipulated.                                          |
| `doesn't have any values` associated with the fields.       | Each and every object has values associated with the fields. |
| create class by "class" keyword. `Class XX {}`              | create object by "new" keyword. `XX aa= new XX()`            |

---

## Types of Class

- <font color=red> Derived Classes and Inheritance </font>
  - A derived class is a class which is created or derived from other remining class.
  - It is used for increasing the functionality of base class.
  - This type of class derives and inherits properties from existing class.
  - It can also add or share/extends its own properties.

1. <font color=red> Superclasses </font>
   - A superclass is a class from which you can derive many sub classes.

2. <font color=red> Subclasses </font>
   - A subclass is a class that derives from superclass.

3. <font color=red> Mixed classes </font>
   - combine the functionality from other classes into a new class.
     - inherit the properties of one class to another.
   - It uses a subset of the functionality of class, whereas a derive class uses the complete set of superclass functionality.
   - different
     - A mixed class
       - manages the properties of other classes
       - and may only use a subset of the functionality of a class
     - a derived class
       - uses the complete set of functionality of its superclasses
       - and usually extends this functionality.
   - ![concepts.figure.id.9](https://i.imgur.com/VRvJI7o.gif)

---

## Uses of Class  

- Class is used to <font color=red> hold both data variables and member functions </font>
- for <font color=red> create user define objects </font>
  - provides a way to organize information about data.
- can use class to <font color=red> inherit the property of other class </font>
- take advantage of <font color=red> constructor or destructor </font>
- can be used for a large amount of data and complex applications.

---

## Use of Object  

- <font color=red> give the type of message accepted and the type of returned responses </font>
- use an object to <font color=red> access a piece of memory using an object reference variable </font>
- <font color=red> It is used to manipulate data </font>
- Objects represent <font color=red> a real-world problem </font> for which you are finding a solution.
- It enables data members and member functions to perform the desired task.



---

# example

## OOPs in Python


> Class > Instance > Instance variables/Attributes > Methods

1. import <font color=red> class </font> like `Turtle` or `Screen`

2. create a new <font color=red> instance </font>

    ```py
    import Turtles

    # make a new window for turtles to paint in
    wn = turtle.Screen()  
    # make a new turtle
    alex = turtle.Turtle()  
    ```

   - `alex = turtle.Turtle()`
   - The Python interpreter find that `Turtle` is a <font color=blue> class, not function </font>
   - so it <font color=blue> creates a new instance of the class </font> and returns it.
     - Since the Turtle class was defined in a separate module, (confusingly, also named turtle)
     - had to refer to the class as `turtle.Turtle`.




3. Each instance can have <font color=red> attributes / instance variables </font>

    ```py
    # For example
    # the following code would print out 1100.

    alex.price = 500
    tess.price = 600
    print(alex.price + tess.price)
    ```
    - use `=` to assign values to an attribute


4. <font color=red> Classes have associated methods </font>

    ```py
    alex.forward(50)
    ```

    - The interpreter looks up `alex`
    - finds `alex` is an <font color=blue> instance of the class </font> `Turtle`.
    - Then it looks up the <font color=blue> attribute </font> `forward`
    - finds that it is a <font color=blue> method </font>
      - `Methods` return `values`, like `functions`
      - However, none of the methods of the `Turtle class` return values the way the `len` function does.
    - the interpreter invokes the method, passing 50 as a **parameter**.


The only difference between <font color=red> invocation </font> and <font color=red> function calls </font>
- the `object instance` itself is also passed as a parameter.
- Thus `alex.forward(50)` moves `alex`, while `tess.forward(50)` moves `tess`.


---


## OOPs in Java: Classes and Objects

> design any program using this OOPs approach.



To developing a pet management system, specially meant for dogs.

declared a class called Dog
1. need to <font color=red> model dogs into software entities </font>
   - <img src="https://i.imgur.com/Ditinne.jpg" width="400">


2. need various information about the dogs
   - List down the differences between them.
   - <img src="https://i.imgur.com/WHebHfY.jpg" width="400">
   - differences are also some common characteristics shared by these dogs.
   - These characteristics (breed, age, size, color) can form a data members for your object.



3. list out the common behaviors of these dogs
   - like sleep, sit, eat, etc.
   - So these will be the actions of our software objects.
   - <img src="https://i.imgur.com/0fRi8B6.jpg" width="400">

4. So far we have defined following things,

   - **Class**: Dogs
   - **Data member / objects**: size, age, color, breed, etc.
   - **Methods**: eat, sleep, sit and run.

   - <img src="https://i.imgur.com/kBcpE3f.jpg" width="400">





5. for different values of data members (breed size, age, and color) in Java class, you will get different dog objects.
   - <img src="https://i.imgur.com/8TkR0Io.jpg" width="500">



6. after declared a class called Dog, defined an object of the class called "maltese" using a new keyword.  

    ```java
    // Class Declaration
    class Dog {
        // Instance Variables
        String breed;
        String size;
        int age;
        String color;

        // method 1
        public String getInfo() {
            return ("Breed is: "+breed+" Size is:"+size+" Age is:"+age+" color is: "+color);
        }
    }


    public class Execute{
        public static void main(String\[\] args) {
            Dog maltese = new Dog();
            maltese.breed="Maltese";
            maltese.size="Small";
            maltese.age=2;
            maltese.color="white";
            System.out.println(maltese.getInfo());
        }
    }

    // Output:
    // Breed is: Maltese Size is: Small Age is:2 color is: white
    ```

---


# 2.2. Inheritance



---

## 22.1. Introduction: Class Inheritance


In Java, each class can extend exactly one other class.
- Because of this property, Java is said to allow `only single inheritance among classes`.
- We should also note that even if a class definition makes no explicit use of the **extends** clause, it automatically inherits from a class, `java.lang.Object`, which serves as the `universal superclass in Java`.


Constructors are never inherited in Java.
- When a PredatoryCreditCard instance is created, all of its fields must be properly initialized, including any inherited fields.
- For this reason, the `first operation performed within the body of a constructor must be to invoke a constructor of the superclass`, which is responsible for properly initializing the fields defined in the superclass.
- In Java, a constructor of the superclass is invoked by using the keyword super:
  - `super(cust, mk, acnt, lim, initialBal);`


This use of the `super` keyword is very similar to use of the keyword `this` when invoking a different constructor within the same class
- If a constructor for a `subclass` does not make an explicit call to `super` or `this` as its first command,
  - then an implicit call to `super()`,
  - the zero-parameter version of the superclass constructor, will be made.

---

### Class Inheritance example


### example1
```py
from random import randrange

class Pet():
    boredom_decrement = 5
    hunger_decrement = 5
    boredom_threshold = 5
    hunger_threshold = 10
    sounds = ['Mrrp']

    def __init__(self, name = "Kitty", pet_type="dog"):
        self.name = name
        self.hunger = randrange(self.hunger_threshold)
        self.boredom = randrange(self.boredom_threshold)
        self.sounds = self.sounds[:]  # copy the class attribute, so that when we make changes to it, we won't affect the other Pets in the class
        self.pet_type = pet_type

    def mood(self):
            if self.hunger <= self.hunger_threshold and self.boredom <= self.boredom_threshold:
                if self.pet_type == "dog":
                    return "happy"
                elif self.pet_type == "cat":
                    return "happy, probably"
                else:
                    return "HAPPY"
            elif self.hunger > self.hunger_threshold:
                if self.pet_type == "dog":
                    return "hungry, arf"
                elif self.pet_type == "cat":
                    return "hungry, meeeeow"
                else:
                    return "hungry"
            else:
                return "bored"
```


---

### example2


```py
class Animal(object):      # 编写 Animal类
  def run(self):
      print("Animal is running...")

class Dog(Animal):         # Dog类 继承 Amimal类，没有run方法
  pass
  dog = Dog()
  dog.run()

class Cat(Animal):         # Cat类 继承 Animal类，有自己的run方法
  def run(self):
      print("Cat is running...")
  kitty = Cat()
  kitty.run()

class Tortoise(Animal):
    def run(self):
        print('Tortoise is running slowly...')

class Car(object):    # Car类不继承，有自己的run方法
    def run(self):
        print('Car is running...')

class Stone(object):  # Stone类不继承，也没有run方法
    pass
```



---

## Polymorphism and Dynamic Dispatch

**polymorphism**
- In the context of object-oriented design, it refers to the ability of a `reference variable to take different forms`.

```java
CreditCard card;

// Liskov Substitution Principle
// a variable (or parameter) with a declared type can be assigned an instance from any direct or indirect subclass of that type.
// Informally, this is a manifestation of the “is a” relationship modeled by inheritance, as a predatory credit card is a credit card (but a credit card is not necessarily predatory).
CreditCard card = new PredatoryCreditCard(...); // parameters omitted
```






---

## Inheriting Variables and Methods


### Mechanics of Defining a Subclass

Inheritance
- easy and elegant way to represent these differences.
- A natural way to organize various structural components of a software package



Basically, it works by defining a new class, and using a special syntax to show what the new `sub-class` inherits from a `super-class`.

- to define a `Dog` class as a special kind of `Pet`, you would say that the `Dog` type inherits from the `Pet` type.

- In the definition of the inherited class, only need to specify the methods and instance variables that are different from the parent class (the parent class/superclass)


A hierarchical design is useful in software development, as common functionality can be grouped at the most general level, thereby promoting reuse of code, while differentiated behaviors can be viewed as extensions of the general case.

In object-oriented programming
- the mechanism for a modular and hierarchical organization is a technique known as `inheritance`.
  - This allows a new class to be defined based upon an existing class as the starting point.
- the existing class is typically described as the `base class`, `parent class, or super-class`,
- while the newly defined class is known as the `subclass or child class`.
- the subclass extends the superclass.


When inheritance is used, the subclass `automatically inherits all methods from the superclass` (other than constructors).
- The subclass can differentiate itself from its superclass in two ways.
- It may augment the superclass by adding new fields and new methods.
- It may also specialize existing behaviors by providing a new implementation that overrides an existing method.


```py
from random import randrange

# Here's the original Pet class
class Pet():
    boredom_decrement = 4
    hunger_decrement = 6
    boredom_threshold = 5
    hunger_threshold = 10
    sounds = ['Mrrp']
    def __init__(self, name = "Kitty"):
        self.name = name
        self.hunger = randrange(self.hunger_threshold)
        self.boredom = randrange(self.boredom_threshold)
        self.sounds = self.sounds[:]

    def hi(self):
        print(self.sounds[randrange(len(self.sounds))])
        self.reduce_boredom()

class Cat(Pet):
    sounds = ['Meow']
    def chasing_rats(self):
        return "What are you doing, Pinky? Taking over the world?!"

class Cheshire(Cat):
    def smile(self):
        print(":D :D :D")


cat1 = Cat("Fluffy")
cat1.hi()   # Uses the special Cat hello.

new_cat = Cheshire("Pumpkin") # Cheshire cat instance
new_cat.hi()           # same as Cat!
new_cat.chasing_rats() # OK, as Cheshire inherits from Cat
new_cat.smile() # Only for Cheshire instances (and any classes that you make inherit from Cheshire)
# cat1.smile() # This line would give you an error, because the Cat class does not have this method!

# None of the subclass methods can be used on the parent class, though.
p1 = Pet("Teddy")
p1.hi() # just the regular Pet hello
#p1.chasing_rats() # This will give you an error -- this method doesn't exist on instances of the Pet class.
#p1.smile() # This will give you an error, too. This method does not exist on instances of the Pet class.

```


---

### How the interpreter looks up attributes

how the interpreter looks up attributes:

1. First, it checks for an `instance variable/method` by the name.

2. If an `instance variable/method` by that name is not found, it checks for a `class variable`. (See the previous chapter for an explanation of the difference between instance variables and class variables.)

3. If no `class variable` is found, it looks for a `class variable` in the `parent class`.

4. If no `class variable` is found, the interpreter looks for a class variable in THAT class’s parent (the “grandparent” class).

5. This process goes on until the last ancestor is reached, at which point Python will signal an error.

---

```py
new_cat = Cheshire("Pumpkin")
print(new_cat.name)
```

Python looks for the `instance variable` <font color='red'> name </font> in the `new_cat instance`.
- In this case, it exists. The name on this instance of Cheshire is Pumpkin.

---

```py
cat1 = Cat("Sepia")
cat1.hi()
```

The Python interpreter looks for `hi` in the instance of `Cat`.
- It does not find it, because there’s no statement of the form `cat1.hi = ....` (if you had set an instance variable on Cat called hi it would be a bad idea, because you would not be able to use the method that it inherited anymore. We’ll see more about this later.)
- Then it looks for a <font color=DarkCyank> class variable/method `hi` </font> in the <font color='Medblue'> class Cat </font> , and still doesn’t find it.
- Next, it looks for a <font color=DarkCyank> class variable </font> `hi` on the parent of <font color=Medblue> class Cat </font> , <font color=red> Pet class </font>
- It finds that – there’s a <font color=DarkCyank> method  </font> called `hi` on the <font color=red> Pet class </font>. Because of the () after hi, the method is invoked.

---

```py
p1 = Pet("Teddy")
p1.chasing_rats()
```

The Python interpreter looks for an <font color=DarkCyank>  instance variable/method </font> called `chasing_rats` on the <font color='red'> Pet class </font>
- It doesn’t exist. <font color='red'> Pet class </font> has no parent classes, so Python signals an error.

---

```py
new_cat = Cheshire("Pumpkin")
```

Neither Cheshire nor Cat defines an `__init__` constructor method
- so the grandaprent <font color=red> Pet class </font> will have it's `__init__` method called.
- That constructor method sets the instance variables name, hunger, boredom, and sounds.

---


## code implement

### The `__init__()` Method for a Child Class

Child Class:
- The `__init__()` method: takes in the information required to make a Car instance.
- The `super()` function:
    - a special function to call method from the parent class.
    - tells Python to call the __init__() method from Car, which gives an ElectricCar instance all the attributes defined in that method.

```py
class Car:
    def __init__(self, make, model, year):
        self.make = make
        self.model = model self.year = year self.odometer_reading = 0

    def get_descriptive_name(self):
        long_name = f"{self.year} {self.manufacturer} {self.model}"
        return long_name.title()

    def read_odometer(self):
        print(f"This car has {self.odometer_reading} miles on it.")

    def update_odometer(self, mileage):
        if mileage >= self.odometer_reading:
            self.odometer_reading = mileage else:
            print("You can't roll back an odometer!")

    def increment_odometer(self, miles):
        self.odometer_reading += miles

class ElectricCar(Car):

    def __init__(self, make, model, year):
        super().__init__(make, model, year)
        self.battery_size = 75

    # Overriding Methods from the Parent Class
    def fill_gas_tank(self):
        print("This car doesn't need a gas tank!")

my_tesla = ElectricCar('tesla', 'model s', 2019)
my_tesla.battery.describe_battery()

print(my_tesla.get_descriptive_name())

```


### Instances as Attributes

```py
class Battery:
    def __init__(self, battery_size=75):
        self.battery_size = battery_size

    def get_range(self):
        if self.battery_size == 75:
            range = 260
        elif self.battery_size == 100:
            range = 315
        print(f"This car can go about {range} miles on a full charge.")

    def describe_battery(self):
        print(f"This car has a {self.battery_size}-kWh battery.")


class ElectricCar(Car):
    def __init__(self, make, model, year):
        super().__init__(make, model, year)
        # Instances as Attributes
        self.battery = Battery()

    # Overriding Methods from the Parent Class
    def fill_gas_tank(self):
        print("This car doesn't need a gas tank!")

my_tesla = ElectricCar('tesla', 'model s', 2019)

my_tesla.battery.describe_battery()
my_tesla.battery.get_range()

# 2019 Tesla Model S
# This car has a 75-kWh battery.
# This car can go about 260 miles on a full charge.
```

---

### `Overrid` 覆写 Methods


`Overrid` 覆写 Methods:

```py

class Parent(Object):

      def samename(self):
          statement1

class child(Parent):

      def samename(self):
          statement2
          # will only performer statement2
```


```py
keep the original Pet class.

make two `subclasses`, Dog and Cat.
- Dogs are always happy unless they are bored and hungry.
- Cats are happy only if they are fed and if their boredom level is in a narrow range and, even then, only with probability 1/2.

# the original Pet class again.
class Cat(Pet):
    sounds = ['Meow']

    def mood(self):
        if self.hunger > self.hunger_threshold:
            return "hungry"
        if self.boredom <2:
            return "grumpy; leave me alone"
        elif self.boredom > self.boredom_threshold:
            return "bored"
        elif randrange(2) == 0:
            return "randomly annoyed"
        else:
            return "happy"

class Dog(Pet):
    sounds = ['Woof', 'Ruff']
    def mood(self):
        if (self.hunger > self.hunger_threshold) and (self.boredom > self.boredom_threshold):
            return "bored and hungry"
        else:
            return "happy"

c1 = Cat("Fluffy")
d1 = Dog("Astro")

c1.boredom = 1
print(c1.mood())    # grumpy; leave me alone
c1.boredom = 3
for i in range(10):
    print(c1.mood())
print(d1.mood())

```

---

## 22.4. Invoke 调用 the Parent Class’s Method

`Invoke` 覆写 Methods:

```py

class Parent(Object):

      def samename(self):
          statement1

class child(Parent):

      def samename(self):
          Parent.samename(self)
          statement2
          # will performer both statement1&2
```


```py

class superclass():

    def __init__(self,x):
        self.x=x

    def method(self):
        print(1)


class childclass(superclass):

    def __init__(self,x,y=2):
        superclass.__init__(self,x)
        self.y=y

    def method(self):
        superclass.method(self)
        print(2)
```

Sometimes the parent class has a useful method,
- just need to execute a little extra code when running the subclass’s method.
- override the parent class’s method in the subclass’s method with the same name, or invoke the parent class’s method.

```py

# the original Pet class again.

class Pet():
    boredom_decrement = 4
    hunger_decrement = 6
    boredom_threshold = 5
    hunger_threshold = 10
    sounds = ['Mrrp']
    def __init__(self, name = "Kitty"):
        self.name = name
        self.hunger = randrange(self.hunger_threshold)
        self.boredom = randrange(self.boredom_threshold)
        self.sounds = self.sounds[:]  # copy the class attribute, so that when we make changes to it, we won't affect the other Pets in the class

    def feed(self):
        self.reduce_hunger()

// wanted the Dog subclass of Pet to say “Arf! Thanks!” when the feed method is called

class Dog(Pet):
    sounds = ['Woof', 'Ruff']

    def feed(self):
        Pet.feed(self)
        print("Arf! Thanks!")

# if the Pet.feed(self) line was deleted?
# no longer calling the parent Pet class's method in the Dog subclass's method definition, the class definition will override the parent method.
# the actions defined in the parent method feed will not happen, and only Arf! Thanks! will be printed.
# The string would print but d1 would not have its hunger reduced.

d1 = Dog("Astro")
d1.feed()
#
Arf! Thanks!
```

here’s a subclass that overrides feed() by invoking the the parent class’s feed() method;
- it then also executes an extra line of code. Note the somewhat inelegant way of invoking the parent class’ method.
- We explicitly refer to `Pet.feed` to get the method/function object. We invoke it with parentheses. However, since we are not invoking the method the normal way, with `<obj>.methodname`, we have to explicitly pass an instance as the first parameter.
- In this case, the variable `self` in `Dog.feed()` will be bound to an instance of Dog, and so just pass `self`: `Pet.feed(self)`.


This technique is very often used with the `__init__` method for a subclass.
- some extra instance variables are defined for the subclass.
- When you invoke the constructor, you pass all the regular parameters for the parent class, plus the extra ones for the subclass.
- The subclass’ `__init__` method then stores the extra parameters in instance variables and calls the parent class’ `__init__` method to store the common parameters in instance variables and do any other initialization that it normally does.

```py
class Pet():

    def hi(self):
        print(self.sounds[randrange(len(self.sounds))])
        self.reduce_boredom()

class Bird(Pet):
    sounds = ["chirp"]

    def __init__(self, name="Kitty", chirp_number=2):
        Pet.__init__(self, name) # call the parent class's constructor
        # basically, call the SUPER -- the parent version -- of the constructor, with all the parameters that it needs.
        self.chirp_number = chirp_number # now, also assign the new instance variable

    def hi(self):
        for i in range(self.chirp_number):
            print(self.sounds[randrange(len(self.sounds))])
            print(8)
        self.reduce_boredom()

b1 = Bird('tweety', 5)
b1.teach("Polly wanna cracker")
b1.hi()
# overwrite
Polly wanna cracker
8
Polly wanna cracker
8
chirp
8
Polly wanna cracker
8
chirp
8
```

---

## 继承和多态

### 继承
在Object Oriented Programming OOP程序设计中，当我们定义一个class的时候，可以从某个现有的class继承，新的class称为`子类 Subclass`，而被继承的class称为`基/父/超类（Base / Super class）`。

比如

```py

1.  编写了一个名为`Animal`的`class`
    - 有一个run()方法可以直接打印：

      class Animal(object):
          def run(self):
              print('Animal is running...')


2.  需要编写Dog和Cat类时，就可以直接从Animal类继承：
    - 于Dog来说，Animal就是它的父类
    - 对于Animal来说，Dog就是它的子类。Cat和Dog类似。

      class Dog(Animal):
          pass

      class Cat(Animal):
          pass
```

### 继承好处

```py

1.  最大的好处是子类获得了父类的全部功能。
    - 由于Animial实现了run()方法，因此，Dog和Cat作为它的子类，什么事也没干，就自动拥有了run()方法：

        dog = Dog()
        dog.run()

        cat = Cat()
        cat.run()
        # 结果
        Animal is running...
        Animal is running...


2.  可以对子类增加一些方法，比如Dog类：

        class Dog(Animal):

            def eat(self):
                print('Eating meat...')


3.  可以对代码做改进

        class Dog(Animal):

            def run(self):
                print('Dog is running...')

        class Cat(Animal):

            def run(self):
                print('Cat is running...')
        # 结果
        Dog is running...
        Cat is running...
```

当子类和父类都存在相同的run()方法时，
- 子类的run()覆盖了父类的run()
- 在代码运行的时候，总是会调用子类的run()。
- 这样，我们就获得了继承的另一个好处：`多态`。


### 多态

- 当定义一个`class`的时候，我们实际上就定义了一种数据类型。
- 我们定义的数据类型和Python自带的数据类型，比如str、list、dict没什么两样

```py
a = list()    # a是list类型
b = Animal()  # b是Animal类型
c = Dog()     # c是Dog类型

判断一个变量是否是某个类型可以用 isinstance() 判断：
>>> isinstance(a, list)
True
>>> isinstance(b, Animal)
True
>>> isinstance(c, Dog)
True
# a、b、c确实对应着list、Animal、Dog这3种类型。
>>> isinstance(c, Animal)
True
# c不仅仅是Dog，c还是Animal！
```

因为Dog是从Animal继承下来的，当创建一个Dog的实例c，c的数据类型是Dog，同时也是Animal，Dog本来就是Animal的一种

所以，在继承关系中，如果一个实例的数据类型是某个子类，那它的数据类型也可以被看做是父类。但是，反过来就不行：

```py
>>> b = Animal()
>>> isinstance(b, Dog)
False
Dog可以看成Animal，但Animal不可以看成Dog。
```


### 多态的好处


```py
编写一个函数接受一个Animal类型的变量：

def run_twice(animal):
    animal.run()
    animal.run()

# 当我们传入Animal的实例时，run_twice()就打印出：
>>> run_twice(Animal())
Animal is running...
Animal is running...

# 当我们传入Dog的实例时，run_twice()就打印出：
>>> run_twice(Dog())
Dog is running...
Dog is running...

# 当我们传入Cat的实例时，run_twice()就打印出：
>>> run_twice(Cat())
Cat is running...
Cat is running...

如果再定义一个Tortoise类型，也从Animal派生：

class Tortoise(Animal):
    def run(self):
        print('Tortoise is running slowly...')
# 调用run_twice()
>>> run_twice(Tortoise())
Tortoise is running slowly...
Tortoise is running slowly...

新增一个Animal的子类，不必对run_twice()做任何修改
- 任何依赖Animal作为参数的函数或者方法都可以不加修改地正常运行，原因就在于多态。
```


1.  多态的好处就是，当我们需要传入Dog、Cat、Tortoise……时，我们只需要接收Animal类型就可以了，因为Dog、Cat、Tortoise……都是Animal类型，然后，按照Animal类型进行操作即可。
    - 由于Animal类型有run()方法，因此，传入的任意类型，只要是Animal类或者子类，就会自动调用实际类型的run()方法，这就是多态的意思：

对于一个变量，只需要知道它是Animal类型，无需确切地知道它的子类型，就可以调用run()方法，
- 而具体调用的run()方法是作用在Animal、Dog、Cat还是Tortoise对象上，由运行时该对象的确切类型决定，这就是多态真正的威力：
- 调用方只管调用，不管细节，
- 而当新增一种Animal的子类时，只要确保run()方法编写正确，不用管原来的代码是如何调用的。这就是著名的`“开闭”原则`：

对扩展开放：允许新增Animal子类；

对修改封闭：不需要修改依赖 Animal类型的 run_twice() 等函数。

继承还可以一级一级地继承下来，就好比从爷爷到爸爸、再到儿子这样的关系。而任何类，最终都可以追溯到根类object，这些继承关系看上去就像一颗倒着的树。比如如下的继承树：

```py
                ┌───────────────┐
                │    object     │
                └───────────────┘
                        │
           ┌────────────┴────────────┐
           │                         │
           ▼                         ▼
    ┌─────────────┐           ┌─────────────┐
    │   Animal    │           │    Plant    │
    └─────────────┘           └─────────────┘
           │                         │
     ┌─────┴──────┐            ┌─────┴──────┐
     │            │            │            │
     ▼            ▼            ▼            ▼
┌─────────┐  ┌─────────┐  ┌─────────┐  ┌─────────┐
│   Dog   │  │   Cat   │  │  Tree   │  │ Flower  │
└─────────┘  └─────────┘  └─────────┘  └─────────┘
```

## 静态语言 vs 动态语言
对于静态语言（例如Java）来说，如果需要传入Animal类型，则传入的对象必须是Animal类型或者它的子类，否则，将无法调用run()方法。

对于Python这样的动态语言来说，则不一定需要传入Animal类型。我们只需要保证传入的对象有一个run()方法就可以了：

class Timer(object):
    def run(self):
        print('Start...')

这就是动态语言的“鸭子类型”，它并不要求严格的继承体系，一个对象只要“看起来像鸭子，走起路来像鸭子”，那它就可以被看做是鸭子。

Python的`“file-like object“`就是一种鸭子类型。对真正的文件对象，它有一个read()方法，返回其内容。但是，许多对象，只要有read()方法，都被视为“file-like object“。许多函数接收的参数就是“file-like object“，你不一定要传入真正的文件对象，完全可以传入任何实现了read()方法的对象。

---

继承可以把父类的所有功能都直接拿过来，这样就不必重零做起，子类只需要新增自己特有的方法，也可以把父类不适合的方法覆盖重写。

动态语言的鸭子类型特点决定了继承不像静态语言那样是必须的。

---

## Importing Classes

### Importing a Single Class

```py
car.py:

class Car:
"""A simple attempt to represent a car."""
```

1. Importing a Single Class

```py
from car import Car

my_new_car = Car('audi', 'a4', 2019)
my_new_car.odometer_reading = 23
my_new_car.read_odometer()
```

2. Storing Multiple Classes in a Module

```py
from car import ElectricCar
my_tesla = ElectricCar('tesla', 'model s', 2019)
```


3. Importing Multiple Classes from a Module

```py
from car import Car, ElectricCar
```

4. Importing an Entire Module

```py
import car
```

5. Using Aliases

```py
from car import ElectricCar as EC
```


.
