---
title: DS - pythonds3 - 8. Graphs and Graph Algorithms
# author: Grace JyL
date: 2019-08-25 11:11:11 -0400
description:
excerpt_separator:
categories: [04CodeNote, PythonNote]
tags:
math: true
# pin: true
toc: true
# image: /assets/img/sample/devices-mockup.png
---

- [pythonds3 - 8. Graphs and Graph Algorithms](#pythonds3---8-graphs-and-graph-algorithms)
  - [Graphs](#graphs)
    - [Vocabulary and Definitions](#vocabulary-and-definitions)
    - [The Graph Abstract Data Type](#the-graph-abstract-data-type)
      - [An Adjacency Matrix ÈÇªÊé•Áü©Èòµ](#an-adjacency-matrix-ÈÇªÊé•Áü©Èòµ)
      - [An Adjacency List ÈÇªÊé•Ë°®](#an-adjacency-list-ÈÇªÊé•Ë°®)
      - [Implementation](#implementation)
  - [example](#example)
    - [The Word Ladder Problem](#the-word-ladder-problem)
      - [implement](#implement)



---


# pythonds3 - 8. Graphs and Graph Algorithms

---

## Graphs

---


### Vocabulary and Definitions

**Vertex/node**
- a fundamental part of a graph.
- It can have a name, ‚Äúkey.‚Äù
- A vertex may also have additional information, ‚Äúpayload.‚Äù

**Edge/‚Äúarc‚Äù**
- another fundamental part of a graph.
- An edge connects two vertices to show that there is a relationship between them.
- Edges may be one-way or two-way.
  - If the edges in a graph are all one-way, the graph is a **directed graph, digraph**.
    - you must take some step before others.

**Weight**
- Edges may be weighted to show that there is a cost to go from one vertex to another.
- For example
  - graph of roads that connect one city to another,
  - the weight on the edge might represent the distance between the two cities.

With those definitions in hand we can formally define a graph.
- A graph can be represented by ùê∫
- `ùê∫=(ùëâ,ùê∏)`.
- `ùëâ` is a set of vertices
- `ùê∏` is a set of edges.
  - Each edge is a tuple `(ùë£,ùë§)`, `ùë§,ùë£ ‚ààùëâ`.
  - We can add a third component to the edge tuple to represent a weight.
  - A subgraph `ùë†` is a set of edges `ùëí` and vertices `ùë£` such that `ùëí‚äÇùê∏` and `ùë£‚äÇùëâ`.



**Path**
- A path in a graph is a `sequence of vertices` that are connected by edges.  
- Formally we would define a path as `ùë§1,ùë§2,...,ùë§ùëõ` such that `(ùë§ùëñ,ùë§ùëñ+1)‚ààùê∏` for all ¬∑.
- The **unweighted path length** is the `number of edges in the path`, specifically `ùëõ‚àí1`.
- The **weighted path length** is the `sum of the weights of all the edges in the path`.
  - For example
  - the `path from ùëâ3 to ùëâ1 is` the sequence of vertices `(ùëâ3,ùëâ4,ùëâ0,ùëâ1)`.
  - The edges are `{(ùë£3,ùë£4,7),(ùë£4,ùë£0,1),(ùë£0,ùë£1,5)}`.

**Cycle**
- A cycle in a directed graph is a path that `starts and ends at the same vertex`.
  - For example
  - the path `(ùëâ5,ùëâ2,ùëâ3,ùëâ5)` is a cycle.
  - A graph with no cycles is called an **acyclic graph**.
  - A directed graph with no cycles is called a **directed acyclic graph / DAG**
  - We will see that we can solve several important problems if the problem can be represented as a DAG.


![digraph](https://i.imgur.com/CfiBhju.png)

- example of a simple weighted digraph.
- represent this graph as the set of six vertices: `ùëâ={ùëâ0,ùëâ1,ùëâ2,ùëâ3,ùëâ4,ùëâ5}`
- and the set of nine edges: `ùê∏={(ùë£0,ùë£1,5),(ùë£1,ùë£2,4),(ùë£2,ùë£3,9),(ùë£3,ùë£4,7),(ùë£4,ùë£0,1),(ùë£0,ùë£5,2),(ùë£5,ùë£4,8),(ùë£3,ùë£5,3),(ùë£5,ùë£2,1)}`


---

### The Graph Abstract Data Type

The graph **abstract data type (ADT)** is defined as follows:

- `Graph()`
  - creates a new, empty graph.

- `addVertex(vert)`
  - adds an instance of Vertex to the graph.

- `addEdge(fromVert, toVert)`
  - Adds a new, directed edge to the graph that connects two vertices.

- `addEdge(fromVert, toVert, weight)`
  - Adds a new, weighted, directed edge to the graph that connects two vertices.

- `getVertex(vertKey)`
  - finds the vertex in the graph named vertKey.

- `getVertices()`
  - returns the list of all vertices in the graph.

- `in`
  - returns `True` for a statement of the form `vertex in graph`, if the given vertex is in the graph,
  - `False` otherwise.

there are several ways we can implement the graph ADT in Python.
- there are trade-offs in using different representations to implement the ADT described above.
- There are two well-known implementations of a graph,
  - the **adjacency matrix**
  - the **adjacency list**.


---

#### An Adjacency Matrix ÈÇªÊé•Áü©Èòµ

One of the easiest ways to implement a graph is to use a two-dimensional matrix.
- each of the rows and columns represent a `vertex` in the graph.
- The value that is stored in the cell at the `intersection of row ùë£ and column ùë§` indicates if there is an edge from `vertex ùë£ to vertex ùë§`.
- When two vertices are connected by an edge, we say that they are **adjacent**.
- A value in a cell represents the weight of the edge from vertex ùë£ to vertex ùë§.


![adjMat](https://i.imgur.com/5fGmi6O.png)

**advantage**
- simple, for small graphs it is easy to see which nodes are connected to other nodes.
- good implementation for a graph when `the number of edges is large`.

- However not a very efficient way to store sparse data.
  - `most of the cells in the matrix are empty` -> this matrix is **‚Äúsparse**.‚Äù Á®ÄÂ∞ëË¥´‰πè



How many edges would be needed to fill the matrix?
- Since there is one row and one column for every vertex in the graph, the number of edges required to fill the matrix is `|ùëâ|^2`.
- A matrix is full when every vertex is connected to every other vertex.
- There are few real problems that approach this sort of connectivity.

---

#### An Adjacency List ÈÇªÊé•Ë°®
- A more space-efficient way to implement a sparsely connected graph is to use an adjacency list.
- keep a master list of all the vertices in the Graph object
- and then each vertex object in the graph maintains a list of the other vertices that it is connected to.
- In our implementation of the Vertex class we will use a dictionary rather than a list where the dictionary keys are the vertices, and the values are the weights.

advantage
- it allows compactly Á¥ßÂáëÂú∞ represent a sparse graph.
- easily find all the links that are directly connected to a particular vertex.




![adjlist](https://i.imgur.com/2TJvhir.png)


---


#### Implementation

Using dictionaries, it is easy to implement the adjacency list in Python.

create two classes,
- `Graph`, which holds the master list of vertices,
- `Vertex`, which will represent each vertex in the graph.
  - Each Vertex uses a dictionary to keep track of the vertices to which it is connected, and the weight of each edge.
  - This dictionary is called `connectedTo`.

```py
class Vertex:
    def __init__(self,key):
        self.id = key
        self.connectedTo = {}

    def addNeighbor(self,nbr,weight=0):
      # add a connection from this vertex to another
      self.connectedTo[nbr] = weight

    def __str__(self):
        return str(self.id) + ' connectedTo: ' + str([x.id for x in self.connectedTo])

    def getConnections(self):
      # returns all of the vertices in the adjacency list, as represented by the connectedTo instance variable.
      return self.connectedTo.keys()

    def getId(self): return self.id

    def getWeight(self,nbr):
      # returns the weight of the edge from this vertex to the vertex passed as a parameter.
      return self.connectedTo[nbr]

class Graph:
    def __init__(self):
        self.vertList = {}
        self.numVertices = 0

    def addVertex(self,key):
      # adding vertices to a graph
      self.numVertices = self.numVertices + 1
      newVertex = Vertex(key)
      self.vertList[key] = newVertex
      return newVertex

    def getVertex(self,n):
      # returns the names of all of the vertices in the graph
      if n in self.vertList: return self.vertList[n]
      else: return None

    def __contains__(self,n):
        return n in self.vertList

    def addEdge(self,f,t,weight=0):
        if f not in self.vertList: nv = self.addVertex(f)
        if t not in self.vertList: nv = self.addVertex(t)
        self.vertList[f].addNeighbor(self.vertList[t], weight)

    def getVertices(self):
        return self.vertList.keys()

    def __iter__(self):
        return iter(self.vertList.values())


g = Graph()
for i in range(6):
  g.addVertex(i)

# display the vertex dictionary.
g.vertList
# {0: <adjGraph.Vertex instance at 0x41e18>,
#  1: <adjGraph.Vertex instance at 0x7f2b0>,
#  2: <adjGraph.Vertex instance at 0x7f288>,
#  3: <adjGraph.Vertex instance at 0x7f350>,
#  4: <adjGraph.Vertex instance at 0x7f328>,
#  5: <adjGraph.Vertex instance at 0x7f300>}

# add the edges that connect the vertices together.
g.addEdge(0,1,5)
g.addEdge(0,5,2)
g.addEdge(1,2,4)
g.addEdge(2,3,9)
g.addEdge(3,4,7)
g.addEdge(3,5,3)
g.addEdge(4,0,1)
g.addEdge(5,4,8)
g.addEdge(5,2,1)

# a nested loop
# verifies that each edge in the graph is properly stored.
for v in g:
for w in v.getConnections():
    print("( %s , %s )" % (v.getId(), w.getId()))
# ( 0 , 5 )
# ( 0 , 1 )
# ( 1 , 2 )
# ( 2 , 3 )
# ( 3 , 4 )
# ( 3 , 5 )
# ( 4 , 0 )
# ( 5 , 4 )
# ( 5 , 2 )
```

---


## example


### The Word Ladder Problem

Transform the word ‚ÄúFOOL‚Äù into the word ‚ÄúSAGE‚Äù.
- must make the change occur gradually by changing one letter at a time.
- At each step you must transform one word into another word,
- not allowed to transform a word into a non-word.
- The word ladder puzzle was invented in 1878 by Lewis Carroll, the author of Alice in Wonderland.
- The following sequence of words shows one possible solution to the problem posed above.


```
FOOL
POOL
POLL
POLE
PALE
SALE
SAGE
```

we can solve this problem using a graph algorithm.
- Represent the relationships between the words as a graph.
- Use the graph algorithm known as breadth first search to find an efficient path from the starting word to the ending word.


#### implement

![wordgraph](https://i.imgur.com/RP4hnkM.png)

- have an edge from one word to another if the two words are only different by a single letter.
- If we can create such a graph, then any path from one word to another is a solution to the word ladder puzzle.   


could use several different approaches to create the graph
- start with the assumption that we have a list of words that are all the same length.
- create a vertex in the graph for every word in the list.
- to connect the words,
  - compare each word in the list with every other.
    - see how many letters are different.
    - If different by only one letter, create an edge between them
  - For a small set of words that approach would work fine;
    - however let‚Äôs suppose we have a list of 5,110 words.
    - Roughly speaking, comparing one word to every other word on the list is an `ùëÇ(ùëõ^2)` algorithm.
    - For 5,110 words, `ùëõ^2` is more than 26 million comparisons.

  - We can do much better by using the following approach.
    - Suppose that we have a huge number of buckets, each of them with a four-letter word on the outside, except that one of the letters in the label has been replaced by an underscore.
    - For example
    - have a bucket labeled ‚Äúpop_.‚Äù
    - As we process each word in our list we compare the word with each bucket, using the ‚Äò_‚Äô as a wildcard, so both ‚Äúpope‚Äù and ‚Äúpops‚Äù would match ‚Äúpop_.‚Äù
    - Every time we find a matching bucket, we put our word in that bucket.
    - Once we have all the words in the appropriate buckets we know that all the words in the bucket must be connected.


    - implement the scheme by dictionary.
      - The labels on the buckets are the keys in dictionary.
      - The value stored for that key is a list of words.
      - Once we have the dictionary built we can create the graph.
      - We start our graph by
        - creating a vertex for each word in the graph.
        - create edges between all the vertices under the same key in the dictionary.  

```py
from pythonds.graphs import Graph

def buildGraph(wordFile):
    g = Graph()
    d = {}

    # create buckets of words that differ by one letter
    wfile = open(wordFile,'r')
    for line in wfile:
        word = line[:-1]
        for i in range(len(word)):
            bucket = word[:i] + '_' + word[i+1:]
            if bucket in d:
                d[bucket].append(word)
            else:
                d[bucket] = [word]

    # add vertices and edges for words in the same bucket
    for bucket in d.keys():
        for word1 in d[bucket]:
            for word2 in d[bucket]:
                if word1 != word2:
                    g.addEdge(word1,word2)
    return g
```

how sparse is the graph?
- The list of four-letter words we have for this problem is 5,110 words long.
- **adjacency matrix**,
  - the matrix would have `5,110 * 5,110 = 26,112,100 cells`.
- **adjacency list**,
  - The graph constructed by the buildGraph function has exactly `53,286 edges`,
  - only 0.20% of the cells filled!
  - That is a very sparse matrix indeed.





















.
