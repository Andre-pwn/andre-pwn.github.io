##### **LLM 응용 실패 극복과 배운 점**

**실패 사례**
프로젝트 진행 시, 통합테스트의 정확도와 효율성을 높이기 위해 AI를 활용한 BDD 방식을 도입하고자 하였습니다. 이에 AI 기반 BDD 자동화 솔루션 OiBDD를 개발하였으나 프로젝트와 조직에 도입하려는 과정에서 다음과 같은 문제에 직면했습니다:

1. 많은 팀이 SRS를 사용하지 않고, 간단한 문서나 구두로 요구사항을 정의.
2. 팀이 이미 사용 중인 Postman과 같은 기존 도구에 익숙하고, 새로운 도구로 변경하려는 저항감 존재.
3. 팀 내 AI 솔루션의 필요성에 대한 공감 부족.

**극복 과정**

- **사용자 관점에서의 설득과 교육**
  Postman과 AI 기반 도구의 차별점과 장점을 비교 설명하며, AI 솔루션이 제공하는 효율성과 일관성을 강조.
  데모 사이트를 구축하여 공유하고, 교육 세션을 통해 팀원들이 새 도구를 직접 체험하도록 하여 도구에 대한 거부감을 줄임.
- **요구사항 정의 방식의 유연화**
  기존 SRS를 사용하지 않는 팀의 현실을 반영하여 Excel, Word와 같은 다양한 문서 형식을 지원하도록 솔루션을 확장.
  이를 위해 여러 형식의 데이터를 처리할 수 있는 파서를 추가 개발.

**배운점 & 인사이트**

- **기술의 유용성보다 채택 가능성이 중요하다**: 기술적으로 뛰어난 솔루션이라도 사용자 입장에서 필요성과 편리성이 느껴지지 않으면 효과적으로 도입될 수 없다는 점을 깨달았습니다.
- **사용자 중심의 개발**: 초기 설계 단계부터 최종 사용자의 요구와 사용 패턴을 깊이 이해하는 것이 성공적인 도구 도입의 핵심입니다.
- **커뮤니케이션과 교육의 중요성**: 새로운 도구의 도입 과정에서 지속적인 설득과 교육이 필수적임을 배웠습니다.

##### LLM을 활용한 테스트 데이터 생성 최적화 경험

기존에 성능 테스트 및 통합/단위 테스트를 위해 실제와 유사한 mock 데이터를 생성하는 데 많은 비용과 시간이 소요되었습니다. 이를 해결하기 위해 AI 기반 테스트 데이터 생성 프로그램을 개발했습니다.

**초기 문제점**
각 필드마다 LLM을 호출하도록 설계했으나, 이로 인해 비용 증가와 속도 저하라는 치명적인 문제가 발생했습니다.

**해결 방안**
LLM을 통해 생성해야 할 데이터 구조를 분석한 후, 무한대로 데이터를 생성할 수 있는 기존 생성해둔 템플릿을 기반으로 Python 코드를 자동 생성하도록 변경했습니다. 이 방식으로 LLM 호출은 최초 한 번만 이루어지고, 이후에는 Python 코드가 데이터를 생성해 비용 절감과 속도 향상을 동시에 달성했습니다.
또한, Python의 faker 모듈을 활용해 실제와 유사한 고품질 데이터를 생성했습니다.

**성과**
1,000,000건의 mock 데이터를 72.38초 만에 생성, 데이터 생성 속도를 대폭 개선하고 비용 효율성을 확보했습니다.

##### 플랫폼 장애 해결 및 성능 최적화 경험

파일 변경 사항을 감지하고 자동으로 RAG를 위한 임베딩 처리하는 시스템에서 메모리 릭으로 AWS 서버가 반복적으로 다운되는 문제를 해결했습니다.

- **문제 상황**: 크로마DB 인스턴스가 비정상적으로 남아있어 임베딩 작업 시 메모리 사용량이 증가, 서버 다운 발생.
- **해결 방안**: Python 프로파일링으로 원인 분석 후, 비동기 락을 사용해 동시성을 제어하고, 청크 임베딩 작업마다 불필요한 참조 해제 로직 추가.
- **성과**: 메모리 릭 문제를 완전히 해결하고 안정적인 플랫폼 운영 환경 확보.

서버에 변경되는 파일에 대해 자동으로 감지하고 처리하기 위해, 스케쥴을 통해 파일모니터링 라이브러리를 활용해 변경된 파일에 대해 db에서 상태를 관리하도록 해두었습니다. 그리고 변경된 파일에 대해 자동으로 embedding을 수행하기 위해 마찬가지로 스케쥴을 통해 변경된 파일 감지 시 다시 임베딩하는 작업을 추가해두엇습니다. 그런데 매일 아침마다 메모리풀로 aws 서버가 죽어있었습니다. 프로그램 어디에선가 메모리 릭이 발생하는 것이었습니다. 원인을 찾기 위해 의심이 되는 코드에 python profiling을 통해 서버에서 원인을 탐색하였습니다. 메모리 릭의 원인은 크로마DB가 계속 생성된 상태로 남아있고, 임베딩이 진행될때마다 메모리가 쌓여 릭이 발생했던 것이었습니다.
이를 해결하기 위해 비동기 락을 통해 동시성을 제어하고, 청크 임베딩 시 마다 불필요한 참조 해제 로직을 추가하였습니다.
