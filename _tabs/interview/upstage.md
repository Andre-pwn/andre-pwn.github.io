채용공고: https://careers.upstage.ai/o/ai-solution-devoperation?lang=ko

# 기술면접 준비

## 코테 관련 질문

- 문제 다시 풀어보고, 푼 답변에 대해 설명 준비

### 알고리즘-1번문제

**문제 설명**

알파벳 대문자와 소문자로 이루어진 문자열 line이 주어집니다. 이 line을 다음 주어진 규칙에 따라 압축한 뒤 return 하도록 solution 함수를 완성해주세요.

1. 대문자 1개와 그 뒤로 이어지는 모든 연속한 소문자들을 하나의 단어로 생각합니다.
   • 예를 들어 "AdminOfWebsite" 에서 "Admin", "Of", "Website"는 각각 단어입 니다.
2. 문장에서 어떤 단어에 포함되지 않으면서 연속해서 이어진 대문자들 또한 하나의 단어 로 생각합니다.
   • 예를 들어 "EUVersusUAE" 에서 단어 "Versus"를 제외한 부분인 "EU",
   "UAE"가 각각 단어가 됩니다.
3. 문자열을 압축을 할 때, 해당 문자열의 모든 단어들의 맨 앞글자만 남겨두는 방식으로 압축을 진행합니다.
   제한사항

- line의 길이는 1 이상 1,000 이하입니다.
- line의 첫 글자는 항상 대문자입니다.

**답안**

- keypoint
  - 연속된 대문자 뒤 소문자가 오는 경우, 소문자 바로 앞 대문자 저장
  - 소문자 바로 뒤 대문자 저장

```python
def solution(word):
    answer = ""
    char = ""
    isPrevLower = True

    for w in word:
        if w.isupper():
            char = w
            if isPrevLower:
                answer += char
                char = ""
                isPrevLower = False
        else:
            answer += char
            char = ""
            isPrevLower = True
    return answer


print(solution("AdminOfWebsite")) # AOW
print(solution("EUVersusUAE")) # EVU
print(solution("ABCdeFhHQq")) # ACFHQ
```

### 알고리즘-2번문제

**문제 설명**

창고에 재고로 쌓여 있는 상품들을 재포장하려고 합니다. 재포장을 완료하기 위해 추가로 구매해야 하는 상품이 몇 개인지 구하고자 합니다.
창고에는 상품이 2개씩 들어있는 상자가 쌓여있습니다. 한 상자 안에 들어있는 2개의 상품이 같은 종류인 경우도 있고 아닌 경우도 있습니다. 1+1 행사를 위해 모든 상자 안에 같은 종류의 상품을 2개씩 넣고 포장하려고 합니다. 일단, 상품의 짝이 맞지 않는 상자끼리 서로 필요한 물 건을 교환해서 최대한 많은 짝을 맞춰 재포장합니다. 그렇게 했음에도 짝을 맞추기에 수량이 부족한 상품은 추가 구매합니다. 단, 상자는 원래 창고에 쌓여있던 개수만큼 사용할 수 있으며, 추가로 더 가져오거나 구입하지 못합니다.
아래 예시는 재포장을 진행하기 전, 각 상자에 들어있는 상품들의 종류를 나타냅니다.
상자 번호

1 번 상자: 1, 2
2 번 상자: 2, 1
3 번 상자: 3, 3
4 번 상자: 4, 5
5 번 상자: 5, 6
6 번 상자: 7, 8

1번 상자에서는 2번 상품을, 2번 상자에서는 1번 상품을 서로 교환하면 두 상자의 짝 맞추기가 해결됩니다. 3번 상자는 이미 짝이 맞추어져 있기 때문에 다른 상자와 교환할 필요가 없습니 다. 4번 상자는 4번 상품을 5번 상자에 들어있는 5번 상품과 교환하면 짝을 맞출 수 있습니다.
5번과 6번 상자는 남아 있는 상품들로 짝을 맞출 수 없기 때문에 상품의 추가 구매가 필요합니 다. 이때, 2개의 상품만 구매하면 짝을 맞출 수 있습니다. 예를 들어, 4번과 6번 상품을 구매하 면 각각 짝을 만들 수 있습니다.
각 상자에 들어있는 상품의 종류를 나타내는 2차원 배열 boxes가 매개변수로 주어집니다.

1번 상자에서는 2번 상품을, 2번 상자에서는 1번 상품을 서로 교환하면 두 상자의 짝 맞추기가 해결됩니다. 3번 상자는 이미 짝이 맞추어져 있기 때문에 다른 상자와 교환할 필요가 없습니 다. 4번 상자는 4번 상품을 5번 상자에 들어있는 5번 상품과 교환하면 짝을 맞출 수 있습니다.
5번과 6번 상자는 남아 있는 상품들로 짝을 맞출 수 없기 때문에 상품의 추가 구매가 필요합니 다. 이때, 2개의 상품만 구매하면 짝을 맞출 수 있습니다. 예를 들어, 4번과 6번 상품을 구매하 면 각각 짝을 만들 수 있습니다.
각 상자에 들어있는 상품의 종류를 나타내는 2차원 배열 boxes가 매개변수로 주어집니다. 상 품의 짝을 맞춰 재포장을 완료하기 위해 추가로 구매해야 하는 상품의 최소 개수를 return 하 도록 solution 함수를 작성해주세요.
~
~
제한사항

- boxes의 길이(=창고에 재고로 쌓인 상자 개수)는 1 이상 100,000 이하입니다.
- boxes의 원소는 2개의 상품이 들어있는 상자를 나타냅니다.
- boxes의 원소는 [a, b] 형태의 배열입니다.
- a 와 b는 상자 안에 들어있는 상품의 종류를 나타냅니다.
- a 와 b는 1이상 1,000,000 이하인 자연수입니다.
- 모든 상품 종류에 대해 추가 구매 가능한 수량은 무한합니다.
  입출력 예
  boxes result
  [[7, 2], [2, 1], [3, 3], [4, 5], [5, 6], [7, 8]] 2
  [[7, 2], [3, 4], [5, 6]] 3
  [[7, 2], [2, 3], [3, 11]] 0

**답안**

- key point
  - 같은 상품이 두개인 경우 set에서 제외하고, 사용가능한 박스 수를 줄인다.
  - 리스트가 아닌 set을 사용한 이유? 중복 제거 및 빠른 탐색에 set이 적합-내부적으로 해시테이블로 구현-O(1)시간 복잡도-list는 O(n)의 시간복잡도(위치기억)
  - 남은 박스 수와 추가구매 상품 중 작은 숫자를 리턴한다

```python
def solution(boxes):
    # 포장 가능한 박스 수
    available_box_cnt = len(boxes)
    # 추가 주문 필요 상품
    result = set()

    # 박스 확인
    for box in boxes:
        # 박스 속 각 상품 확인
        for b in box:
            # 상품이 추가 주문 필요 상품에 있는 경우
            if b in result:
                #  짝이 맞으므로 추가주문에서 제거
                result.remove(b)
                # 박스에 넣는다
                available_box_cnt -=1
            # 없는 경우
            else:
                # 추가 주문으로 넣기
                result.add(b)

    # 포장 가능한 박스 남은 수보다 추가 주문 상품이 큰 경우
    if available_box_cnt < len(result):
        # 가능한 만큼만 추가주문한다
        return available_box_cnt
    else:
        return len(result)

print(solution([[1, 2], [2, 1], [3, 3], [4, 5], [5, 6], [7, 8]])) # 2
print(solution([[1, 2], [3, 4], [5, 6]])) # 3
print(solution([[1, 2], [2, 3], [3, 1]])) # 0
```

### 알고리즘-3번문제

문제 설명
6자리 숫자로만 이루어진 배열 ar, arr2가 주어집니다. 이때, arr2의 각 숫자에 대해서 ar 에 딱 한자리만 다른 숫자가 몇 개씩 담겨있는지 알아보려 합니다.
다음은

- ar= [123457, 123458, 623456, 123436, 123456, 223344, 113344]
- arr2 = [123456, 123344, 223455]
  인 경우의 예시입니다.
- arr2의 첫 번째 숫자 : 123456
  - arr에서 123456과 딱 한 자리만 다른 숫자 : 123457, 123458, 623456, 123436
  - 단, arr1의 123456은 딱 한 자리만 다른 숫자가 아닙니다.
- arr2의 두 번째 숫자 : 123344
  - arr1에서 123344와 딱 한 자리만 다른 숫자 : 223344, 113344
- arr2의 세 번째 숫자 : 223455
  - arr에서 223455와 딱 한 자리만 다른 숫자 : 없습니다.

따라서 순서대로 [4, 2, 0]을 정답 배열에 담아 return 하면 됩니다.
6자리 숫자로만 이루어진 배열 arr1 , arr2 가 매개변수로 주어질 때, arr2 의 각 숫자에 대해서 arr1 에 딱 한자리만 다른 숫자가 몇 개씩 담겨있는지 순서대로 배열에 담아 return 하도록 solution 함수를 완성해주세요.

**답안**

- 처음에는 두 수를 서로 뺀 후 절대값의 자릿수를 구해, (해당 자릿수-1)을 10으로 제곱한 값으로, 차의 절대값을 나누면 나머지가 없다는 접근으로 보았다. 그런데 이 경우 1231-1229=2 여서 두자리가 다르지만 위 경우가 통해서 일의자리인 경우 일의자리와 십의자리를 다시 비교해야한다. (1320-1290도 이 경우) 그렇게 하니까 속도가 안나왔다.
- 하나하나 비교하기로했다
- 성능에서 탈락했는데 diff_cnt가 1초과면 반복 중지를 넣었으면 개선되었을것같다

```python
def solution(arr1, arr2):
    answer = []

    # 비교 숫자 확인
    for a2 in arr2:
        cnt = 0 # 하나의 숫자만 다른 경우
        # 비교 대상 숫자 확인
        for a1 in arr1:
            # 완전히 일치하면 제외
            if a1 == a2:
                continue

            diff_cnt = 0
            # a1과 a2를 비교해서 자릿수가 다른 횟수 구하기
            for a1_num, a2_num in zip(str(a1), str(a2)):
                # 자리수에 수가 다르면 diff_cnt 추가
                if a1_num != a2_num:
                    diff_cnt += 1
                # 만약 1초과면 그만 보기
                if diff_cnt > 1:
                    break

            cnt += 1 if diff_cnt == 1 else 0

        # a2가 하나의 숫자만 다른 횟수 추가
        answer.append(cnt)

    return answer




print(solution([123457, 123458, 623456, 123436, 123456, 223344, 113344], [123456, 123344, 223455])) # [4, 2, 0]
```

### SQL

문제 설명

CART_PRODUCTS 테이블은 장바구니에 담긴 상품 정보를 담은 테이블입니다.

CART_PRODUCTS 테이블의 구조는 다음과 같으며, ID, CART_ID , NAME , PRICE는 각각 테이블의 아이디, 장바구니의 아이디, 상품 종류, 가격을 나타냅니다.

| NAME    | TYPE    |
| ------- | ------- |
| ID      | INT     |
| CART_ID | INT     |
| NAME    | VARCHAR |
| PRICE   | INT     |

문제

지금 이 쇼핑몰에는 수량을 지정하는 기능이 없어, 같은 상품을 n개 사면 CART_PRODUCTS 테이블에 레코드가 n개 등록됩니다. 쇼핑몰 개발팀은 CART_PRODUCTS 테이블에 QUANTITY 컬럼을 추가해 수량을 지정하는 기능을 새로 만들려 합니다. 이 컬럼이 추가되면 같은 장바구니에서 같은 상품을 n개 살 때 QUANTITY가 n인 레코드를 하나만 등록하면 됩니 다.

기능 적용 후 CART_PRODUCTS 테이블이 어떻게 바뀔지 시뮬레이션해보려 합니다. 기능 적 용 후 장바구니의 아이디, 상품 종류, 상품 수량을 조회하는 SOL 문을 작성해주세요. SQL 문 을 실행하면 장바구니의 아이디가 작은 레코드가 먼저, 장바구니 아이디가 같은 레코드 중에 서는 상품 종류가 사전 순으로 먼저 나오는 레코드가 먼저 보여야 합니다.

예시

예를 들어 CART_PRODUCTS 테이블이 다음과 같다면

| ID   | CART_ID | NAME      | PRICE |
| ---- | ------- | --------- | ----- |
| 3728 | 195     | Ketchup   | 1380  |
| 3729 | 195     | Pasta     | 1980  |
| 5687 | 301     | Ice Cream | 3980  |
| 5696 | 301     | Coffee    | 24800 |
| 5697 | 301     | Coffee    | 24800 |
| 5737 | 304     | Coffee    | 24800 |

SQL 문을 실행하면 다음과 같이 나와야 합니다.

| CART_ID | NAME QUANTITY | QUANTITY |
| ------- | ------------- | -------- |
| 195     | Ketchup       | 1        |
| 195     | Pasta         | 1        |

**답안**

- `GROUP BY`를 통해 상품(`NAME`)과 카트(`CART_ID`)단위로 묶습니다.
- `ORDER BY`를 통해 장바구니ID와 이름순 오름차순으로 정렬합니다.
- `CART_ID`, `NAME`를 조회하고, 그룹 단위로 묶인 카트+상품 단위의 수는 `QUANTITY`로 표시합니다.

```sql
SELECT CART_ID, NAME, COUNT(*) as QUANTITY
FROM CART_PRODUCTS
GROUP BY NAME, CART_ID
ORDER BY CART_ID, NAME
```

### 업무흐름-1번문제

#### 문제

위 그림에서 사용자의 접속이 많아져 Database (D 부분) 에 부하가 몰릴 경우 서비스를 안정적으로 운영하기 위해 할 수 있는 가능한 조치를 간단히 서술하시오.

#### 답안

우선 **Redis**와 같은 메모리 캐시를 활용할 수 있습니다. 자주 요청되는 데이터를 DB에 직접 다녀오는 대신 캐시에 저장해두면 부하를 낮출 수 있습니다.

그 뒤는 기존 복잡하고 비효율적인 DB 쿼리가 있다면, **쿼리튜닝**을 진행하거나, **인덱스를 추가**하는 방법이 있습니다. 자주 사용하는 컬럼에 대해 인덱스를 추가하면, 검색, 종인 성능을 높일 수 있습니다.

혹은 **분산DB(레플리카 DB)** 를 적용해볼 수 있습니다. 리플리케이션 구조를 적용하여, 마스터 DB에서는 INSERT/UPDATE와 같은 요청을 처리하고, 슬레이브 DB에서는 SELECT 요청만 처리하는 방식입니다.

여러 방법을 도입해도 부족한 경우에는 DB 서버의 스펙을 높이는 방법도 있습니다. CPU, 메모리, 스토리지 IO의 성능 증설하면 이를 해결할 수 있습니다.

- [CQRS 공부](https://papooo-dev.github.io/posts/CQRS-%ED%8C%A8%ED%84%B4/)

- 레디스 공부

### 업무흐름-2번

#### 문제

위 그림에서 사용자 (A 부분) 가 입력한 민감 개인정보 데이터가 B,C 를 거쳐 Database (D 부분) 에 최종 저장된다고 할 때, 데이터를 안전하게 전송하고 저장할 수 있도록 가 능한 보안조치에 대해서 서술하시오.

#### 답안

- 웹 브라우저에서 웹 서버로 데이터를 전송할 때, **HTTPS 프로토콜**을 통해 전송합니다. 이를 통해 전송 계층에서 데이터를 암호화합니다.
  - HTTPS는 데이터를 전송할 때 **SSL/TLS 암호화를 적용** 합니다. 중간에 데이터가 가로채여도 내용을 알 수 없습니다.
  - **SSL(보안 소켓 계층, Secure Sockets Layer)** 와 **TLS(전송 계층 보안, Transport Layer Security)** 는 인터넷에서 데이터를 안전하게 전송하기 위해 사용되는 암호화 프로토콜 - SSL/TLS 인증서 있음
- 웹서버에서 데이터를 다룰 때도 플레인텍스트가 아닌 **암호화시킨 정보**를 통해 데이터를 주고 받습니다. (AES, RSA와 같은 강력한 암호화 알고리즘 저장) 필요한 경우 민감데이터를 사용하는 곳에서만 복호화를 하여 사용합니다.
- 이때 복호화된 정보 또한 클라이언트에 플레인텍스트로 바로 주지 않고, 클라이언트에서 복호화를 진행합니다.
  - RSA: 공개키 암호화(공개키로 암호화, 개인키로 복호화, 안전 but 느림) / AES: 대칭키 암호화(암복호화 동일키, 처리 빠름-대용량, 유출위험)
  - HTTPS에서는 RSA로 안전하게 AES 키를 공유한 뒤, AES를 사용해 데이터 전송을 암호화
- 또한 Database에 넣을 때 **해싱 알고리즘 등을 통해 암호화해서 저장**합니다
  - 비밀번호나 인증정보는 일회성 확인정보로 복호화가 필요 없기에 해싱 알고리즘 사용-원본 데이터 불가능, 데이터 유출 시에도 안전
  - 이름,주소와 같이 복호화가 필요한 경우 AES와 같은 대칭키 암호화로 암호화 - KMS에서 대칭키를 안전하게 관리

### 업무흐름-3번

#### 문제:

위 그림의 web application server (C 부분)에 새로운 버전의 application 을 배포 할 경우 취할 수 있는 전략에 나열하고 각 전략의 장단점을 비교하시오.

#### 답안

- **롤링 업데이트 방식**이 있습니다. 두 서버 중 하나의 서버에 신 버전 배포를 진행하고, 배포가 완료되면 나머지 하나에도 같은 방식으로 업데이트하는 방식입니다. 즉, 점진적으로 업데이트를 진행하는 것입니다.
- 다음은 **블루-그린 배포**입니다. 하나의 서버에만 업그레이드 버전을 배포하고, 나머지 서버는 구 버전으로 유지합니다. 업그레이드 버전이 배포된 서버에서 충분한 테스트를 진행한 후 로드밸런서 스위칭을 통해 업그레이드 버전을 사용자 사용 버전으로 적용합니다.
- 롤링 업데이트 방식의 장점 은 배포가 간단하고, 중단을 최소화할 수 있습니다. 다만 업데이트 작업 중에는 구버전과 신버전을 동시에 운영해야 하기에 데이터 호환 준비를 철저하게 해야합니다. 또한 블루-그린 배포에 비해 상대적으로 업데이터버전에 대한 테스트 기간과 환경이 짧아 검증이 충분하지 않을 수 있습니다.
- 블루-그린 배포의 방점은 새로 업데이트 된 버전에 대해 충분한 테스트 절차를 거치게 되어 업데이트에 대한 안정성을 가질 수 있습니다. 또한 신버전과 구버전이 독립된 환경에서 존재하기 때문에, 호환성에 대한 문제를 고려하지 않아도 됩니다. 검증 후에는 로드밸런서를 통해 빠르게 스위칭이 가능합니다. 다만 인프라 비용이 추가적으로 더 들고, 구버전, 신버전 환경을 동시에 유지/운영하기 때문에 빌드/배포 스크립트가 복잡해질 수 있습니다.

- 그 외 방식도 공부하기

## 기술 질문

### 좋은 REST API 설계를 위한 전략

### 대규모 트래픽 프로그램 시 도입하고 싶은 것

- 유튜브 저장영상 참고

### mysql 성능 최적화 방법? - 인덱싱?

### java17의 장점

### webflux의 장점

### langchain 강의 진행 방식과 성과

### docker, aws 적용 시 어려웠던 점과 극복 방법

### RAG 적용 상세 프로세스

### 사이드 프로젝트 경험

## 그 외 질문

### Q. 간단한 자기소개

A.안녕하세요, 저는 AI 어플리케이션 개발과 AI 트렌드 공부를 좋아하는 정예울입니다.

- 6-7년 전 처음 AI를 접할 때는 모델 개발 중심 - 문턱이 높았다
- 지난 몇 년간 생성형 AI 서능 크게 향상 -> 누구나 api를 통해 상용 LLM을 통한 AI 어플리케이션을 구축할 수 있는 세상!
- Langchain, 에이전트, 멀티 에어전트, AI 트렌트를 공부하며 미래에는 많은 것이 AI로 대체될 거라는 확신
- 본격적 공부 -> 사내에서 Langchain 강의 진행 - 지식공유&AI 제품 개발 기여
- 두 개의 AI 어플리케이션 개발 경험 - LLM 어플리케이션 개발 시, 아키텍쳐, 프롬프트 관리, 응답 퀄리티 일관되고 높게 유지하는 방법 등에 대한 경험
- 그 전에는 spring 기반의 java 개발. - db 모델링, 프론트, 백엔드, cicd 구축, 서버작업, 기술문서 작업까지 모두 경험
- 현재 팀에서는 javadoc을 docusaurus markdown으로 파싱해주는 api 명세서 자동화 생성 프로세스 구축 작업 중
- 개인적 소개: 취미로 수영좋아하구, 영화나 책을 보는 것도 좋아해요

### Q. 회사에 왜 지원했어요?

A.

### Q. 왜 이직하려고 하세요?

A. 작년동안은 회사에서 AI 사업에 투자를 하며, 진행을 하였는데, 회사 사정으로인해 더 이상 AI 사업를 진행하지 않게되었습니다.
저는 추후 AI 엔지니어로 커리어를 쌓고 싶어, AI 서비스 회사로의 이직을 준비하고 있습니다.

### Q. 개발자 전향 이유?

### Q. 회사에 대해 아는 것 알려주세요.

A.

### Q. 직무와 나의 fit

A.

- 생성형 AI 어플리케이션 개발 경험이 있습니다. 이를 통해 prompt template 구축, RAG 등을 적용해보았습니다.
- 개발 전반의 과정을 경험하였습니다. 서비스 개발부터 aws 환경에 배포, docker를 활용한 cicd 파이프라인 구축 경험이 있어 백엔드를 개발하고 애플리케이션을 배포, 운영하는 데 문제 없습니다.
- 체계를 정립하고 프로세스를 만드는 일을 잘합니다. 현재도 api 명세서 작업을 진행하며, 이를 자동화하기 위해 javadoc 작성 표준과 api 명세서 형식을 정립하고, 자동화 프로세스를 구축하는 작업을 진행하고 있습니다.
- 학습능력이 빠르고, 이를 실무에 적용하는 능력이 좋습니다. 작년에 langchain과 pastAPI, flask를 처음 접했지만 이를 통한 어플리케이션을 개발을 진행했습니다. 또한 webflux에 대해서도 공부하며 어플리케이션 적용을 하였습니다.

### Q. 업스테이지에 해당 직군에서 근무하며 해보고 싶은 것

A.

### Q. AI에 대한 비전\*\*

코딩 자체는 LLM이 대체할 가능성이 높지만, 요구사항 분석과 효율적인 설계 능력은 여전히 인간의 역할로 중요할 것입니다. LLM의 잠재력을 최대한 활용하기 위해서는 정확한 설계를 기반으로 효과적인 프롬프트 작성 능력이 필수적이라고 생각합니다. 이를 위해 지속적으로 시스템 설계와 패턴에 대한 학습을 이어가고 있습니다.

또한, Agent 중심의 애플리케이션 개발이 주류가 될 것으로 보며, LLM의 독립적인 판단과 개선 능력을 활용한 Agent 기반 자동화가 미래의 핵심이 될 것이라 믿습니다. AI 기반 업무 자동화가 확산되면서 도메인 지식과 AI 활용 기술의 결합이 더욱 중요해질 것입니다. 이를 뒷받침하기 위해 커뮤니케이션 능력과 문서화 역량도 개발자의 핵심 역량으로 자리 잡을 것이라고 생각합니다.

궁극적으로, LLM 기술을 통해 효율적인 자동화와 정확한 설계를 실현하며, 다양한 비즈니스와 산업의 발전에 기여하는 것을 목표로 삼고 있습니다.

제가 앞으로 더 깊게 공부하고 싶은 분야는 RAG와 Agent입니다.

### Q: 어려운 문제를 해결했던 경험을 이야기해주세요.

**A**: "AI 기반 RAG 시스템에서 메모리 릭으로 인해 서버가 반복적으로 다운되는 문제를 해결한 경험이 있습니다. Python 프로파일링을 통해 원인을 분석하고 비동기 락을 적용하여 동시성을 제어했으며, 참조 해제 로직을 추가해 문제를 완전히 해결했습니다. 이 경험을 통해 복잡한 문제를 분석하고 해결하는 데 자신감을 얻게 되었습니다."

### Q: 생성 AI와 관련된 프로젝트 경험을 소개해주세요.

- **초기 문제점**: 필드별 LLM 호출로 인해 비용 과다와 속도 저하 발생.
- **해결 방안**: LLM으로 데이터 구조 분석 후 데이터 생성이 가능한 Python 코드를 생성, 초기 1회 LLM 호출 뒤 이후 LLM 호출 없이 데이터를 무한 확장 가능하도록 설계. faker 모듈을 활용해 실제와 유사한 고품질 데이터 생성.
- **성과**: 1,000,000건의 mock 데이터를 72.38초 만에 생성, 데이터 생성 비용과 속도를 획기적으로 최적화.

### Q. 3-5년 후 어떤 개발자?

**생성 AI 및 시스템 설계 전문가**

- **목표**: 생성 AI 기술과 백엔드 시스템 설계에서 독보적인 전문성을 갖춘 개발자가 되는 것.
- **이유**: AI 기술이 빠르게 발전하면서, 효율적인 시스템 설계와 AI 응용 능력은 필수적인 역량이 되고 있습니다. 저는 AI 기술을 실질적인 비즈니스 솔루션으로 구현하고, 대규모 데이터를 효율적으로 처리할 수 있는 아키텍처를 설계할 수 있는 전문가로 성장하고 싶습니다.

**도메인 지식과 기술을 융합하는 개발자**

- **목표**: 마케팅에서의 깊은 이해를 바탕으로, 기술을 활용해 실질적인 가치를 창출하는 개발자가 되는 것.
- **이유**: 기술만으로는 사용자에게 충분한 가치를 전달할 수 없습니다. 도메인 지식을 기반으로 사용자 요구를 파악하고, 이를 해결하는 기술 솔루션을 제시하는 개발자가 되고 싶습니다.

### Q. Agent 도입에 대한 아이디어?
