채용공고: https://careers.upstage.ai/o/ai-solution-devoperation?lang=ko

# 기술면접 준비

### Q. 간단한 자기소개

- 안녕하세요, 저는 AI Software Engineer 정예울입니다.
- 저는 새로운 지식을 배우고 적용하고, 더 좋은 방법에 대해 고민해보는 것을 좋아합니다.
- 미래에는 많은 것이 AI로 대체될 거라는 확신으로 최근에는 Langchain, AI 트렌드에 관심을 두고 공부하고 있습니다.
- 이를 바탕으로 사내에서 Langchain 강의 진행
- 두 개의 AI 어플리케이션 개발 - ai 어플리케이션의 아키텍쳐, 프롬프트 관리, 응답 퀄리티 유지 등에 대해 깊이 있게 고민, 경험
- 이전에는 spring 기반의 java 개발- db 모델링, 프론트, 백엔드 개발, cicd 구축 등 다양한 업무를 경험을 쌓았음
- 현재 AI 분야 가장 뛰어난 성장력을 가진 upstage에서 저의 AI software engineer로서의 커리어를 함께 성장하며 쌓아나가고 싶습니다.
- 개인적 소개: 취미로 수영좋아하구, 영화나 책을 보는 것도 좋아해요

### Q. 회사에 왜 지원했어요?

- Upstage는 **국내 최고의 LLM인 solar pro와 solar mini 모델**을 가지고 있다.
- llm 어플리케이션을 개발하며 느낀 것-중요한 건 **자체 모델**을 갖고 있는 것 - 매우 비전이 있다고 생각!
- 상용 llm은 문제1)토큰 비용, 문제2)의존적-모델바뀌거나, 고장나면 서비스 끝!
- **document parse**를 통해 기업에서의 document 기반의 rag, qa 서비스에서 더 많은 정보를 획득하고, 정확도를 높일 수 있을 것.
- 앞으로 대중적으로 AI의 큰 패러다임은 업무자동화라고 생각 - upstage의 solar 모델과 document parse를 통해 기업 기반의 업무 자동화 서비스 개발에 큰 도움이 되어 미래에 더 큰 가치를 발휘할 것이라 기대

### Q. 현재 팀에서 하는 일

현재 팀에서는 javadoc을 docusaurus markdown으로 파싱해주는 api 명세서 자동화 생성 프로세스 구축 작업 중

## 기술 질문

### 좋은 REST API 설계를 위한 전략

**REST API 원칙을 잘 지키는 것**

1. **일관된 인터페이스로 설계하는 것**

- **리소스 식별**
  - 하나의 리소스에 대해서는 동일한 단어를 사용(되도록 복수형으로)
  - 동사가 아닌 명사 사용
- **계층 구조 사용**
  - 부모-자식 관계 반영한 URI 설계
  - ex) gitlab의 project issue 조회 시 `GET projects/123/issues/2`
- **리소스 표현(HTTP method)으로 조작**
  - DELETE users/123 이면 123 유저 삭제, GET users/123 이면 123 유저 정보 조회

2. **무상태성**

- 서버는 클라이언트 상태 저장X (다른 요청은 관심X, 요청은 서로 독립적)
- 모든 요청을 필요한 정보 포함(응답형식 등) - 완전한 요청
- 자가 설명 메시지: 클라이언트의 요청과 서버의 응답은 별도 매뉴얼 없이도 필요한 정보를 해석할 수 있는 모든 정보 포함

**명확한 응답 구조**

- 데이터와 메타데이터를 포함하는 일관된 구조

```json
{
  "header" : {
    "staff_id" : "STAFF_ID",
    ..
  },
  "data": {
    "user_id": "USER_ID"
  }
}
```

- 에러 처리 시에도 명확하고 일관된 에러 응답 형식 사용

```json
{
  "error": {
    "code": 400,
    "message": "Invalid request",
    "details": "The 'email' field is required."
  }
}
```

- 클라이언트에게 필요한 필드만 반환
- 페이지, 필터링, 정렬 지원

**버저닝**

- API 변경 시 하위호환성 유지를 위해, 버저닝을 명시적으로 제공
  > _"하위 호환성을 유지한다"_
  >
  > = 기존 API를 사용하는 클라이언트가 새로운 변경 사항으로 인해 문제가 생기지 않도록 보호하는 것.
  >
- 예: `/api/v1/users` -> `api/v2/users`

**보안**

- HTTPS 사용: 모든 통신을 암호화하여 보안 위협을 줄입니다.
- 인증 및 권한 관리
  - OAuth 2.0, JWT(JSON Web Token) 등 표준 인증 방식을 사용합니다.

**에러처리**

- 명확하고 일관된 에러 응답 형식

### 대규모 트래픽 프로그램 시 도입하고 싶은 것

- [대규모 트래픽 시스템 아키텍쳐](https://papooo-dev.github.io/posts/big-traffic-overview/) 참고

### mysql 성능 최적화 방법?

- 쿼리튜닝
- 레디스와 같은 메모리 캐시 적용
- 조회 성능이 안나온다면 분산 DB(master-slave) 구조 적용
- 수평적확장-서버 수 증가-샤딩을 통한 분산
- 그래도 안나온다면 CQRS 패턴 도입도 고려해봄직

### java17의 장점

### webflux의 장점

### langchain 강의 진행 방식과 성과

### docker, aws 적용 시 어려웠던 점과 극복 방법

**도커 사용 시 어려움과 해결 경험**

과거 도커를 사용하여 인터페이스 거래 시뮬레이터 엔진을 실행했던 경험에서 몇 가지 어려움을 겪었습니다.

- **문제 상황**:
  도커 컨테이너에서 시뮬레이터 엔진을 실행한 후, 대상 기관의 포트를 설정하고 거래를 시도했으나 정상적으로 작동하지 않았습니다. 문제를 조사한 결과, 엔진을 띄운 서버에서 실제 엔진이 실행되는 위치는 도커 컨테이너 내부였지만, 서버와 도커 컨테이너 간 포트 연동이 제대로 설정되지 않았음을 발견했습니다.
- **해결 방법**:
  도커 Compose 설정 파일에서 가용 포트 범위를 명시적으로 설정하여 서버와 컨테이너 간 포트가 제대로 연결되도록 구성했습니다. 이를 통해 거래가 정상적으로 이루어질 수 있었습니다.
- **느낀 점**:
  도커 컨테이너 내부에서 애플리케이션이 실행된다는 개념이 처음에는 다소 헷갈렸습니다. 그러나 문제를 해결하며 도커 네트워킹과 컨테이너 구조에 대한 이해를 높일 수 있었고, 이후에는 유사한 상황에서도 빠르게 대처할 수 있었습니다.

### RAG 적용 상세 프로세스

### 사이드 프로젝트 경험

## 그 외 질문

### Q. 왜 이직하려고 하세요?

A. 작년동안은 회사에서 AI 사업에 투자를 하며, 진행을 하였는데, 회사 사정으로인해 더 이상 AI 사업를 진행하지 않게되었습니다.
저는 추후 AI 엔지니어로 커리어를 쌓고 싶어, AI 서비스 회사로의 이직을 준비하고 있습니다.

### Q. 개발자 전향 이유?

### Q. 회사에 대해 아는 것 알려주세요.

**[Upstage 제품]**

- **Solar Pro**
  - 기업의 특화된 데이터에 맞춘 커스터마이징이 가능
  - 고객 서비스 챗봇, 내부 문서 분석, 데이터 기반 의사결정 지원
- **Solar Mini**
  - Solar Pro의 경량화 버전으로, 특정 업무에 최적화된 성능을 제공
  - 비교적 가벼운 연산 자원을 사용하면서도 높은 정확도를 유지합니다.
- **Document Parse**
  - 문서 자동 처리 솔루션으로, 비정형 데이터를 구조화된 형식으로 변환합니다.
  - 이미지, 엑셀, pdf, pptx ..
  - OCR로 문서에서 텍스트 추출
  - 텍스트를 분류하고 필요한 정보를 구조화
  - 대량 문서를 빠르게 처리하고 효율성을 높임

**[Upstage 서비스]**

- **AI Customization Platform**
  - 기업의 데이터와 요구사항에 맞춘 **맞춤형 AI 모델 개발 플랫폼**.
  - AI를 비즈니스 환경에 통합하여 **프로세스를 자동화하거나 분석 역량을 강화**할 수 있습니다.
- **AI for CX (Customer Experience)**
  - 고객 경험을 개선하기 위한 AI 솔루션
    - 고객 문의를 자동으로 응답하는 챗봇.
    - 콜센터 상담 데이터를 분석하여 주요 문제를 도출.
    - 고객 이탈 방지 및 만족도 향상에 기여.
- **활용 사례**
  - LG전자: Solar Pro를 활용한 내부 업무 자동화 및 데이터 분석.
  - 한화생명: 보험 서류의 자동 분류 및 처리.
  - AWS 협력: 클라우드 환경에서의 AI 솔루션 최적화.

### Q. 직무와 나의 fit

- **생성형 AI 어플리케이션 개발 경험**이 있습니다. 이를 통해 prompt template 구축, RAG 등을 적용해보았습니다.
- **개발 전반의 과정을 경험**하였습니다. 서비스 개발부터 aws 환경에 배포, docker를 활용한 cicd 파이프라인 구축 경험이 있어 백엔드를 개발하고 애플리케이션을 배포, 운영하는 데 문제 없습니다.
- **체계를 정립하고 프로세스를 만드는 일**을 잘합니다. 현재도 api 명세서 작업을 진행하며, 이를 자동화하기 위해 javadoc 작성 표준과 api 명세서 형식을 정립하고, 자동화 프로세스를 구축하는 작업을 진행하고 있습니다.
- **학습능력이 빠르고, 이를 실무에 적용하는 능력**이 좋습니다. 작년에 langchain과 pastAPI, flask를 처음 접했지만 이를 통한 어플리케이션을 개발을 진행했습니다. 또한 webflux에 대해서도 공부하며 어플리케이션 적용을 하였습니다.

### Q. 업스테이지에 해당 직군에서 근무하며 해보고 싶은 것

팔란티어? 기업의 업무를 파악해 ai를 도입해 문제 해결 - 이를 위해서는 도메인 지식

비즈니스 문제 해결을 위해서는 LLM이라는 기술로 접근하는 것이 아니라, 기존에 문제를 해결해왔던 도메인 지식이 깊은 사람이 가장 필요합니다.
그 사람이 문제를 해결해왔던 방식처럼 워크 플로우를 구성하고, **중간중간 LLM이 "어떤 데이터"로, "어떤 방식(Tool)을 이용"할 지에 대해 체인을 구성하는 것이 AI 솔루션**인 것이죠.

### Q. 기업 대상 AI 서비스에 대한 의견

미국의 팔란티어의 어떤 분이 한 강의가 인상 깊었었다. 핵심은 기업에서 LLM을 활용하여 어떠한 솔루션을 만들 때, LLM을 통해 할 수 있는 일에 대한 정의보다, 해결해야 하는 일이 무엇인지에 대한 명확하고 단계적인 정의가 우선이 되어야 한다는 것이었다.
소비자 대상인 경우 AI의 답안이 틀려도 큰 리스크가 없지만, 기업은 다르다.
그 이유

1. 기업의 데이터는 통합되어 있지 않다. => document parser를 도입해볼 수 있다.
2. 기업의 특정 워크플로우나 용어에 대한 이해가 부족. => 기업 도메인 지식 특화하여 train 가능한 solar pro를 도입해본다.

초반에는 사용자 주도 방식으로, LLM의 결정 전 데이터 선택과 도구를 중간에 사람이 선택한다. 점진적으로 자동수행 방식으로 가며 자주 반복되는 업무에 대해 trigger point를 잡아 워크플로우를 체인으로 구성해둔다.

**성공적인 LLM 활용을 위한 조건**

- 문제 정의 우선: LLM으로 무엇을 할 수 있을지 정의하기 전에, 해결해야 할 문제를 명확히 정의하고 단계적으로 접근해야 합니다.
- 워크플로우 설계: 문제 해결의 흐름을 이해하고 각 단계에서 LLM의 역할을 구체적으로 지정해야 합니다.
- 도메인 전문가와 AI 전문가의 협업: 도메인 지식이 깊은 사람과 AI 솔루션을 잘 이해하는 사람이 협력하여 최적의 솔루션을 설계.
- UI/UX 최적화: 사용자 인터페이스를 설계하여 LLM의 도움을 효과적으로 받을 수 있는 환경 제공

기업에서 LLM을 활용하려면 단순히 AI를 도입하는 것을 목표로 삼는 것이 아니라, 명확한 비즈니스 문제를 해결하기 위한 도구로 접근해야 합니다. LLM은 문제 해결 속도를 높이는 보조 역할을 할 뿐, 모든 것을 자동으로 해결해 주는 만능 도구가 아닙니다. 목적 달성을 위해 각 단계에서 LLM의 역할을 지정하고, 도메인 전문가와 AI 전문가의 협업을 통해 최적의 워크플로우를 설계하는 것이 중요합니다. 무엇보다도 AI 솔루션이 반드시 필요한지에 대한 근본적인 질문을 던지는 것에서부터 시작해야 합니다.

### Q. AI에 대한 비전

코딩 자체는 LLM이 대체할 가능성이 높지만, 요구사항 분석과 효율적인 설계 능력은 여전히 인간의 역할로 중요할 것입니다. LLM의 잠재력을 최대한 활용하기 위해서는 정확한 설계를 기반으로 효과적인 프롬프트 작성 능력이 필수적이라고 생각합니다. 이를 위해 지속적으로 시스템 설계와 패턴에 대한 학습을 이어가고 있습니다.

또한, Agent 중심의 애플리케이션 개발이 주류가 될 것으로 보며, LLM의 독립적인 판단과 개선 능력을 활용한 Agent 기반 자동화가 미래의 핵심이 될 것이라 믿습니다. AI 기반 업무 자동화가 확산되면서 도메인 지식과 AI 활용 기술의 결합이 더욱 중요해질 것입니다. 이를 뒷받침하기 위해 커뮤니케이션 능력과 문서화 역량도 개발자의 핵심 역량으로 자리 잡을 것이라고 생각합니다.

궁극적으로, LLM 기술을 통해 효율적인 자동화와 정확한 설계를 실현하며, 다양한 비즈니스와 산업의 발전에 기여하는 것을 목표로 삼고 있습니다.

제가 앞으로 더 깊게 공부하고 싶은 분야는 RAG와 Agent입니다.

### Q: 어려운 문제를 해결했던 경험을 이야기해주세요.

1. AI 기반 RAG 시스템에서 메모리 릭으로 인해 서버가 반복적으로 다운되는 문제를 해결한 경험이 있습니다. Python 프로파일링을 통해 원인을 분석하고 비동기 락을 적용하여 동시성을 제어했으며, 참조 해제 로직을 추가해 문제를 완전히 해결했습니다. 이 경험을 통해 복잡한 문제를 분석하고 해결하는 데 자신감을 얻게 되었습니다.
2. Docusaurus 기반 document 앱과 Spring Boot 앱을 분리하고 GitLab 멀티 프로젝트 파이프라인과 artifact를 활용해 빌드 효율성을 극대화했음

- 기존에 docusaurus 기반의 document 어플리케이션을 springboot 어플리케이션 내부에 포함해 하나의 jar로 배포하기 위해, springboot 앱을 빌드하는 cicd에서 document 앱을 빌드하는 구조로 있었음
- 문제: springboot 어플리케이션 변경으로 인해 springboot jar 배포를 할 때, 늘 document 앱 빌드를 했는데, npm install & build가 시간 소요가 컸음
- 해결
  - document 앱 프로젝트를 분리 - document 프로젝트에서 npm install & build
  - build된 정적 리소스를 artifact에 보관
  - gitlab의 멀티 프로젝트 파이프라인을 통해 document 빌드 완료 후 springboot의 deploy job trigger
  - artifact에 있는 build 정적 리소스를 포함하여 springboot 어플리케이션 빌드하여 jar 생성
- 장점
  - springboot 배포 시, document 빌드로 인한 지연 문제 해결 (springboot 어플리케이션이 변경될때마다 document 빌드를 새로할 필요 X)
  - document 변경 시, 자동으로 springboot jar에 변경된 정적 리소스 반영하여 배포 가능

### Q: 생성 AI와 관련된 프로젝트 경험을 소개해주세요.

- **초기 문제점**: 필드별 LLM 호출로 인해 비용 과다와 속도 저하 발생.
- **해결 방안**: LLM으로 데이터 구조 분석 후 데이터 생성이 가능한 Python 코드를 생성, 초기 1회 LLM 호출 뒤 이후 LLM 호출 없이 데이터를 무한 확장 가능하도록 설계. faker 모듈을 활용해 실제와 유사한 고품질 데이터 생성.
- **성과**: 1,000,000건의 mock 데이터를 72.38초 만에 생성, 데이터 생성 비용과 속도를 획기적으로 최적화.

### Q. 3-5년 후 어떤 개발자?

**생성 AI 및 시스템 설계 전문가**

- **목표**: 생성 AI 기술과 백엔드 시스템 설계에서 독보적인 전문성을 갖춘 개발자가 되는 것.
- **이유**: AI 기술이 빠르게 발전하면서, 효율적인 시스템 설계와 AI 응용 능력은 필수적인 역량이 되고 있습니다. 저는 AI 기술을 실질적인 비즈니스 솔루션으로 구현하고, 대규모 데이터를 효율적으로 처리할 수 있는 아키텍처를 설계할 수 있는 전문가로 성장하고 싶습니다.

**도메인 지식과 기술을 융합하는 개발자**

- **목표**: 마케팅에서의 깊은 이해를 바탕으로, 기술을 활용해 실질적인 가치를 창출하는 개발자가 되는 것.
- **이유**: 기술만으로는 사용자에게 충분한 가치를 전달할 수 없습니다. 도메인 지식을 기반으로 사용자 요구를 파악하고, 이를 해결하는 기술 솔루션을 제시하는 개발자가 되고 싶습니다.

### Q. 주변에서 나를 어떻게 평가?

- **체계적이고 협업에 강한 사람**

  - 매 회의마다 회의록 작성, action task 정리해서 이슈티켓으로 뽑아 회의록과 함께 공유
  - 아키텍쳐, 시스템 같은 말로 정리하기 어렵고 쉽게 까먹는 사항은 다이어그램이나 그림으로 정리해 쉽게 이해할 수 있게 하고, 위키에 정리해서 정보의 지속 가능성을 높이는 것을 선호
  - 배운 지식, 경험한 문제 해결 과정 공유에 적극적, 올해만 회사 포럼에 51개 글을 작성(트러블슈팅, ai트렌드, 개발 아키텍쳐 등..)
- **적극적인 사람**

  - 사람을 좋아해서, 별로 안친해도 말도 잘 걸고 분위기를 편하게 함
  - 업무적으로 필요한 부분에 대해 적극적으로 개선 방안에 대해 제안하고, 작업하는 것을 즐김

## 코테 알고리즘

### 알고리즘-1번문제

**문제 설명**

알파벳 대문자와 소문자로 이루어진 문자열 line이 주어집니다. 이 line을 다음 주어진 규칙에 따라 압축한 뒤 return 하도록 solution 함수를 완성해주세요.

1. 대문자 1개와 그 뒤로 이어지는 모든 연속한 소문자들을 하나의 단어로 생각합니다.
   • 예를 들어 "AdminOfWebsite" 에서 "Admin", "Of", "Website"는 각각 단어입 니다.
2. 문장에서 어떤 단어에 포함되지 않으면서 연속해서 이어진 대문자들 또한 하나의 단어 로 생각합니다.
   • 예를 들어 "EUVersusUAE" 에서 단어 "Versus"를 제외한 부분인 "EU",
   "UAE"가 각각 단어가 됩니다.
3. 문자열을 압축을 할 때, 해당 문자열의 모든 단어들의 맨 앞글자만 남겨두는 방식으로 압축을 진행합니다.
   제한사항

- line의 길이는 1 이상 1,000 이하입니다.
- line의 첫 글자는 항상 대문자입니다.

**답안**

- keypoint
  - 연속된 대문자 뒤 소문자가 오는 경우, 소문자 바로 앞 대문자 저장
  - 소문자 바로 뒤 대문자 저장

```python
def solution(word):
    answer = ""
    char = ""
    isPrevLower = True

    for w in word:
        if w.isupper():
            char = w
            if isPrevLower:
                answer += char
                char = ""
                isPrevLower = False
        else:
            answer += char
            char = ""
            isPrevLower = True
    return answer


print(solution("AdminOfWebsite")) # AOW
print(solution("EUVersusUAE")) # EVU
print(solution("ABCdeFhHQq")) # ACFHQ
```

### 알고리즘-2번문제

**문제 설명**

창고에 재고로 쌓여 있는 상품들을 재포장하려고 합니다. 재포장을 완료하기 위해 추가로 구매해야 하는 상품이 몇 개인지 구하고자 합니다.
창고에는 상품이 2개씩 들어있는 상자가 쌓여있습니다. 한 상자 안에 들어있는 2개의 상품이 같은 종류인 경우도 있고 아닌 경우도 있습니다. 1+1 행사를 위해 모든 상자 안에 같은 종류의 상품을 2개씩 넣고 포장하려고 합니다. 일단, 상품의 짝이 맞지 않는 상자끼리 서로 필요한 물 건을 교환해서 최대한 많은 짝을 맞춰 재포장합니다. 그렇게 했음에도 짝을 맞추기에 수량이 부족한 상품은 추가 구매합니다. 단, 상자는 원래 창고에 쌓여있던 개수만큼 사용할 수 있으며, 추가로 더 가져오거나 구입하지 못합니다.
아래 예시는 재포장을 진행하기 전, 각 상자에 들어있는 상품들의 종류를 나타냅니다.
상자 번호

1 번 상자: 1, 2
2 번 상자: 2, 1
3 번 상자: 3, 3
4 번 상자: 4, 5
5 번 상자: 5, 6
6 번 상자: 7, 8

1번 상자에서는 2번 상품을, 2번 상자에서는 1번 상품을 서로 교환하면 두 상자의 짝 맞추기가 해결됩니다. 3번 상자는 이미 짝이 맞추어져 있기 때문에 다른 상자와 교환할 필요가 없습니 다. 4번 상자는 4번 상품을 5번 상자에 들어있는 5번 상품과 교환하면 짝을 맞출 수 있습니다.
5번과 6번 상자는 남아 있는 상품들로 짝을 맞출 수 없기 때문에 상품의 추가 구매가 필요합니 다. 이때, 2개의 상품만 구매하면 짝을 맞출 수 있습니다. 예를 들어, 4번과 6번 상품을 구매하 면 각각 짝을 만들 수 있습니다.
각 상자에 들어있는 상품의 종류를 나타내는 2차원 배열 boxes가 매개변수로 주어집니다.

1번 상자에서는 2번 상품을, 2번 상자에서는 1번 상품을 서로 교환하면 두 상자의 짝 맞추기가 해결됩니다. 3번 상자는 이미 짝이 맞추어져 있기 때문에 다른 상자와 교환할 필요가 없습니 다. 4번 상자는 4번 상품을 5번 상자에 들어있는 5번 상품과 교환하면 짝을 맞출 수 있습니다.
5번과 6번 상자는 남아 있는 상품들로 짝을 맞출 수 없기 때문에 상품의 추가 구매가 필요합니 다. 이때, 2개의 상품만 구매하면 짝을 맞출 수 있습니다. 예를 들어, 4번과 6번 상품을 구매하 면 각각 짝을 만들 수 있습니다.
각 상자에 들어있는 상품의 종류를 나타내는 2차원 배열 boxes가 매개변수로 주어집니다. 상 품의 짝을 맞춰 재포장을 완료하기 위해 추가로 구매해야 하는 상품의 최소 개수를 return 하 도록 solution 함수를 작성해주세요.
~
~
제한사항

- boxes의 길이(=창고에 재고로 쌓인 상자 개수)는 1 이상 100,000 이하입니다.
- boxes의 원소는 2개의 상품이 들어있는 상자를 나타냅니다.
- boxes의 원소는 [a, b] 형태의 배열입니다.
- a 와 b는 상자 안에 들어있는 상품의 종류를 나타냅니다.
- a 와 b는 1이상 1,000,000 이하인 자연수입니다.
- 모든 상품 종류에 대해 추가 구매 가능한 수량은 무한합니다.
  입출력 예
  boxes result
  [[7, 2], [2, 1], [3, 3], [4, 5], [5, 6], [7, 8]] 2
  [[7, 2], [3, 4], [5, 6]] 3
  [[7, 2], [2, 3], [3, 11]] 0

**답안**

- key point
  - 같은 상품이 두개인 경우 set에서 제외하고, 사용가능한 박스 수를 줄인다.
  - 리스트가 아닌 set을 사용한 이유? 중복 제거 및 빠른 탐색에 set이 적합-내부적으로 해시테이블로 구현-O(1)시간 복잡도-list는 O(n)의 시간복잡도(위치기억)
  - 남은 박스 수와 추가구매 상품 중 작은 숫자를 리턴한다

```python
def solution(boxes):
    # 포장 가능한 박스 수
    available_box_cnt = len(boxes)
    # 추가 주문 필요 상품
    result = set()

    # 박스 확인
    for box in boxes:
        # 박스 속 각 상품 확인
        for b in box:
            # 상품이 추가 주문 필요 상품에 있는 경우
            if b in result:
                #  짝이 맞으므로 추가주문에서 제거
                result.remove(b)
                # 박스에 넣는다
                available_box_cnt -=1
            # 없는 경우
            else:
                # 추가 주문으로 넣기
                result.add(b)

    # 포장 가능한 박스 남은 수보다 추가 주문 상품이 큰 경우
    if available_box_cnt < len(result):
        # 가능한 만큼만 추가주문한다
        return available_box_cnt
    else:
        return len(result)

print(solution([[1, 2], [2, 1], [3, 3], [4, 5], [5, 6], [7, 8]])) # 2
print(solution([[1, 2], [3, 4], [5, 6]])) # 3
print(solution([[1, 2], [2, 3], [3, 1]])) # 0
```

### 알고리즘-3번문제

문제 설명
6자리 숫자로만 이루어진 배열 ar, arr2가 주어집니다. 이때, arr2의 각 숫자에 대해서 ar 에 딱 한자리만 다른 숫자가 몇 개씩 담겨있는지 알아보려 합니다.
다음은

- ar= [123457, 123458, 623456, 123436, 123456, 223344, 113344]
- arr2 = [123456, 123344, 223455]
  인 경우의 예시입니다.
- arr2의 첫 번째 숫자 : 123456
  - arr에서 123456과 딱 한 자리만 다른 숫자 : 123457, 123458, 623456, 123436
  - 단, arr1의 123456은 딱 한 자리만 다른 숫자가 아닙니다.
- arr2의 두 번째 숫자 : 123344
  - arr1에서 123344와 딱 한 자리만 다른 숫자 : 223344, 113344
- arr2의 세 번째 숫자 : 223455
  - arr에서 223455와 딱 한 자리만 다른 숫자 : 없습니다.

따라서 순서대로 [4, 2, 0]을 정답 배열에 담아 return 하면 됩니다.
6자리 숫자로만 이루어진 배열 arr1 , arr2 가 매개변수로 주어질 때, arr2 의 각 숫자에 대해서 arr1 에 딱 한자리만 다른 숫자가 몇 개씩 담겨있는지 순서대로 배열에 담아 return 하도록 solution 함수를 완성해주세요.

**답안**

- 처음에는 두 수를 서로 뺀 후 절대값의 자릿수를 구해, (해당 자릿수-1)을 10으로 제곱한 값으로, 차의 절대값을 나누면 나머지가 없다는 접근으로 보았다. 그런데 이 경우 1231-1229=2 여서 두자리가 다르지만 위 경우가 통해서 일의자리인 경우 일의자리와 십의자리를 다시 비교해야한다. (1320-1290도 이 경우) 그렇게 하니까 속도가 안나왔다.
- 하나하나 비교하기로했다
- 성능에서 탈락했는데 diff_cnt가 1초과면 반복 중지를 넣었으면 개선되었을것같다

```python
def solution(arr1, arr2):
    answer = []

    # 비교 숫자 확인
    for a2 in arr2:
        cnt = 0 # 하나의 숫자만 다른 경우
        # 비교 대상 숫자 확인
        for a1 in arr1:
            # 완전히 일치하면 제외
            if a1 == a2:
                continue

            diff_cnt = 0
            # a1과 a2를 비교해서 자릿수가 다른 횟수 구하기
            for a1_num, a2_num in zip(str(a1), str(a2)):
                # 자리수에 수가 다르면 diff_cnt 추가
                if a1_num != a2_num:
                    diff_cnt += 1
                # 만약 1초과면 그만 보기
                if diff_cnt > 1:
                    break

            cnt += 1 if diff_cnt == 1 else 0

        # a2가 하나의 숫자만 다른 횟수 추가
        answer.append(cnt)

    return answer




print(solution([123457, 123458, 623456, 123436, 123456, 223344, 113344], [123456, 123344, 223455])) # [4, 2, 0]
```

### SQL

문제 설명

CART_PRODUCTS 테이블은 장바구니에 담긴 상품 정보를 담은 테이블입니다.

CART_PRODUCTS 테이블의 구조는 다음과 같으며, ID, CART_ID , NAME , PRICE는 각각 테이블의 아이디, 장바구니의 아이디, 상품 종류, 가격을 나타냅니다.

| NAME    | TYPE    |
| ------- | ------- |
| ID      | INT     |
| CART_ID | INT     |
| NAME    | VARCHAR |
| PRICE   | INT     |

문제

지금 이 쇼핑몰에는 수량을 지정하는 기능이 없어, 같은 상품을 n개 사면 CART_PRODUCTS 테이블에 레코드가 n개 등록됩니다. 쇼핑몰 개발팀은 CART_PRODUCTS 테이블에 QUANTITY 컬럼을 추가해 수량을 지정하는 기능을 새로 만들려 합니다. 이 컬럼이 추가되면 같은 장바구니에서 같은 상품을 n개 살 때 QUANTITY가 n인 레코드를 하나만 등록하면 됩니 다.

기능 적용 후 CART_PRODUCTS 테이블이 어떻게 바뀔지 시뮬레이션해보려 합니다. 기능 적 용 후 장바구니의 아이디, 상품 종류, 상품 수량을 조회하는 SOL 문을 작성해주세요. SQL 문 을 실행하면 장바구니의 아이디가 작은 레코드가 먼저, 장바구니 아이디가 같은 레코드 중에 서는 상품 종류가 사전 순으로 먼저 나오는 레코드가 먼저 보여야 합니다.

예시

예를 들어 CART_PRODUCTS 테이블이 다음과 같다면

| ID   | CART_ID | NAME      | PRICE |
| ---- | ------- | --------- | ----- |
| 3728 | 195     | Ketchup   | 1380  |
| 3729 | 195     | Pasta     | 1980  |
| 5687 | 301     | Ice Cream | 3980  |
| 5696 | 301     | Coffee    | 24800 |
| 5697 | 301     | Coffee    | 24800 |
| 5737 | 304     | Coffee    | 24800 |

SQL 문을 실행하면 다음과 같이 나와야 합니다.

| CART_ID | NAME QUANTITY | QUANTITY |
| ------- | ------------- | -------- |
| 195     | Ketchup       | 1        |
| 195     | Pasta         | 1        |

**답안**

- `GROUP BY`를 통해 상품(`NAME`)과 카트(`CART_ID`)단위로 묶습니다.
- `ORDER BY`를 통해 장바구니ID와 이름순 오름차순으로 정렬합니다.
- `CART_ID`, `NAME`를 조회하고, 그룹 단위로 묶인 카트+상품 단위의 수는 `QUANTITY`로 표시합니다.

```sql
SELECT CART_ID, NAME, COUNT(*) as QUANTITY
FROM CART_PRODUCTS
GROUP BY NAME, CART_ID
ORDER BY CART_ID, NAME
```

### 업무흐름-1번문제

####문제
위 그림에서 사용자의 접속이 많아져 Database (D 부분) 에 부하가 몰릴 경우 서비스를 안정적으로 운영하기 위해 할 수 있는 가능한 조치를 간단히 서술하시오.

#### 답안

우선 **Redis**와 같은 메모리 캐시를 활용할 수 있습니다. 자주 요청되는 데이터를 DB에 직접 다녀오는 대신 캐시에 저장해두면 부하를 낮출 수 있습니다. 그 뒤는 기 기존 복잡하고 비효율적인 DB 쿼리가 있다면, **쿼리튜닝**을 진행하거나, **인덱스를 추가**하는 방법이 있습니다. 자주 사용하는 컬럼에 대해 인덱스를 추가하면, 검색, 종인 성능을 높일 수 있습니다. 혹은 **분산DB(레플리카 DB)**를 적용해볼 수 있습니다. 리플리케이션 구조를 적용하여, 마스터 DB에서는 INSERT/UPDATE와 같은 요청을 처리하고, 슬레이브 DB에서는 SELECT 요청만 처리하는 방식입니다. 여러 방법을 도입해도 부족한 경우에는 DB 서버의 스펙을 높이는 방법도 있습니다. CPU, 메모 리, 스토리지 IO의 성능 증설하면 이를 해결할 수 있습니다.

- CQRS 공부

### 업무흐름-2번

#### 문제

위 그림에서 사용자 (A 부분) 가 입력한 민감 개인정보 데이터가 B,C 를 거쳐 Database (D 부분) 에 최종 저장된다고 할 때, 데이터를 안전하게 전송하고 저장할 수 있도록 가 능한 보안조치에 대해서 서술하시오.

#### 답안

웹 브라우저에서 웹 서버로 데이터를 전송할 때, **HTTPS 프로토콜**을 통해 전송합니다. 이를 통해 전송 계층에서 데이터를 암호화합니다. 웹서버에서 데이터를 다룰 때도 플레인텍스트가 아닌 **암호화시킨 정보**를 통해 데이터를 주고 받습니다. 민감데이터를 사용하는 곳에서는 복호화를 하여 사용합니다. 이때 복호화된 정보또한 클라이언트에 플레인텍스트로 바로 주지 않고, 클라이언트에서 복호화를 진행합니다. 또한 Database에 넣을 때 **해싱 알고리즘 등을 통해 암호화해서 저장**합니다.

### 업무흐름-3번

#### 문제:

위 그림의 web application server (C 부분)에 새로운 버전의 application 을 배포 할 경우 취할 수 있는 전략에 나열하고 각 전략의 장단점을 비교하시오.

#### 답안

**롤링 업데이트 방식**이 있습니다. 두 서버 중 하나의 서버에 신 버전 배포를 진행하고, 배포가 완료되면 나머지 하나에도 같은 방식으로 업데이트하는 방식입니다. 즉, 점진적으로 업데이트를 진행하는 것입니다. 다음은 블루-그린 배포입니다. 하나의 서버에만 업그레이드 버전을 배포하고, 나머지 서버는 구 버전으로 유지합니다• 업그 레이드 버전이 배포된 서버에서 충분한 테스트를 진행한 후 로드밸런서 스위칭을 통해 업그레이드 버전을 사용자 사용 버전으로 적용합니다. 롤링 업데이트 방식의 장점 은 배포가 간단하고, 중단을 최소화할 수 있습니다. 다만 업데이트 작업 중에는 구버전과 신버전을 동시에 운영해야 하기에 데이터 호환 준비를 철저하게 해야합니다.
또한 **블루-그린 배포**에 비해 상대적으로 업데이터버전에 대한 테스트 기간과 환경이 짧아 검증이 충분하지 않을 수 있습니다. 블루-그린 배포의 방점은 새로 업데이트 된 버전에 대해 충분한 테스트 절차를 거치게 되어 업데이트에 대한 안정성을 가질 수 있습니다. 또한 신버전과 구버전이 독립된 환경에서 존재하기 때문에, 호환성에 대한 문제를 고려하지 않아도 됩니다. 검증 후에는 로드밸런서를 통해 빠르게 스위칭이 가능합니다. 다만 인프라 비용이 추가적으로 더 들고, 구버전, 신버전 환경을 동시에 유지/운영하기 때문에 빌드/배포 스크립트가 복잡해질 수 있습니다.
